################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

#=======================================================================================================================
#--------------------------------------------- GF 0.18um MCU DRC RULE DECK ---------------------------------------------
#=======================================================================================================================
require 'time'
require 'logger'
require 'etc'

exec_start_time = Time.now

logger = Logger.new($stdout)

logger.formatter = proc do |_severity, datetime, _progname, msg|
  "#{datetime}: Memory Usage (" + `pmap #{Process.pid} | tail -1`[10, 40].strip + ") : #{msg}
"
end

#================================================
#----------------- FILE SETUP -------------------
#================================================
logger.info("Starting running GF180MCU Klayout DRC runset on #{$input}")
logger.info("Ruby Version for klayout: #{RUBY_VERSION}")

if $input
  if $topcell
    source($input, $topcell)
  else
    source($input)
  end
end

logger.info('Loading database to memory is complete.')

if $report
  logger.info("GF180MCU Klayout DRC runset output at: #{$report}")
  report('DRC Run Report at', $report)
else
  layout_dir = Pathname.new(RBA::CellView.active.filename).parent.realpath
  report_path = layout_dir.join('gf180_drc.lyrdb').to_s
  logger.info("GF180MCU Klayout DRC runset output at default location: #{report_path}")
  report('DRC Run Report at', report_path)
end

#================================================
#------------------ SWITCHES --------------------
#================================================
logger.info('Evaluate switches.')

def bool_check?(obj)
  obj.to_s.downcase == 'true'
end

# connectivity rules
if $conn_drc == 'true'
  CONNECTIVITY_RULES = $conn_drc
  logger.info('connectivity rules are enabled.')
else
  CONNECTIVITY_RULES = false
  logger.info('connectivity rules are disabled.')
end

# WEDGE
WEDGE = bool_check?($wedge)

logger.info("Wedge enabled: #{WEDGE}")

# BALL
BALL = bool_check?($ball)

logger.info("Ball enabled: #{BALL}")

# GOLD
GOLD = bool_check?($gold)

logger.info("Gold enabled: #{GOLD}")

# MIM
MIM_OPTION = $mim_option || 'B'

logger.info("MIM Option selected: #{MIM_OPTION}")

# OFFGRID
OFFGRID = $offgrid != 'false'

logger.info("Offgrid enabled:  #{OFFGRID}")

# threads
if $thr
  threads($thr)
else
  thr ||= Etc.nprocessors
  threads(thr)
end

logger.info("Number of threads to use #{$thr}")

#=== PRINT DETAILS ===
logger.info("Verbose mode: #{$verbose}")
if $verbose == 'true'
  verbose(true)
else
  verbose(false)
end

# === TILING MODE ===
case $run_mode
when 'tiling'
  tiles(500.um)
  tile_borders(10.um)
  logger.info('Tiling  mode is enabled.')

when 'deep'
  #=== HIER MODE ===
  deep
  logger.info('deep  mode is enabled.')
else
  #=== FLAT MODE ===
  flat
  logger.info('flat  mode is enabled.')
end

# METAL_TOP
METAL_TOP = $metal_top || '9K'

logger.info("METAL_TOP Selected is #{METAL_TOP}")

# METAL_LEVEL
METAL_LEVEL = $metal_level || '5LM'

logger.info("METAL_STACK Selected is #{METAL_LEVEL}")

# FEOL
FEOL = bool_check?($feol)

logger.info("FEOL enabled: #{FEOL}")

# BEOL
BEOL = bool_check?($beol)

logger.info("BEOL enabled: #{BEOL}")

#================================================
#------------- LAYERS DEFINITIONS ---------------
#================================================
polygons_count = 0
logger.info('Read in polygons from layers.')

def get_polygons(layer, data_type)
  ps = polygons(layer, data_type)
  $run_mode == 'deep' ? ps : ps.merged
end

comp = get_polygons(22, 0)
count = comp.count
logger.info("comp has #{count} polygons")
polygons_count += count

dnwell = get_polygons(12, 0)
count = dnwell.count
logger.info("dnwell has #{count} polygons")
polygons_count += count

nwell = get_polygons(21, 0)
count = nwell.count
logger.info("nwell has #{count} polygons")
polygons_count += count

lvpwell = get_polygons(204, 0)
count = lvpwell.count
logger.info("lvpwell has #{count} polygons")
polygons_count += count

dualgate = get_polygons(55, 0)
count = dualgate.count
logger.info("dualgate has #{count} polygons")
polygons_count += count

poly2 = get_polygons(30, 0)
count = poly2.count
logger.info("poly2 has #{count} polygons")
polygons_count += count

nplus = get_polygons(32, 0)
count = nplus.count
logger.info("nplus has #{count} polygons")
polygons_count += count

pplus = get_polygons(31, 0)
count = pplus.count
logger.info("pplus has #{count} polygons")
polygons_count += count

sab = get_polygons(49, 0)
count = sab.count
logger.info("sab has #{count} polygons")
polygons_count += count

esd = get_polygons(24, 0)
count = esd.count
logger.info("esd has #{count} polygons")
polygons_count += count

resistor = get_polygons(62, 0)
count = resistor.count
logger.info("resistor has #{count} polygons")
polygons_count += count

fhres = get_polygons(227, 0)
count = fhres.count
logger.info("fhres has #{count} polygons")
polygons_count += count

fusetop = get_polygons(75, 0)
count = fusetop.count
logger.info("fusetop has #{count} polygons")
polygons_count += count

fusewindow_d = get_polygons(96, 1)
count = fusewindow_d.count
logger.info("fusewindow_d has #{count} polygons")
polygons_count += count

polyfuse = get_polygons(220, 0)
count = polyfuse.count
logger.info("polyfuse has #{count} polygons")
polygons_count += count

mvsd = get_polygons(210, 0)
count = mvsd.count
logger.info("mvsd has #{count} polygons")
polygons_count += count

mvpsd = get_polygons(11, 39)
count = mvpsd.count
logger.info("mvpsd has #{count} polygons")
polygons_count += count

nat = get_polygons(5, 0)
count = nat.count
logger.info("nat has #{count} polygons")
polygons_count += count

comp_dummy = get_polygons(22, 4)
count = comp_dummy.count
logger.info("comp_dummy has #{count} polygons")
polygons_count += count

poly2_dummy = get_polygons(30, 4)
count = poly2_dummy.count
logger.info("poly2_dummy has #{count} polygons")
polygons_count += count

schottky_diode = get_polygons(241, 0)
count = schottky_diode.count
logger.info("schottky_diode has #{count} polygons")
polygons_count += count

zener = get_polygons(178, 0)
count = zener.count
logger.info("zener has #{count} polygons")
polygons_count += count

res_mk = get_polygons(110, 5)
count = res_mk.count
logger.info("res_mk has #{count} polygons")
polygons_count += count

opc_drc = get_polygons(124, 5)
count = opc_drc.count
logger.info("opc_drc has #{count} polygons")
polygons_count += count

ndmy = get_polygons(111, 5)
count = ndmy.count
logger.info("ndmy has #{count} polygons")
polygons_count += count

pmndmy = get_polygons(152, 5)
count = pmndmy.count
logger.info("pmndmy has #{count} polygons")
polygons_count += count

v5_xtor = get_polygons(112, 1)
count = v5_xtor.count
logger.info("v5_xtor has #{count} polygons")
polygons_count += count

cap_mk = get_polygons(117, 5)
count = cap_mk.count
logger.info("cap_mk has #{count} polygons")
polygons_count += count

mos_cap_mk = get_polygons(166, 5)
count = mos_cap_mk.count
logger.info("mos_cap_mk has #{count} polygons")
polygons_count += count

ind_mk = get_polygons(151, 5)
count = ind_mk.count
logger.info("ind_mk has #{count} polygons")
polygons_count += count

diode_mk = get_polygons(115, 5)
count = diode_mk.count
logger.info("diode_mk has #{count} polygons")
polygons_count += count

drc_bjt = get_polygons(127, 5)
count = drc_bjt.count
logger.info("drc_bjt has #{count} polygons")
polygons_count += count

lvs_bjt = get_polygons(118, 5)
count = lvs_bjt.count
logger.info("lvs_bjt has #{count} polygons")
polygons_count += count

mim_l_mk = get_polygons(117, 10)
count = mim_l_mk.count
logger.info("mim_l_mk has #{count} polygons")
polygons_count += count

latchup_mk = get_polygons(137, 5)
count = latchup_mk.count
logger.info("latchup_mk has #{count} polygons")
polygons_count += count

guard_ring_mk = get_polygons(167, 5)
count = guard_ring_mk.count
logger.info("guard_ring_mk has #{count} polygons")
polygons_count += count

otp_mk = get_polygons(173, 5)
count = otp_mk.count
logger.info("otp_mk has #{count} polygons")
polygons_count += count

mtpmark = get_polygons(122, 5)
count = mtpmark.count
logger.info("mtpmark has #{count} polygons")
polygons_count += count

neo_ee_mk = get_polygons(88, 17)
count = neo_ee_mk.count
logger.info("neo_ee_mk has #{count} polygons")
polygons_count += count

sramcore = get_polygons(108, 5)
count = sramcore.count
logger.info("sramcore has #{count} polygons")
polygons_count += count

lvs_rf = get_polygons(100, 5)
count = lvs_rf.count
logger.info("lvs_rf has #{count} polygons")
polygons_count += count

lvs_drain = get_polygons(100, 7)
count = lvs_drain.count
logger.info("lvs_drain has #{count} polygons")
polygons_count += count

ind_mk = get_polygons(151, 5)
count = ind_mk.count
logger.info("ind_mk has #{count} polygons")
polygons_count += count

hvpolyrs = get_polygons(123, 5)
count = hvpolyrs.count
logger.info("hvpolyrs has #{count} polygons")
polygons_count += count

lvs_io = get_polygons(119, 5)
count = lvs_io.count
logger.info("lvs_io has #{count} polygons")
polygons_count += count

probe_mk = get_polygons(13, 17)
count = probe_mk.count
logger.info("probe_mk has #{count} polygons")
polygons_count += count

esd_mk = get_polygons(24, 5)
count = esd_mk.count
logger.info("esd_mk has #{count} polygons")
polygons_count += count

lvs_source = get_polygons(100, 8)
count = lvs_source.count
logger.info("lvs_source has #{count} polygons")
polygons_count += count

well_diode_mk = get_polygons(153, 51)
count = well_diode_mk.count
logger.info("well_diode_mk has #{count} polygons")
polygons_count += count

ldmos_xtor = get_polygons(226, 0)
count = ldmos_xtor.count
logger.info("ldmos_xtor has #{count} polygons")
polygons_count += count

plfuse = get_polygons(125, 5)
count = plfuse.count
logger.info("plfuse has #{count} polygons")
polygons_count += count

efuse_mk = get_polygons(80, 5)
count = efuse_mk.count
logger.info("efuse_mk has #{count} polygons")
polygons_count += count

mcell_feol_mk = get_polygons(11, 17)
count = mcell_feol_mk.count
logger.info("mcell_feol_mk has #{count} polygons")
polygons_count += count

ymtp_mk = get_polygons(86, 17)
count = ymtp_mk.count
logger.info("ymtp_mk has #{count} polygons")
polygons_count += count

dev_wf_mk = get_polygons(128, 17)
count = dev_wf_mk.count
logger.info("dev_wf_mk has #{count} polygons")
polygons_count += count

comp_label = get_polygons(22, 10)
count = comp_label.count
logger.info("comp_label has #{count} polygons")
polygons_count += count

poly2_label = get_polygons(30, 10)
count = poly2_label.count
logger.info("poly2_label has #{count} polygons")
polygons_count += count

mdiode = get_polygons(116, 5)
count = mdiode.count
logger.info("mdiode has #{count} polygons")
polygons_count += count

contact = get_polygons(33, 0)
count = contact.count
logger.info("contact has #{count} polygons")
polygons_count += count

metal1_drawn = get_polygons(34, 0)
count = metal1_drawn.count
logger.info("metal1_drawn has #{count} polygons")
polygons_count += count

metal1_dummy = get_polygons(34, 4)
count = metal1_dummy.count
logger.info("metal1_dummy has #{count} polygons")
polygons_count += count

metal1         = metal1_drawn + metal1_dummy

metal1_label = get_polygons(34, 10)
count = metal1_label.count
logger.info("metal1_label has #{count} polygons")
polygons_count += count

metal1_slot = get_polygons(34, 3)
count = metal1_slot.count
logger.info("metal1_slot has #{count} polygons")
polygons_count += count

metal1_blk = get_polygons(34, 5)
count = metal1_blk.count
logger.info("metal1_blk has #{count} polygons")
polygons_count += count

via1 = get_polygons(35, 0)
count = via1.count
logger.info("via1 has #{count} polygons")
polygons_count += count

metal2_drawn = get_polygons(36, 0)
count = metal2_drawn.count
logger.info("metal2_drawn has #{count} polygons")
polygons_count += count

metal2_dummy = get_polygons(36, 4)
count = metal2_dummy.count
logger.info("metal2_dummy has #{count} polygons")
polygons_count += count

metal2 = metal2_drawn + metal2_dummy

metal2_label = get_polygons(36, 10)
count = metal2_label.count
logger.info("metal2_label has #{count} polygons")
polygons_count += count

metal2_slot = get_polygons(36, 3)
count = metal2_slot.count
logger.info("metal2_slot has #{count} polygons")
polygons_count += count

metal2_blk = get_polygons(36, 5)
count = metal2_blk.count
logger.info("metal2_blk has #{count} polygons")
polygons_count += count

if METAL_LEVEL == '2LM'

  top_via       = via1
  topmin1_via   = contact
  top_metal     = metal2
  topmin1_metal = metal1

else

  via2 = get_polygons(38, 0)
  count = via2.count
  logger.info("via2 has #{count} polygons")
  polygons_count += count

  metal3_drawn = get_polygons(42, 0)
  count = metal3_drawn.count
  logger.info("metal3_drawn has #{count} polygons")
  polygons_count += count

  metal3_dummy = get_polygons(42, 4)
  count = metal3_dummy.count
  logger.info("metal3_dummy has #{count} polygons")
  polygons_count += count

  metal3 = metal3_drawn + metal3_dummy

  metal3_label = get_polygons(42, 10)
  count = metal3_label.count
  logger.info("metal3_label has #{count} polygons")
  polygons_count += count

  metal3_slot = get_polygons(42, 3)
  count = metal3_slot.count
  logger.info("metal3_slot has #{count} polygons")
  polygons_count += count

  metal3_blk = get_polygons(42, 5)
  count = metal3_blk.count
  logger.info("metal3_blk has #{count} polygons")
  polygons_count += count

  if METAL_LEVEL == '3LM'

    top_via       = via2
    topmin1_via   = via1
    top_metal     = metal3
    topmin1_metal = metal2
  else

    via3 = get_polygons(40, 0)
    count = via3.count
    logger.info("via3 has #{count} polygons")
    polygons_count += count

    metal4_drawn = get_polygons(46, 0)
    count = metal4_drawn.count
    logger.info("metal4_drawn has #{count} polygons")
    polygons_count += count

    metal4_dummy = get_polygons(46, 4)
    count = metal4_dummy.count
    logger.info("metal4_dummy has #{count} polygons")
    polygons_count += count

    metal4 = metal4_drawn + metal4_dummy

    metal4_label = get_polygons(46, 10)
    count = metal4_label.count
    logger.info("metal4_label has #{count} polygons")
    polygons_count += count

    metal4_slot = get_polygons(46, 3)
    count = metal4_slot.count
    logger.info("metal4_slot has #{count} polygons")
    polygons_count += count

    metal4_blk = get_polygons(46, 5)
    count = metal4_blk.count
    logger.info("metal4_blk has #{count} polygons")
    polygons_count += count

    if METAL_LEVEL == '4LM'

      top_via       = via3
      topmin1_via   = via2
      top_metal     = metal4
      topmin1_metal = metal3
    else

      via4 = get_polygons(41, 0)
      count = via4.count
      logger.info("via4 has #{count} polygons")
      polygons_count += count

      case METAL_LEVEL
      when '5LM'
        metal5_drawn = get_polygons(81, 0)
        count = metal5_drawn.count
        logger.info("metal5_drawn has #{count} polygons")
        polygons_count += count

        metal5_dummy = get_polygons(81, 4)
        count = metal5_dummy.count
        logger.info("metal5_dummy has #{count} polygons")
        polygons_count += count

        metal5 = metal5_drawn + metal5_dummy

        metal5_label = get_polygons(81, 10)
        count = metal5_label.count
        logger.info("metal5_label has #{count} polygons")
        polygons_count += count

        metal5_slot = get_polygons(81, 3)
        count = metal5_slot.count
        logger.info("metal5_slot has #{count} polygons")
        polygons_count += count

        metal5_blk = get_polygons(81, 5)
        count = metal5_blk.count
        logger.info("metal5_blk has #{count} polygons")
        polygons_count += count

        top_via       = via4
        topmin1_via   = via3
        top_metal     = metal5
        topmin1_metal = metal4
      when '6LM'
        metal5_drawn = get_polygons(81, 0)
        count = metal5_drawn.count
        logger.info("metal5_drawn has #{count} polygons")
        polygons_count += count

        metal5_dummy = get_polygons(81, 4)
        count = metal5_dummy.count
        logger.info("metal5_dummy has #{count} polygons")
        polygons_count += count

        metal5         = metal5_drawn + metal5_dummy

        metal5_label = get_polygons(81, 10)
        count = metal5_label.count
        logger.info("metal5_label has #{count} polygons")
        polygons_count += count

        metal5_slot = get_polygons(81, 3)
        count = metal5_slot.count
        logger.info("metal5_slot has #{count} polygons")
        polygons_count += count

        metal5_blk = get_polygons(81, 5)
        count = metal5_blk.count
        logger.info("metal5_blk has #{count} polygons")
        polygons_count += count

        via5 = get_polygons(82, 0)
        count = via5.count
        logger.info("via5 has #{count} polygons")
        polygons_count += count

        metaltop_drawn = get_polygons(53, 0)
        count = metaltop_drawn.count
        logger.info("metaltop_drawn has #{count} polygons")
        polygons_count += count

        metaltop_dummy = get_polygons(53, 4)
        count = metaltop_dummy.count
        logger.info("metaltop_dummy has #{count} polygons")
        polygons_count += count

        metaltop       = metaltop_drawn + metaltop_dummy

        metaltop_label = get_polygons(53, 10)
        count = metaltop_label.count
        logger.info("metaltop_label has #{count} polygons")
        polygons_count += count

        metaltop_slot = get_polygons(53, 3)
        count = metaltop_slot.count
        logger.info("metaltop_slot has #{count} polygons")
        polygons_count += count

        metalt_blk = get_polygons(53, 5)
        count = metalt_blk.count
        logger.info("metalt_blk has #{count} polygons")
        polygons_count += count

        top_via       = via5
        topmin1_via   = via4
        top_metal     = metaltop
        topmin1_metal = metal5
      else
        logger.error("Unknown metal stack #{METAL_LEVEL}")
        raise
      end
    end
  end
end

pad = get_polygons(37, 0)
count = pad.count
logger.info("pad has #{count} polygons")
polygons_count += count

ubmpperi = get_polygons(183, 0)
count = ubmpperi.count
logger.info("ubmpperi has #{count} polygons")
polygons_count += count

ubmparray = get_polygons(184, 0)
count = ubmparray.count
logger.info("ubmparray has #{count} polygons")
polygons_count += count

ubmeplate = get_polygons(185, 0)
count = ubmeplate.count
logger.info("ubmeplate has #{count} polygons")
polygons_count += count

metal1_res = get_polygons(110, 11)
count = metal1_res.count
logger.info("metal1_res has #{count} polygons")
polygons_count += count

metal2_res = get_polygons(110, 12)
count = metal2_res.count
logger.info("metal2_res has #{count} polygons")
polygons_count += count

metal3_res = get_polygons(110, 13)
count = metal3_res.count
logger.info("metal3_res has #{count} polygons")
polygons_count += count

metal4_res = get_polygons(110, 14)
count = metal4_res.count
logger.info("metal4_res has #{count} polygons")
polygons_count += count

metal5_res = get_polygons(110, 15)
count = metal5_res.count
logger.info("metal5_res has #{count} polygons")
polygons_count += count

metal6_res = get_polygons(110, 16)
count = metal6_res.count
logger.info("metal6_res has #{count} polygons")
polygons_count += count

pr_bndry = get_polygons(0, 0)
count = pr_bndry.count
logger.info("pr_bndry has #{count} polygons")
polygons_count += count

border = get_polygons(63, 0)
count = border.count
logger.info("border has #{count} polygons")
polygons_count += count
logger.info("Total no. of polygons in the design is #{polygons_count}")

logger.info('Starting deriving base layers.')

#=====================================================
#------------- BASE LAYERS DERIVATIONS ---------------
#=====================================================

dnwell_n        = dnwell.not(lvpwell)
dnwell_p        = dnwell.and(lvpwell)

all_nwell       = dnwell_n.join(nwell)

ncomp           = comp.and(nplus)
pcomp           = comp.and(pplus)
tgate           = poly2.and(comp).not(res_mk)

nactive         = ncomp.not(all_nwell)
ngate           = nactive.and(tgate)
nsd             = nactive.interacting(ngate).not(ngate).not(res_mk)
ptap            = pcomp.not(all_nwell).not(res_mk)

pactive         = pcomp.and(all_nwell)
pgate           = pactive.and(tgate)
psd             = pactive.interacting(pgate).not(pgate).not(res_mk)
ntap            = ncomp.and(all_nwell).not(res_mk)

ngate_dn        = ngate.and(dnwell_p)
ptap_dn         = ptap.and(dnwell_p).outside(well_diode_mk)

pgate_dn        = pgate.and(dnwell_n)
ntap_dn         = ntap.and(dnwell_n)

psd_dn          = pcomp.and(dnwell_n).interacting(pgate_dn).not(pgate_dn).not(res_mk)
nsd_dn          = ncomp.and(dnwell_p).interacting(ngate_dn).not(ngate_dn).not(res_mk)

natcomp        	= nat.and(comp)

# Gate
nom_gate = tgate.not(dualgate)
thick_gate = tgate.and(dualgate)

ngate_56V = ngate.and(dualgate)
pgate_56V = pgate.and(dualgate)

ngate_5V = ngate_56V.and(v5_xtor)
pgate_5V = pgate_56V.and(v5_xtor)

ngate_6V = ngate_56V.not(v5_xtor)
pgate_6V = pgate_56V.not(v5_xtor)

# DNWELL
dnwell_3p3v = dnwell.not_interacting(v5_xtor).not_interacting(dualgate)
dnwell_56v = dnwell.overlapping(dualgate)

# LVPWELL
lvpwell_dn = lvpwell.interacting(dnwell)
lvpwell_out = lvpwell.not_interacting(dnwell)

lvpwell_dn3p3v = lvpwell.and(dnwell_3p3v)
lvpwell_dn56v = lvpwell.and(dnwell_56v)

# NWELL
nwell_dn = nwell.interacting(dnwell)
nwell_n_dn = nwell.not_interacting(dnwell)

#================================================
#------------- LAYERS CONNECTIONS ---------------
#================================================

if CONNECTIVITY_RULES

  logger.info('Construct connectivity for the design.')

  connect(dnwell, ncomp)
  connect(ncomp,  contact)
  connect(pcomp,  contact)

  connect(lvpwell_out, pcomp)
  connect(lvpwell_dn, pcomp)

  connect(nwell, ncomp)
  connect(natcomp, contact)
  connect(mvsd, ncomp)
  connect(mvpsd, pcomp)
  connect(contact, metal1)
  connect(metal1,  via1)
  connect(via1,    metal2)
  if METAL_LEVEL != '2LM'
    connect(metal2,  via2)
    connect(via2,    metal3)

    if METAL_LEVEL != '3LM'
      connect(metal3,  via3)
      connect(via3,    metal4)

      if METAL_LEVEL != '4LM'
        connect(metal4,  via4)
        connect(via4,    metal5)

        if METAL_LEVEL != '5LM'
          connect(metal5,  via5)
          connect(via5,    metaltop)
        end
      end
    end
  end

end

#================================================
#------------ PRE-DEFINED FUNCTIONS -------------
#================================================

def conn_space_check(layer, not_conn_val, mode)
  unconnected_errors_unfiltered = layer.space(not_conn_val.um, mode)
  # Filter out the errors arising from the same net
  unconnected_errors = DRC::DRCLayer.new(self, RBA::EdgePairs.new)
  unconnected_errors_unfiltered.data.each do |ep|
    net1 = l2n_data.probe_net(layer.data, ep.first.p1)
    net2 = l2n_data.probe_net(layer.data, ep.second.p1)
    if !net1 || !net2
      logger.error("Connectivity check encountered 2 nets that doesn't exist. Potential issue in klayout...")
    elsif net1.circuit != net2.circuit || net1.cluster_id != net2.cluster_id
      # unconnected
      unconnected_errors.data.insert(ep)
    end
  end
  unconnected_errors
end

def conn_space(layer, conn_val, not_conn_val, mode)
  if layer.respond_to?(:nets) # KLayout version (>=0.28.4) which supports "nets"
    nets = layer.nets
    connected_output   = nets.space(conn_val.um, mode, props_eq).polygons(0.001.um)
    singularity_errors = nets.space(0.001.um, mode).polygons(0.001.um)
    unconnected_output = nets.space(not_conn_val.um, mode, props_ne).polygons(0.001.um).join(singularity_errors)
    nets.forget
  else
    raise 'ERROR : Wrong connectivity implementation' if conn_val > not_conn_val

    connected_output = layer.space(conn_val.um, mode).polygons(0.001.um)
    unconnected_errors = conn_space_check(layer, not_conn_val, mode)
    singularity_errors = layer.space(0.001.um, mode).polygons(0.001.um)
    unconnected_output = unconnected_errors.polygons.join(singularity_errors)
  end
  [connected_output, unconnected_output]
end

def conn_separation_check(_layer, not_conn_val, mode)
  unconnected_errors_unfiltered = layer1.separation(layer2, not_conn_val.um, mode)
  # Filter out the errors arising from the same net
  unconnected_errors = DRC::DRCLayer.new(self, RBA::EdgePairs.new)
  unconnected_errors_unfiltered.data.each do |ep|
    net1 = l2n_data.probe_net(layer1.data, ep.first.p1)
    net2 = l2n_data.probe_net(layer2.data, ep.second.p1)
    if !net1 || !net2
      logger.error("Connectivity check encountered 2 nets that doesn't exist. Potential issue in klayout...")
    elsif net1.circuit != net2.circuit || net1.cluster_id != net2.cluster_id
      # unconnected
      unconnected_errors.data.insert(ep)
    end
  end
  unconnected_errors
end

def conn_separation(layer1, layer2, conn_val, not_conn_val, mode)
  if layer1.respond_to?(:nets) # KLayout version (>=0.28.4) which supports "nets"
    nets1 = layer1.nets
    nets2 = layer2.nets
    connected_output   = nets1.separation(nets2, conn_val.um,     mode, props_eq).polygons(0.001.um)
    unconnected_output = nets1.separation(nets2, not_conn_val.um, mode, props_ne).polygons(0.001.um)
    nets1.forget
    nets2.forget
  else
    raise 'ERROR : Wrong connectivity implementation' if conn_val > not_conn_val

    connected_output = layer1.separation(layer2, conn_val.um, mode).polygons(0.001.um)
    unconnected_errors = conn_separation_check(layer, not_conn_val, mode)
    unconnected_output = unconnected_errors.polygons(0.001.um)
  end
  [connected_output, unconnected_output]
end

# === IMPLICIT EXTRACTION ===
if CONNECTIVITY_RULES
  logger.info('Connectivity rules enabled, Netlist object will be generated.')
  netlist
end

# === LAYOUT EXTENT ===
CHIP = extent.sized(0.0)
logger.info("Total area of the design is #{CHIP.area} um^2.")

#================================================
#----------------- MAIN RUNSET ------------------
#================================================

logger.info('Starting GF180MCU DRC rules.')
logger.info('Running all FEOL rules') if FEOL

logger.info('Running all BEOL rules') if BEOL
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #--------------------LVPWELL---------------------
  #================================================

  logger.info('Starting LVPWELL derivations')
  lvpwell_dn_MV = lvpwell_dn.interacting(dualgate)

  # Rule LPW.1_LV: Min. LVPWELL Width. is 0.6µm
  logger.info('Executing rule LPW.1_LV')
  lpw1_l1 = lvpwell_dn.width(0.6.um, euclidian)
  lpw1_l1.output('LPW.1_LV', 'LPW.1_LV : Min. LVPWELL Width. : 0.6µm')
  lpw1_l1.forget

  # Rule LPW.1_MV: Min. LVPWELL Width. is 0.74µm
  logger.info('Executing rule LPW.1_MV')
  lpw1_l1 = lvpwell_dn_MV.width(0.74.um, euclidian)
  lpw1_l1.output('LPW.1_MV', 'LPW.1_MV : Min. LVPWELL Width. : 0.74µm')
  lpw1_l1.forget

  if CONNECTIVITY_RULES
    logger.info('CONNECTIVITY_RULES section')

    connected_lvpwell_3p3v, unconnected_lvpwell_3p3v = conn_space(lvpwell_dn, 0.86, 1.4, euclidian)
    connected_lvpwell_5p0v, unconnected_lvpwell_5p0v = conn_space(lvpwell_dn, 0.86, 1.7, euclidian)

    # Rule LPW.2a_LV: Min. LVPWELL to LVWELL Space (Inside DNWELL) [Different potential]. is 1.4µm
    logger.info('Executing rule LPW.2a_LV')
    lpw2a_l1 = unconnected_lvpwell_3p3v.not_interacting(v5_xtor).not_interacting(dualgate)
    lpw2a_l1.output('LPW.2a_LV',
                    'LPW.2a_LV : Min. LVPWELL to LVWELL Space (Inside DNWELL) [Different potential]. : 1.4µm')
    lpw2a_l1.forget

    # Rule LPW.2a_MV: Min. LVPWELL to LVPWELL Space (Inside DNWELL) [Different potential]. is 1.7µm
    logger.info('Executing rule LPW.2a_MV')
    lpw2a_l1 = unconnected_lvpwell_5p0v.overlapping(dualgate)
    lpw2a_l1.output('LPW.2a_MV',
                    'LPW.2a_MV : Min. LVPWELL to LVPWELL Space (Inside DNWELL) [Different potential]. : 1.7µm')
    lpw2a_l1.forget

    # Rule LPW.2b_LV: Min. LVPWELL to LVPWELL Space [Equi potential]. is 0.86µm
    logger.info('Executing rule LPW.2b_LV')
    lpw2b_l1 = connected_lvpwell_3p3v.not_interacting(v5_xtor).not_interacting(dualgate)
    lpw2b_l1.output('LPW.2b_LV', 'LPW.2b_LV : Min. LVPWELL to LVPWELL Space [Equi potential]. : 0.86µm')
    lpw2b_l1.forget

    # Rule LPW.2b_MV: Min. LVPWELL to LVPWELL Space [Equi potential]. is 0.86µm
    logger.info('Executing rule LPW.2b_MV')
    lpw2b_l1 = connected_lvpwell_5p0v.overlapping(dualgate)
    lpw2b_l1.output('LPW.2b_MV', 'LPW.2b_MV : Min. LVPWELL to LVPWELL Space [Equi potential]. : 0.86µm')
    lpw2b_l1.forget

  else
    logger.info('CONNECTIVITY_RULES disabled section')

    # Rule LPW.2a_LV: Min. LVPWELL to LVWELL Space (Inside DNWELL) [Different potential]. is 1.4µm
    logger.info('Executing rule LPW.2a_LV')
    lpw2a_l1 = lvpwell_dn.isolated(1.4.um, euclidian)
    lpw2a_l1.output('LPW.2a_LV',
                    'LPW.2a_LV : Min. LVPWELL to LVWELL Space (Inside DNWELL) [Different potential]. : 1.4µm')
    lpw2a_l1.forget

    # Rule LPW.2a_MV: Min. LVPWELL to LVPWELL Space (Inside DNWELL) [Different potential]. is 1.7µm
    logger.info('Executing rule LPW.2a_MV')
    lpw2a_l1 = lvpwell_dn_MV.isolated(1.7.um, euclidian)
    lpw2a_l1.output('LPW.2a_MV',
                    'LPW.2a_MV : Min. LVPWELL to LVPWELL Space (Inside DNWELL) [Different potential]. : 1.7µm')
    lpw2a_l1.forget

  end

  # Rule LPW.3: Min. DNWELL enclose LVPWELL. is 2.5µm
  logger.info('Executing rule LPW.3_LV')
  lpw3_l1 = dnwell.enclosing(lvpwell_dn, 2.5.um, euclidian).polygons(0.001.um)
  lpw3_l2 = lvpwell_dn.not(dnwell)
  lpw3_l = lpw3_l1.or(lpw3_l2)
  lpw3_l.output('LPW.3', 'LPW.3 : Min. DNWELL enclose LVPWELL. : 2.5µm')
  lpw3_l1.forget
  lpw3_l2.forget
  lpw3_l.forget

  # Rule LPW.4 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_04.html

  # Rule LPW.5: LVPWELL resistors must be enclosed by DNWELL.
  logger.info('Executing rule LPW.5')
  lpw5_l1 = lvpwell.and(res_mk).not(dnwell)
  lpw5_l1.output('LPW.5', 'LPW.5 : LVPWELL resistors must be enclosed by DNWELL.')
  lpw5_l1.forget

  # Rule LPW.11: Min. (LVPWELL outside DNWELL) space to DNWELL. is 1.5µm
  logger.info('Executing rule LPW.11')
  lpw11_l = lvpwell.outside(dnwell).separation(dnwell, 1.5.um, euclidian)
  lpw11_l.output('LPW.11', 'LPW.11 : Min. (LVPWELL outside DNWELL) space to DNWELL. : 1.5µm')
  lpw11_l.forget

  # Rule LPW.12: LVPWELL cannot overlap with Nwell.
  logger.info('Executing rule LPW.12')
  lpw12_l1 = lvpwell.outside(dnwell).and(nwell)
  lpw12_l1.output('LPW.12', 'LPW.12 : LVPWELL cannot overlap with Nwell.')
  lpw12_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

# metal stack
if BEOL && (METAL_LEVEL == '6LM')
  #================================================
  #----------------------via5----------------------
  #================================================

  # Rule V5.1: Min/max Via1 size . is 0.26µm
  logger.info('Executing rule V5.1')
  v51_l1 = via5.edges.without_length(0.26.um)
  v51_l1.output('V5.1', 'V5.1 : Min/max Via1 size . : 0.26µm')
  v51_l1.forget

  # Rule V5.2a: min. via5 spacing is 0.26µm
  logger.info('Executing rule V5.2a')
  v52a_l1 = via5.space(0.26.um, euclidian)
  v52a_l1.output('V5.2a', 'V5.2a : min. via5 spacing : 0.26µm')
  v52a_l1.forget

  # Rule V5.2b: via5 Space in 4x4 or larger via5 array is 0.36µm
  logger.info('Executing rule V5.2b')
  via5_egde_length = 0.26 * 3 + 3 * 0.36
  poss_4_4_via5 = via5.sized(0.2, 'square_limit').merged.sized(-0.2, 'square_limit')
  via5_4x4_all = poss_4_4_via5.with_bbox_min(via5_egde_length..nil).interacting(via5, 16..nil)
  via5_4x4_loc_exc = via5_4x4_all.width(via5_egde_length,
                                        projection_limits(via5_egde_length..1000 * via5_egde_length)).polygons
  via5_4x4_loc = via5_4x4_all.not_interacting(via5_4x4_loc_exc)
  selected_via5 = via5.interacting(via5_4x4_loc)
  via5b_l1 = selected_via5.space(0.36.um, euclidian)
  via5b_l1.output('V5.2b', 'V5.2b : via5 Space in 4x4 or larger via5 array : 0.36µm')
  via5b_l1.forget
  poss_4_4_via5.forget
  via5_4x4_all.forget
  via5_4x4_loc_exc.forget
  via5_4x4_loc.forget
  selected_via5.forget

  # Rule V5.3a is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V5.3b: metal5  overlap of via5.
  logger.info('Executing rule V5.3b')
  v53b_l1 = via5.not(metal5)
  v53b_l2 = via5.enclosed(metal5, 0.01.um, euclidian).polygons(0.001.um)
  v53b_l = v53b_l1.or(v53b_l2)
  v53b_l.output('V5.3b', 'V5.3b : metal5 overlap of via5 >= 0.01')
  v53b_l1.forget
  v53b_l2.forget
  v53b_l.forget

  # Rule V5.3c: metal5 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V5.3c')
  v5p3c_cond = metal5.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v5p3c_eol_allowed = metal5.edges.with_length(nil, 0.34.um)
  v5p3c_eol = v5p3c_eol_allowed.interacting(v5p3c_cond.first_edges).interacting(v5p3c_cond.second_edges)
                               .not(v5p3c_cond.first_edges).not(v5p3c_cond.second_edges)
  v5p3c_l1 = via5.edges.enclosed(v5p3c_eol, 0.06.um, projection)
  v5p3c_l1.output('V5.3c', 'V5.3c : metal5 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v5p3c_l1.forget
  v5p3c_cond.forget
  v5p3c_eol.forget
  v5p3c_eol_allowed.forget

  # Rule V5.3d: If metal5 overlap via5 by < 0.04um on one side, adjacent metal5 edges overlap. : 0.06µm
  logger.info('Executing rule V5.3d')
  via5_3d_cond_edges = via5.edges.not_outside(via5.enclosed(metal5, 0.04.um, projection).edges)
  via5_3d_check_corner = via5_3d_cond_edges.extended_in(0.002.um)
  via5_3d_check = via5.edges.interacting(via5_3d_check_corner).not(via5_3d_cond_edges)
  via5_cond_corner = via5_3d_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via5_3d_l1 = via5_3d_check.enclosed(metal5.edges, 0.06.um, projection).polygons
  via5_3d_l2 = via5.interacting(via5_cond_corner)
  via5_3d_l = via5_3d_l1.or(via5_3d_l2)
  via5_3d_l.output('V5.3d',
                   'V5.3d : If metal5 overlap via5 by < 0.04um on one side, adjacent metal5 edges overlap. : 0.06µm')
  via5_3d_l.forget
  via5_3d_l2.forget
  via5_3d_l1.forget
  via5_3d_cond_edges.forget
  via5_3d_check_corner.forget
  via5_cond_corner.forget
  via5_3d_check.forget

  # Rule V5.3e is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V5.4a: metaltop overlap of via5.
  logger.info('Executing rule V5.4a')
  via5_4a_l1 = via5.enclosed(metaltop, 0.01.um, euclidian).polygons(0.001.um)
  via5_4a_l2 = via5.not(metaltop)
  via5_4a_l = via5_4a_l1.or(via5_4a_l2)
  via5_4a_l.output('V5.4a', 'V5.4a : metaltop overlap of via5 >= 0.01 um')
  via5_4a_l1.forget
  via5_4a_l2.forget
  via5_4a_l.forget

  # Rule V5.4b: metaltop (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V5.4b')
  v5p4b_cond = metaltop.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v5p4b_eol_allowed = metaltop.edges.with_length(nil, 0.34.um)
  v5p4b_cond_edge1 = v5p4b_cond.first_edges
  v5p4b_cond_edge2 = v5p4b_cond.second_edges
  v5p4b_eol = v5p4b_eol_allowed.interacting(v5p4b_cond_edge1).interacting(v5p4b_cond_edge2)
                               .not(v5p4b_cond_edge1).not(v5p4b_cond_edge2)
  v5p4b_l1 = via5.edges.enclosed(v5p4b_eol, 0.06.um, projection)
  v5p4b_l1.output('V5.4b', 'V5.4p : metaltop (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v5p4b_l1.forget
  v5p4b_cond.forget
  v5p4b_eol.forget
  v5p4b_eol_allowed.forget
  v5p4b_cond_edge1.forget
  v5p4b_cond_edge2.forget

  # Rule V5.4c: If metaltop overlap via5 by < 0.04um on one side,
  ## adjacent metaltop edges overlap. : 0.06µm
  logger.info('Executing rule V5.4c')
  via5_4c_cond_edges = via5.edges.not_outside(via5.enclosed(metaltop, 0.04.um, projection).edges)
  via5_4c_check_corner = via5_4c_cond_edges.extended_in(0.002.um)
  via5_4c_check = via5.edges.interacting(via5_4c_check_corner).not(via5_4c_cond_edges)
  via5_4c_cond_corner = via5_4c_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via5_4c_l1 = via5_4c_check.enclosed(metaltop.edges, 0.06.um, projection).polygons
  via5_4c_l2 = via5.interacting(via5_4c_cond_corner)
  via5_4c_l = via5_4c_l1.or(via5_4c_l2)
  via5_4c_l.output('V5.4c', 'V5.4c : If metaltop overlap via5 by < 0.04um on one side,
                    adjacent metaltop edges overlap. : 0.06µm')
  via5_4c_l.forget
  via5_4c_l2.forget
  via5_4c_l1.forget
  via5_4c_cond_edges.forget
  via5_4c_check_corner.forget
  via5_4c_cond_corner.forget
  via5_4c_check.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #----------------H POLY RESISTOR-----------------
  #================================================

  logger.info('Starting HRES derivations')
  hres_poly = poly2.interacting(pplus).interacting(sab).interacting(res_mk).interacting(resistor)
  hres1_poly = poly2.interacting(pplus).interacting(sab).interacting(res_mk)

  # Rule HRES.1: Minimum space. Note : Merge if the spacing is less than 0.4 um. is 0.4µm
  logger.info('Executing rule HRES.1')
  hres1_l1 = resistor.interacting(hres1_poly).space(0.4.um, euclidian)
  hres1_l1.output('HRES.1', 'HRES.1 : Minimum space. Note : Merge if the spacing is less than 0.4 um. : 0.4µm')
  hres1_l1.forget

  # Rule HRES.2: Minimum width of Poly2 resistor. is 1µm
  logger.info('Executing rule HRES.2')
  hres2_l1 = hres_poly.width(1.um, euclidian)
  hres2_l1.output('HRES.2', 'HRES.2 : Minimum width of Poly2 resistor. : 1µm')
  hres2_l1.forget

  # Rule HRES.3: Minimum space between Poly2 resistors. is 0.4µm
  logger.info('Executing rule HRES.3')
  hres3_l1 = hres_poly.space(0.4.um, euclidian)
  hres3_l1.output('HRES.3', 'HRES.3 : Minimum space between Poly2 resistors. : 0.4µm')
  hres3_l1.forget

  # Rule HRES.4: Minimum RESISTOR overlap of Poly2 resistor. is 0.4µm
  logger.info('Executing rule HRES.4')
  hres4_l1 = hres_poly.enclosed(resistor, 0.4.um, euclidian).polygons(0.001.um)
  hres4_l2 = hres_poly.not_outside(resistor).not(resistor)
  hres4_l  = hres4_l1.or(hres4_l2)
  hres4_l.output('HRES.4', 'HRES.4 : Minimum RESISTOR overlap of Poly2 resistor. : 0.4µm')
  hres4_l1.forget
  hres4_l2.forget
  hres4_l.forget

  # Rule HRES.5: Minimum RESISTOR space to unrelated Poly2. is 0.3µm
  logger.info('Executing rule HRES.5')
  hres5_l1 = resistor.interacting(hres1_poly).separation(poly2.not_interacting(sab), 0.3.um, euclidian)
  hres5_l1.output('HRES.5', 'HRES.5 : Minimum RESISTOR space to unrelated Poly2. : 0.3µm')
  hres5_l1.forget

  # Rule HRES.6: Minimum RESISTOR space to COMP.
  logger.info('Executing rule HRES.6')
  hres6_l1 = resistor.interacting(hres1_poly).separation(comp, 0.3.um, euclidian).polygons(0.001.um)
  hres6_l2 = comp.not_outside(resistor.interacting(hres1_poly))
  hres6_l = hres6_l1.or(hres6_l2)
  hres6_l.output('HRES.6', 'HRES.6 : Minimum RESISTOR space to COMP.')
  hres6_l.forget
  hres6_l1.forget
  hres6_l2.forget
  hres1_poly.forget

  # Rule HRES.7: Minimum Pplus overlap of contact on Poly2 resistor. is 0.2µm
  logger.info('Executing rule HRES.7')
  hres7_l1 = contact.and(hres_poly).enclosed(pplus, 0.2.um, euclidian).polygons(0.001.um)
  hres7_l2 = contact.and(hres_poly).not_outside(pplus).not(pplus)
  hres7_l  = hres7_l1.or(hres7_l2)
  hres7_l.output('HRES.7', 'HRES.7 : Minimum Pplus overlap of contact on Poly2 resistor. : 0.2µm')
  hres7_l1.forget
  hres7_l2.forget
  hres7_l.forget

  # Rule HRES.8: Space from salicide block to contact on Poly2 resistor.
  logger.info('Executing rule HRES.8')
  hres8_l1 = contact.and(hres_poly).separation(sab,
                                               0.22.um).polygons(0.001.um).or(contact.and(hres_poly).interacting(sab))
  hres8_l1.output('HRES.8', 'HRES.8 : Space from salicide block to contact on Poly2 resistor.')
  hres8_l1.forget

  # Rule HRES.9: Minimum salicide block overlap of Poly2 resistor in width direction.
  logger.info('Executing rule HRES.9')
  hres9_sab             = sab.interacting(pplus).interacting(res_mk).interacting(resistor)
  hres9_clear_sab       = hres9_sab.not(hres_poly)
  hres9_bad_inside_edge = hres9_sab.edges.inside_part(hres_poly).extended(0, 0, 0.001.um, 0.001.um).interacting(
    hres9_clear_sab, 1, 1
  )
  hres9_sab_hole = hres9_sab.holes.and(hres_poly)
  hres9_l1 = hres_poly.enclosed(hres9_sab, 0.28.um, euclidian).polygons(0.001.um)
  hres9_l2 = hres9_bad_inside_edge.or(hres9_sab_hole)
  hres9_l = hres9_l1.or(hres9_l2)
  hres9_l.output('HRES.9', 'HRES.9 : Minimum salicide block overlap of Poly2 resistor in width direction.')
  hres9_l.forget
  hres9_l1.forget
  hres9_l2.forget
  hres9_sab.forget
  hres9_clear_sab.forget
  hres9_bad_inside_edge.forget
  hres9_sab_hole.forget

  # Rule HRES.10: Minimum & maximum Pplus overlap of SAB.
  logger.info('Executing rule HRES.10')
  pplus1_hres10 = pplus.and(sab).drc(width != 0.1.um)
  pplus2_hres10 = pplus.not_overlapping(sab).edges
  hres10_l1 = pplus1_hres10.or(pplus2_hres10).extended(0, 0, 0.001.um, 0.001.um).interacting(hres_poly)
  hres10_l1.output('HRES.10', 'HRES.10 : Minimum & maximum Pplus overlap of SAB.')
  hres10_l1.forget
  pplus1_hres10.forget
  pplus2_hres10.forget

  # Rule HRES.11 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_03.html#hres-poly-resistor-phres-optional-with-one-additional-mask

  # Rule HRES.12a: P type Poly2 resistor (high sheet rho) shall be covered by RES_MK marking.
  ## RES_MK length shall be coincide with resistor length (Defined by Pplus space)
  ## and width covering the width of Poly2.
  logger.info('Executing rule HRES.12a')
  mk_hres12a = res_mk.edges.not(poly2.not(pplus).and(sab).edges).inside_part(poly2)
  hres12a_l1 = res_mk.interacting(resistor).interacting(mk_hres12a)
  hres12a_l1.output('HRES.12a',
                    'HRES.12a : P type Poly2 resistor (high sheet rho) shall be covered by RES_MK marking.
                     RES_MK length shall be coincide with resistor length (Defined by Pplus space)
                     and width covering the width of Poly2. ')
  hres12a_l1.forget
  mk_hres12a.forget

  # Rule HRES.12b: If the size of single RES_MK mark layer is greater than 15000 um2
  ## and both side (X and Y) are greater than 80 um.
  ## Then the minimum spacing to adjacent RES_MK layer. is 20µm
  logger.info('Executing rule HRES.12b')
  hres12b = res_mk.with_area(15_000.001.um, nil).edges.with_length(80.001.um, nil)
  hres12b_l1 = hres12b.separation(res_mk.edges, 20.um)
  hres12b_l1.output('HRES.12b',
                    'HRES.12b : If the size of single RES_MK mark layer is greater than 15000 um2
                     and both side (X and Y) are greater than 80 um.
                     Then the minimum spacing to adjacent RES_MK layer. : 20µm')
  hres12b_l1.forget
  hres12b.forget
  hres_poly.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #---------------------MCELL----------------------
  #================================================

  # Rule MC.1: min. mcell width is 0.4µm
  logger.info('Executing rule MC.1')
  mc1_l1 = mcell_feol_mk.width(0.4.um, euclidian)
  mc1_l1.output('MC.1', 'MC.1 : min. mcell width : 0.4µm')
  mc1_l1.forget

  # Rule MC.2: min. mcell spacing is 0.4µm
  logger.info('Executing rule MC.2')
  mc2_l1 = mcell_feol_mk.space(0.4.um, euclidian)
  mc2_l1.output('MC.2', 'MC.2 : min. mcell spacing : 0.4µm')
  mc2_l1.forget

  # Rule MC.3: Minimum Mcell area is 0.35µm²
  logger.info('Executing rule MC.3')
  mc3_l1 = mcell_feol_mk.with_area(nil, 0.35.um)
  mc3_l1.output('MC.3', 'MC.3 : Minimum Mcell area : 0.35µm²')
  mc3_l1.forget

  # Rule MC.4: Minimum area enclosed by Mcell is 0.35µm²
  logger.info('Executing rule MC.4')
  mc4_l1 = mcell_feol_mk.holes.with_area(nil, 0.35.um)
  mc4_l1.output('MC.4', 'MC.4 : Minimum area enclosed by Mcell : 0.35µm²')
  mc4_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #---------------------PPLUS----------------------
  #================================================

  logger.info('Starting PPLUS derivations')

  nplus_edges = nplus.edges
  pplus_edges = pplus.edges
  ncomp_edges = ncomp.edges
  pcomp_butted = pcomp.interacting(ncomp)
  pplus_butted_edges = pplus.edges.and(ncomp.edges)
  nwell_n_dn_sized_out = nwell_n_dn.sized(0.429.um)
  nwell_n_dn_sized_in  = nwell_n_dn.sized(-0.429.um)
  lvpwell_dn_sized_out = lvpwell_dn.sized(0.429.um)
  lvpwell_dn_sized_in  = lvpwell_dn.sized(-0.429.um)

  # Rule PP.1: min. pplus width is 0.4µm
  logger.info('Executing rule PP.1')
  pp1_l1 = pplus.width(0.4.um, euclidian)
  pp1_l1.output('PP.1', 'PP.1 : min. pplus width : 0.4µm')
  pp1_l1.forget

  # Rule PP.2: min. pplus spacing is 0.4µm
  logger.info('Executing rule PP.2')
  pp2_l1 = pplus.space(0.4.um, euclidian)
  pp2_l1.output('PP.2', 'PP.2 : min. pplus spacing : 0.4µm')
  pp2_l1.forget

  # Rule PP.3a: Space to NCOMP for NCOMP (1) inside LVPWELL (2) outside NWELL and DNWELL. is 0.16µm
  logger.info('Executing rule PP.3a')
  pp3_pplus = pplus.not_interacting(pcomp_butted)
  pp3a_ncomp = ncomp.and(lvpwell).join(ncomp.not(nwell_n_dn))
  pp3a_l1 = pp3_pplus.separation(pp3a_ncomp, 0.16.um, euclidian)
  pp3a_l1.output('PP.3a',
                 'PP.3a : Space to NCOMP for NCOMP (1) inside LVPWELL (2) outside NWELL and DNWELL: 0.16µm')
  pp3a_l1.forget
  pp3a_ncomp.forget

  # Rule PP.3bi: Space to NCOMP: For Inside DNWELL. (i) NCOMP space to LVPWELL >= 0.43um is 0.08µm.
  logger.info('Executing rule PP.3bi')
  pp_3bi_ncomp = ncomp.not(lvpwell_dn_sized_out)
  pp3bi_l1 = pp3_pplus.and(dnwell).separation(pp_3bi_ncomp, 0.08.um, euclidian)
  pp3bi_l1.output('PP.3bi',
                  'PP.3bi : Space to NCOMP: For Inside DNWELL. (i) NCOMP space to LVPWELL >= 0.43um: 0.08µm')
  pp3bi_l1.forget
  pp_3bi_ncomp.forget

  # Rule PP.3bii: Space to NCOMP: For Inside DNWELL.
  ## (ii) NCOMP space to LVPWELL < 0.43um. is 0.16µm
  logger.info('Executing rule PP.3bii')
  pp_3bii_ncomp = ncomp.and(lvpwell_dn_sized_out)
  pp3bii_l1 = pp3_pplus.and(dnwell).separation(pp_3bii_ncomp, 0.16.um, euclidian)
  pp3bii_l1.output('PP.3bii', "PP.3bii : Space to NCOMP: For Inside DNWELL.
                      (ii) NCOMP space to LVPWELL < 0.43um. : 0.16µm")
  pp3bii_l1.forget
  pp_3bii_ncomp.forget

  # Rule PP.3ci: Space to NCOMP: For Outside DNWELL, inside Nwell:
  ## (i) NWELL Overlap of NCOMP >= 0.43um is 0.08µm.
  logger.info('Executing rule PP.3ci')
  pp_3ci_ncomp = ncomp.and(nwell_n_dn_sized_in)
  pp3ci_l1 = pp3_pplus.and(nwell_n_dn).separation(pp_3ci_ncomp, 0.08.um, euclidian)
  pp3ci_l1.output('PP.3ci', "PP.3ci : Space to NCOMP: For Outside DNWELL, inside Nwell:
                    (i) NWELL Overlap of NCOMP >= 0.43um: 0.08µm")
  pp3ci_l1.forget
  pp_3ci_ncomp.forget

  # Rule PP.3cii: Space to NCOMP: For Outside DNWELL, inside Nwell:
  ## (ii) NWELL Overlap of NCOMP 0.43um. is 0.16µm
  logger.info('Executing rule PP.3cii')
  pp_3cii_ncomp = ncomp.and(nwell_n_dn.not(nwell_n_dn_sized_in))
  pp3cii_l1 = pp3_pplus.and(nwell_n_dn).separation(pp_3cii_ncomp, 0.16.um, euclidian)
  pp3cii_l1.output('PP.3cii', "PP.3cii : Space to NCOMP: For Outside DNWELL, inside Nwell:
                     (ii) NWELL Overlap of NCOMP 0.43um. : 0.16µm")
  pp3cii_l1.forget
  pp_3cii_ncomp.forget

  # Rule PP.3d: Min/max space to a butted NCOMP is 0um.
  logger.info('Executing rule PP.3d')
  pp3d_l1 = pcomp.and(ncomp)
  pp3d_l1.output('PP.3d', 'PP.3d : Min/max space to a butted NCOMP: 0um')
  pp3d_l1.forget

  # Rule PP.3e: Space to NCOMP edge adjacent to a butting edge is 0um.
  logger.info('Executing rule PP.3e')
  pp3e_l1 = pplus.and(ncomp)
  pp3e_l1.output('PP.3e', 'PP.3e : Space to NCOMP edge adjacent to a butting edge: 0um')
  pp3e_l1.forget

  # Rule PP.4a: Space related to N-channel gate at a butting edge parallel to gate. is 0.32µm
  logger.info('Executing rule PP.4a')
  pp4a_l1 = pplus_edges.and(ncomp_edges).separation(ngate.edges, 0.32.um, projection)
  pp4a_l1.output('PP.4a', 'PP.4a : Space related to N-channel gate at a butting edge parallel to gate. : 0.32µm')
  pp4a_l1.forget

  # Rule PP.4b: Within 0.32um of channel, space to N-channel gate
  ## extension perpendicular to the direction of Poly2.
  logger.info('Executing rule PP.4b')
  pp_4b_poly = poly2.edges.interacting(ngate.edges.not(ncomp_edges)).centers(0, 0.99).and(ngate.sized(0.32.um))
  pp4b_l1 = pplus.interacting(pplus_edges.separation(pp_4b_poly, 0.22.um, projection).polygons(0.001.um))
  pp4b_l1.output('PP.4b', "PP.4b : Within 0.32um of channel, space to N-channel gate
                    extension perpendicular to the direction of Poly2.")
  pp4b_l1.forget
  pp_4b_poly.forget

  # Rule PP.5a: Overlap of P-channel gate. is 0.23µm
  logger.info('Executing rule PP.5a')
  pp5a_l1 = pplus.enclosing(pgate, 0.23.um, euclidian).polygons(0.001.um)
  pp5a_l2 = pgate.not_outside(pplus).not(pplus)
  pp5a_l  = pp5a_l1.or(pp5a_l2)
  pp5a_l.output('PP.5a', 'PP.5a : Overlap of P-channel gate. : 0.23µm')
  pp5a_l1.forget
  pp5a_l2.forget
  pp5a_l.forget

  # Rule PP.5b: Extension beyond COMP for COMP
  ## (1) Inside NWELL (2) outside LVPWELL but inside DNWELL. is 0.16µm
  logger.info('Executing rule PP.5b')
  pp5b_pplus_slct = pplus.edges.not(pplus_butted_edges)
  pp5b_pplus = pp5b_pplus_slct.and(nwell).join(pp5b_pplus_slct.not(lvpwell).and(dnwell))
  pp5b_l1 = pcomp.edges.enclosed(pp5b_pplus, 0.16.um, projection)
  pp5b_l1.output('PP.5b', 'PP.5b : Extension beyond COMP for COMP
                 (1) Inside NWELL (2) outside LVPWELL but inside DNWELL. : 0.16µm')
  pp5b_l1.forget
  pp5b_pplus.forget
  pp5b_pplus_slct.forget

  # Rule PP.5ci: Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
  ##  (i) For LVPWELL overlap of Pplus >= 0.43um for LVPWELL tap. is 0.02µm
  logger.info('Executing rule PP.5ci')
  pp_5ci_background = pplus.not_outside(lvpwell).inside(dnwell).edges.not(nplus_edges)
  pp_5ci_foreground = pcomp.not_outside(lvpwell).inside(dnwell).edges.not(nplus_edges).inside_part(lvpwell_dn_sized_in)
  pp5ci_l1 = pp_5ci_background.enclosing(pp_5ci_foreground, 0.02.um, euclidian)
  pp5ci_l1.output('PP.5ci', "PP.5ci : Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
                    (i) For LVPWELL overlap of Pplus >= 0.43um for LVPWELL tap. : 0.02µm")
  pp5ci_l1.forget
  pp_5ci_background.forget
  pp_5ci_foreground.forget

  # Rule PP.5cii: Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
  ## (ii) For LVPWELL overlap of Pplus < 0.43um for the LVPWELL tap. is 0.16µm
  logger.info('Executing rule PP.5cii')
  pp_5cii_background = pplus.not_outside(lvpwell).inside(dnwell).edges
  pp_5cii_extend = lvpwell_dn.not(lvpwell_dn_sized_in)
  pp_5cii_foreground = pcomp.not_outside(lvpwell).inside(dnwell).edges.not(nplus_edges).and(pp_5cii_extend)
  pp5cii_l1 = pp_5cii_background.enclosing(pp_5cii_foreground, 0.16.um, projection)
  pp5cii_l1.output('PP.5cii', "PP.5cii : Extension beyond COMP: For Inside DNWELL, inside LVPWELL:
                     (ii) For LVPWELL overlap of Pplus < 0.43um for the LVPWELL tap. : 0.16µm")
  pp5cii_l1.forget
  pp_5cii_background.forget
  pp_5cii_extend.forget
  pp_5cii_foreground.forget
  lvpwell_dn_sized_in.forget

  # Rule PP.5di: Extension beyond COMP: For Outside DNWELL
  ## (i) For Pplus to NWELL space >= 0.43um for Pfield or LVPWELL tap. is 0.02µm
  logger.info('Executing rule PP.5di')
  pp_5d_background = pplus.outside(dnwell).edges
  pp_5d_pcomp = pcomp.outside(dnwell).edges
  pp_5di_foreground = pp_5d_pcomp.not(nplus_edges).not(nwell_n_dn_sized_out)
  pp5di_l1 = pp_5d_background.enclosing(pp_5di_foreground, 0.02.um, projection)
  pp5di_l1.output('PP.5di', "PP.5di : Extension beyond COMP: For Outside DNWELL
                    (i) For Pplus to NWELL space >= 0.43um for Pfield or LVPWELL tap. : 0.02µm")
  pp5di_l1.forget
  pp_5di_foreground.forget

  # Rule PP.5dii: Extension beyond COMP: For Outside DNWELL
  ## (ii) For Pplus to NWELL space < 0.43um for Pfield or LVPWELL tap. is 0.16µm
  logger.info('Executing rule PP.5dii')
  pp_5dii_foreground = pp_5d_pcomp.not(nplus_edges).and(nwell_n_dn_sized_out)
  pp5dii_l1 = pp_5d_background.enclosing(pp_5dii_foreground, 0.16.um, projection)
  pp5dii_l1.output('PP.5dii', "PP.5dii : Extension beyond COMP: For Outside DNWELL
                     (ii) For Pplus to NWELL space < 0.43um for Pfield or LVPWELL tap. : 0.16µm")
  pp5dii_l1.forget
  pp_5d_background.forget
  pp_5dii_foreground.forget
  nplus_edges.forget
  pp_5d_pcomp.forget
  nwell_n_dn_sized_out.forget

  # Rule PP.6: Overlap with PCOMP butted to NCOMP. is 0.22µm
  logger.info('Executing rule PP.6')
  pp6_l1 = comp.interacting(pplus).enclosing(ncomp.interacting(pplus), 0.22.um, projection).polygons
  pp6_l1.output('PP.6', 'PP.6 : Overlap with PCOMP butted to NCOMP. : 0.22µm')
  pp6_l1.forget

  # Rule PP.7: Space to unrelated unsalicided Poly2. is 0.18µm
  logger.info('Executing rule PP.7')
  pp7_l1 = pplus.separation(poly2.and(sab), 0.18.um, euclidian)
  pp7_l1.output('PP.7', 'PP.7 : Space to unrelated unsalicided Poly2. : 0.18µm')
  pp7_l1.forget

  # Rule PP.8a: Minimum Pplus area (um2). is 0.35µm²
  logger.info('Executing rule PP.8a')
  pp8a_l1 = pplus.with_area(nil, 0.35.um)
  pp8a_l1.output('PP.8a', 'PP.8a : Minimum Pplus area (um2). : 0.35µm²')
  pp8a_l1.forget

  # Rule PP.8b: Minimum area enclosed by Pplus (um2). is 0.35µm²
  logger.info('Executing rule PP.8b')
  pp8b_l1 = pplus.holes.with_area(nil, 0.35.um)
  pp8b_l1.output('PP.8b', 'PP.8b : Minimum area enclosed by Pplus (um2). : 0.35µm²')
  pp8b_l1.forget

  # Rule PP.9: Overlap of unsalicided Poly2. is 0.18µm
  logger.info('Executing rule PP.9')
  pp9_l1 = pplus.enclosing(poly2.not_interacting(resistor).and(sab), 0.18.um, euclidian).polygons(0.001.um)
  pp9_l2 = poly2.not_interacting(resistor).and(sab).not_outside(pplus).not(pplus)
  pp9_l  = pp9_l1.or(pp9_l2)
  pp9_l.output('PP.9', 'PP.9 : Overlap of unsalicided Poly2. : 0.18µm')
  pp9_l1.forget
  pp9_l2.forget
  pp9_l.forget

  # Rule PP.10: Overlap of unsalicided COMP. is 0.18µm
  logger.info('Executing rule PP.10')
  pp10_l1 = pplus.enclosing(comp.and(sab), 0.18.um, euclidian)
  pp10_l1.output('PP.10', 'PP.10 : Overlap of unsalicided COMP. : 0.18µm')
  pp10_l1.forget

  # Rule PP.11: Butting Pplus and NCOMP is forbidden within 0.43um of Nwell edge
  ## (for outside DNWELL) and of LVPWELL edge (for inside DNWELL case).
  logger.info('Executing rule PP.11')
  pp_11_nwell_exclusion_area = nwell_n_dn.not(nwell_n_dn_sized_in)
  pp_11_lvpwell_exclude_area = lvpwell_dn_sized_out.not(lvpwell_dn)
  pp11_l1 = pplus_butted_edges.and(pp_11_nwell_exclusion_area)
  pp11_l2 = pplus_butted_edges.and(pp_11_lvpwell_exclude_area)
  pp11_l = pp11_l1.join(pp11_l2)
  pp11_l.output('PP.11', "PP.11 : Butting Pplus and NCOMP is forbidden within 0.43um of Nwell edge
                    (for outside DNWELL) and of LVPWELL edge (for inside DNWELL case).")
  pp11_l.forget
  pp11_l1.forget
  pp11_l2.forget
  pp_11_nwell_exclusion_area.forget
  pp_11_lvpwell_exclude_area.forget
  pplus_butted_edges.forget
  nwell_n_dn_sized_in.forget
  lvpwell_dn_sized_out.forget

  # Rule PP.12: Overlap with N-channel Poly2 gate extension is forbidden
  ##  within 0.32um of N-channel gate.
  logger.info('Executing rule PP.12')
  pp12_l1 = pplus.interacting(pplus_edges.separation(ngate.edges.and(ncomp_edges), 0.32.um,
                                                     euclidian).polygons(0.001.um))
  pp12_l1.output('PP.12', "PP.12 : Overlap with N-channel Poly2 gate extension is forbidden
                    within 0.32um of N-channel gate.")
  pp12_l1.forget
  pplus_edges.forget
  ncomp_edges.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

# METAL_LEVEL
if BEOL && (METAL_LEVEL == '4LM' || METAL_LEVEL == '5LM' || METAL_LEVEL == '6LM')
  #================================================
  #---------------------METAL3---------------------
  #================================================

  # Rule M3.1: min. metal3 width is 0.28µm
  logger.info('Executing rule M3.1')
  m31_l1 = metal3.width(0.28.um, euclidian)
  m31_l1.output('M3.1', 'M3.1 : min. metal3 width : 0.28µm')
  m31_l1.forget

  # Rule M3.2a: min. metal3 spacing is 0.28µm
  logger.info('Executing rule M3.2a')
  m32a_l1 = metal3.space(0.28.um, euclidian)
  m32a_l1.output('M3.2a', 'M3.2a : min. metal3 spacing : 0.28µm')
  m32a_l1.forget

  # Rule M3.2b: Space to wide Metal3 (length & width > 10um) is 0.3µm
  logger.info('Executing rule M3.2b')
  wide_m3 = metal3.not_interacting(metal3.edges.with_length(nil, 10.um))
  m32b_l1 = metal3.separation(wide_m3, 0.3.um, euclidian)
  m32b_l1.output('M3.2b', 'M3.2b : Space to wide Metal3 (length & width > 10um) : 0.3µm')
  m32b_l1.forget
  wide_m3.forget

  # Rule M3.3: Minimum metal3 area is 0.1444µm²
  logger.info('Executing rule M3.3')
  m33_l1 = metal3.with_area(nil, 0.1444.um)
  m33_l1.output('M3.3', 'M3.3 : Minimum metal3 area : 0.1444µm²')
  m33_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #----------------P+ POLY RESISTOR----------------
  #================================================

  logger.info('Starting PRES derivations')
  pres_poly = poly2.and(pplus).interacting(sab).interacting(res_mk).not_interacting(resistor)

  # Rule PRES.1: Minimum width of Poly2 resistor. is 0.8µm
  logger.info('Executing rule PRES.1')
  pres1_l1 = pres_poly.width(0.8.um, euclidian)
  pres1_l1.output('PRES.1', 'PRES.1 : Minimum width of Poly2 resistor. : 0.8µm')
  pres1_l1.forget

  # Rule PRES.2: Minimum space between Poly2 resistors. is 0.4µm
  logger.info('Executing rule PRES.2')
  pres2_l1 = pres_poly.isolated(0.4.um, euclidian)
  pres2_l1.output('PRES.2', 'PRES.2 : Minimum space between Poly2 resistors. : 0.4µm')
  pres2_l1.forget

  # Rule PRES.3: Minimum space from Poly2 resistor to COMP.
  logger.info('Executing rule PRES.3')
  pres3_l1 = pres_poly.separation(comp, 0.6.um, euclidian).polygons(0.001.um)
  pres3_l2 = comp.not_outside(pres_poly)
  pres3_l  = pres3_l1.or(pres3_l2)
  pres3_l.output('PRES.3', 'PRES.3 : Minimum space from Poly2 resistor to COMP.')
  pres3_l.forget
  pres3_l1.forget
  pres3_l2.forget

  # Rule PRES.4: Minimum space from Poly2 resistor to unrelated Poly2. is 0.6µm
  logger.info('Executing rule PRES.4')
  pres4_l1 = pres_poly.separation(poly2.not_interacting(sab), 0.6.um, euclidian)
  pres4_l1.output('PRES.4', 'PRES.4 : Minimum space from Poly2 resistor to unrelated Poly2. : 0.6µm')
  pres4_l1.forget

  # Rule PRES.5: Minimum Plus implant overlap of Poly2 resistor. is 0.3µm
  logger.info('Executing rule PRES.5')
  pres5_l1 = pres_poly.enclosed(pplus, 0.3.um, euclidian).polygons(0.001.um)
  pres5_l2 = pres_poly.not_outside(pplus).not(pplus)
  pres5_l  = pres5_l1.or(pres5_l2)
  pres5_l.output('PRES.5', 'PRES.5 : Minimum Plus implant overlap of Poly2 resistor. : 0.3µm')
  pres5_l1.forget
  pres5_l2.forget
  pres5_l.forget

  # Rule PRES.6: Minimum salicide block overlap of Poly2 resistor in width direction. is 0.28µm
  logger.info('Executing rule PRES.6')
  pres6_l1 = pres_poly.enclosed(sab, 0.28.um)
  pres6_l1.output('PRES.6', 'PRES.6 : Minimum salicide block overlap of Poly2 resistor in width direction. : 0.28µm')
  pres6_l1.forget

  # Rule PRES.7: Space from salicide block to contact on Poly2 resistor.
  logger.info('Executing rule PRES.7')
  pres7_l1 = contact.and(pres_poly).separation(sab, 0.22.um).polygons(0.001.um)
  pres7_l2 = contact.and(pres_poly).interacting(sab)
  pres7_l = pres7_l1.or(pres7_l2)
  pres7_l.output('PRES.7', 'PRES.7 : Space from salicide block to contact on Poly2 resistor.')
  pres7_l1.forget
  pres7_l2.forget

  # Rule PRES.8 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_01.html#p-poly-resistor-pres

  # Rule PRES.9a: Pplus Poly2 resistor shall be covered by RES_MK marking.
  ## RES_MK length shall be coincide with resistor length (Defined by SAB length)
  ## and width covering the width of Poly2.
  logger.info('Executing rule PRES.9a')
  mk_pres9a = res_mk.edges.not(poly2.and(pplus).and(sab).edges).inside_part(poly2)
  pres9a_l1 = res_mk.interacting(pres_poly).interacting(mk_pres9a)
  pres9a_l1.output('PRES.9a',
                   'PRES.9a : Pplus Poly2 resistor shall be covered by RES_MK marking.
                    RES_MK length shall be coincide with resistor length (Defined by SAB length)
                    and width covering the width of Poly2.')
  pres9a_l1.forget
  mk_pres9a.forget

  # Rule PRES.9b: If the size of single RES_MK mark layer is greater than 15000um2
  ## and both side (X and Y) are greater than 80um.
  ## then the minimum spacing to adjacent RES_MK layer. is 20µm
  logger.info('Executing rule PRES.9b')
  pres9b = res_mk.with_area(15_000.001.um, nil).edges.with_length(80.001.um, nil)
  pres9b_l1 = pres9b.separation(res_mk.edges, 20.um)
  pres9b_l1.output('PRES.9b',
                   'PRES.9b : If the size of single RES_MK mark layer is greater than 15000um2
                    and both side (X and Y) are greater than 80um.
                    then the minimum spacing to adjacent RES_MK layer. : 20µm')
  pres9b_l1.forget
  pres9b.forget
  pres_poly.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

#================================================
#--------------DUMMY EXCLUDE LAYERS--------------
#================================================

# Rule DE.1 is not a DRC check
## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_08.html#design-rules-for-dummy-exclude-layers-ndmy-and-pmndmy

# Rule DE.2: Minimum NDMY or PMNDMY size (x or y dimension in um) is 0.8µm.
logger.info('Executing rule DE.2')
de2_l1 = ndmy.or(pmndmy).width(0.8.um, euclidian)
de2_l1.output('DE.2', 'DE.2 : Minimum NDMY or PMNDMY size (x or y dimension in um) : 0.8µm')
de2_l1.forget

# Rule DE.3: Maximum NDMY size (um2) is 15000 um2.
## If size greater than 15000 um2 then two sides should not be greater than (80 um).
logger.info('Executing rule DE.3')
de3_ndmy_area = ndmy.with_area(15_000.um, nil).edges
de3_l1 = de3_ndmy_area.with_length(80.001.um, nil)
de3_l = de3_ndmy_area.join(de3_l1)
de3_l.output('DE.3', 'DE.3 : Maximum NDMY size (um2): 15000 um2.
              If size greater than 15000 um2 then two sides should not be greater than (80 um).')
de3_l.forget
de3_l1.forget
de3_ndmy_area.forget

# Rule DE.4: Minimum NDMY to NDMY space (Merge if space is less) is 20µm.
logger.info('Executing rule DE.4')
de4_l1 = ndmy.space(20.um, euclidian)
de4_l1.output('DE.4', 'DE.4 : Minimum NDMY to NDMY space (Merge if space is less) : 20µm')
de4_l1.forget
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if MIM_OPTION == 'A'
  #================================================
  #------------MIM CAPACITOR OPTION A -------------
  #================================================

  logger.info('MIM Capacitor Option A section')

  mim_virtual = fusetop.sized(1.06.um).and(metal2.interacting(fusetop))

  # Rule MIM.1: Minimum MiM bottom plate spacing to the bottom plate metal
  ## (whether adjacent MiM or routing metal). is 1.2µm
  logger.info('Executing rule MIM.1')
  mim1_l1 = metal2.separation(mim_virtual, transparent, 1.2.um)
  mim1_l1.output('MIM.1', 'MIM.1 : Minimum MiM bottom plate spacing to the bottom plate metal
                 (whether adjacent MiM or routing metal). : 1.2µm')
  mim1_l1.forget

  # Rule MIM.2: Minimum MiM bottom plate overlap of Via2 layer.
  ## [This is applicable for via2 within 1.06um oversize of FuseTop layer
  ## (referenced to virtual bottom plate)]. is 0.4µm
  logger.info('Executing rule MIM.2')
  mim2_via = via2.overlapping(mim_virtual)
  mim2_l1 = mim2_via.enclosed(metal2, 0.4.um, euclidian).polygons(0.001.um)
  mim2_l2 = mim2_via.not_outside(metal2).not(metal2)
  mim2_l  = mim2_l1.join(mim2_l2)
  mim2_l.output('MIM.2', 'MIM.2 : Minimum MiM bottom plate overlap of Via2 layer.
                 [This is applicable for via2 within 1.06um oversize of FuseTop layer
                 (referenced to virtual bottom plate)]. : 0.4µm')
  mim2_l1.forget
  mim2_l2.forget
  mim2_l.forget
  mim2_via.forget

  # Rule MIM.3: Minimum MiM bottom plate overlap of Top plate.
  logger.info('Executing rule MIM.3')
  mim3_l1 = fusetop.enclosed(mim_virtual, 0.6.um).polygons(0.001.um)
  mim3_l2 = fusetop.not_inside(mim_virtual)
  mim3_l = mim3_l1.join(mim3_l2)
  mim3_l.output('MIM.3', 'MIM.3 : Minimum MiM bottom plate overlap of Top plate.')
  mim3_l1.forget
  mim3_l2.forget
  mim_virtual.forget

  # Rule MIM.4: Minimum MiM top plate (FuseTop) overlap of Via2. is 0.4µm
  logger.info('Executing rule MIM.4')
  mim4_l1 = via2.enclosed(fusetop, 0.4.um, euclidian).polygons(0.001.um)
  mim4_l2 = via2.not_outside(fusetop).not(fusetop)
  mim4_l  = mim4_l1.join(mim4_l2)
  mim4_l.output('MIM.4', 'MIM.4 : Minimum MiM top plate (FuseTop) overlap of Via2. : 0.4µm')
  mim4_l1.forget
  mim4_l2.forget
  mim4_l.forget

  # Rule MIM.5: Minimum spacing between top plate and
  ## the Via2 connecting to the bottom plate. is 0.4µm
  logger.info('Executing rule MIM.5')
  mim5_l1 = fusetop.separation(via2.interacting(metal2), 0.4.um, euclidian)
  mim5_l1.output('MIM.5', 'MIM.5 : Minimum spacing between top plate and
                  the Via2 connecting to the bottom plate. : 0.4µm')
  mim5_l1.forget

  # Rule MIM.6: Minimum spacing between unrelated top plates. is 0.6µm
  logger.info('Executing rule MIM.6')
  mim6_l1 = fusetop.space(0.6.um, euclidian)
  mim6_l1.output('MIM.6', 'MIM.6 : Minimum spacing between unrelated top plates. : 0.6µm')
  mim6_l1.forget

  # Rule MIM.7: Min FuseTop enclosure by CAP_MK is 0um.
  logger.info('Executing rule MIM.7')
  mim7_l1 = fusetop.not(cap_mk)
  mim7_l1.output('MIM.7', 'MIM.7 : Min FuseTop enclosure by CAP_MK: 0um')
  mim7_l1.forget

  # Rule MIM.8a: Minimum MIM cap area (defined by FuseTop area) is 25µm².
  logger.info('Executing rule MIM.8a')
  mim8a_l1 = fusetop.with_area(nil, 25.um)
  mim8a_l1.output('MIM.8a', 'MIM.8a : Minimum MIM cap area (defined by FuseTop area): 25µm²')
  mim8a_l1.forget

  # Rule MIM.8b: Maximum single MIM Cap area (Use multiple MIM caps in parallel
  ## connection if bigger capacitors are required) (um2). is 10000µm
  logger.info('Executing rule MIM.8b')
  mim8b_l1 = fusetop.with_area(10_001.um, nil)
  mim8b_l1.output('MIM.8b', 'MIM.8b : Maximum single MIM Cap area (Use multiple MIM caps in parallel
                   connection if bigger capacitors are required) (um2). : 10000µm')
  mim8b_l1.forget

  # Rule MIM.9: Min. via spacing for sea of via on MIM top plate. is 0.5µm
  logger.info('Executing rule MIM.9')
  mim9_l1 = via2.and(fusetop).space(0.5.um, euclidian)
  mim9_l1.output('MIM.9', 'MIM.9 : Min. via spacing for sea of via on MIM top plate. : 0.5µm')
  mim9_l1.forget

  # Rule MIM.10: (a) There cannot be any Via1 touching MIM bottom plate Metal2.
  ## (b) MIM bottom plate Metal2 can only be connected through the higher Via (Via2).
  logger.info('Executing rule MIM.10')
  mim10_l1 = via1.and(metal2.interacting(fusetop))
  mim10_l1.output('MIM.10', 'MIM.10 : (a) There cannot be any Via1 touching MIM bottom plate Metal2.
                  (b) MIM bottom plate Metal2 can only be connected through the higher Via (Via2).')
  mim10_l1.forget

  # Rule MIM.11: Bottom plate of multiple MIM caps can be shared (for common nodes)
  # as long as total MIM area with that single common plate does not exceed MIM.8b rule.
  logger.info('Executing rule MIM.11')
  mim11_large_metal2 = metal2.interacting(fusetop).with_area(10_000, nil)
  mim11_large_metal2_violation = polygon_layer
  mim11_large_metal2.data.each do |p|
    mim11_metal2_polygon_layer = polygon_layer
    mim11_metal2_polygon_layer.data.insert(p)
    fuse_in_polygon = fusetop.and(mim11_metal2_polygon_layer)
    next unless fuse_in_polygon.area > 10_000

    mim11_bad_metal2_polygon = mim11_metal2_polygon_layer.interacting(fuse_in_polygon)
    mim11_bad_metal2_polygon.data.each do |b|
      b.num_points.positive? && mim11_large_metal2_violation.data.insert(b)
    end
  end
  mim11_l1 = mim11_large_metal2_violation
  mim11_l1.output('MIM.11', 'MIM.11 : Bottom plate of multiple MIM caps can be shared (for common nodes)
                  as long as total MIM area with that single common plate does not exceed MIM.8b rule.')
  mim11_l1.forget
  mim11_large_metal2.forget
  mim11_large_metal2_violation.forget

  # Rule MIM.12 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_4_1.html

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

#================================================
#--------------------METALTOP--------------------
#================================================
if BEOL

  case METAL_TOP
  when '6K'
    logger.info('MetalTop thickness 6k section')

    # Rule MT.1: min. metaltop width is 0.36µm
    logger.info('Executing rule MT.1')
    mt1_l1 = top_metal.width(0.36.um, euclidian)
    mt1_l1.output('MT.1', 'MT.1 : min. metaltop width : 0.36µm')
    mt1_l1.forget

    # Rule MT.2a: min. metaltop spacing is 0.38µm
    logger.info('Executing rule MT.2a')
    mt2a_l1 = top_metal.space(0.38.um, euclidian)
    mt2a_l1.output('MT.2a', 'MT.2a : min. metaltop spacing : 0.38µm')
    mt2a_l1.forget

    # Rule MT.2b: Space to wide Metal2 (length & width > 10um) is 0.5µm
    logger.info('Executing rule MT.2b')
    wide_top_metal = top_metal.not_interacting(top_metal.edges.with_length(nil, 10.um))
    mt2b_l1 = top_metal.separation(wide_top_metal, 0.5.um, euclidian)
    mt2b_l1.output('MT.2b', 'MT.2b : Space to wide Metal2 (length & width > 10um) : 0.5µm')
    mt2b_l1.forget
    wide_top_metal.forget

    # Rule MT.4: Minimum MetalTop area is 0.5625µm²
    logger.info('Executing rule MT.4')
    mt4_l1 = top_metal.with_area(nil, 0.5625.um)
    mt4_l1.output('MT.4', 'MT.4 : Minimum MetalTop area : 0.5625µm²')
    mt4_l1.forget

  when '9K', '11K'
    logger.info('MetalTop thickness 9k/11k section')

    # Rule MT.1: min. metaltop width is 0.44µm
    logger.info('Executing rule MT.1')
    mt1_l1 = top_metal.width(0.44.um, euclidian)
    mt1_l1.output('MT.1', 'MT.1 : min. metaltop width : 0.44µm')
    mt1_l1.forget

    # Rule MT.2a: min. metaltop spacing is 0.46µm
    logger.info('Executing rule MT.2a')
    mt2a_l1 = top_metal.space(0.46.um, euclidian)
    mt2a_l1.output('MT.2a', 'MT.2a : min. metaltop spacing : 0.46µm')
    mt2a_l1.forget

    # Rule MT.2b: Space to wide Metal2 (length & width > 10um) is 0.6µm
    logger.info('Executing rule MT.2b')
    wide_top_metal = top_metal.not_interacting(top_metal.edges.with_length(nil, 10.um))
    mt2b_l1 = top_metal.separation(wide_top_metal, 0.6.um, euclidian)
    mt2b_l1.output('MT.2b', 'MT.2b : Space to wide Metal2 (length & width > 10um) : 0.6µm')
    mt2b_l1.forget
    wide_top_metal.forget

    # Rule MT.4: Minimum MetalTop area is 0.5625µm²
    logger.info('Executing rule MT.4')
    mt4_l1 = top_metal.with_area(nil, 0.5625.um)
    mt4_l1.output('MT.4', 'MT.4 : Minimum MetalTop area : 0.5625µm²')
    mt4_l1.forget
  end
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if MIM_OPTION == 'B'
  #================================================
  #-------------MIM CAPACITOR OPTION B-------------
  #================================================

  logger.info('MIM Capacitor Option B section')

  mimtm_virtual = fusetop.sized(1.06.um).and(topmin1_metal.interacting(fusetop))

  # Rule MIMTM.1: Minimum MiM bottom plate spacing to the bottom plate metal
  ## (whether adjacent MiM or routing metal). is 1.2µm
  logger.info('Executing rule MIMTM.1')
  mimtm1_l1 = topmin1_metal.separation(mimtm_virtual, transparent, 1.2.um)
  mimtm1_l1.output('MIMTM.1', "MIMTM.1 : Minimum MiM bottom plate spacing to the bottom plate metal
                      (whether adjacent MiM or routing metal). : 1.2µm")
  mimtm1_l1.forget

  # Rule MIMTM.2: Minimum MiM bottom plate overlap of Vian-1 layer.
  ## [This is applicable for Vian-1 within 1.06um oversize of FuseTop layer
  ## (referenced to virtual bottom plate)]. is 0.4µm
  logger.info('Executing rule MIMTM.2')
  mimtm_via = top_via.overlapping(mimtm_virtual)
  mimtm2_l1 = mimtm_via.enclosed(topmin1_metal, 0.4.um, euclidian).polygons(0.001.um)
  mimtm2_l2 = mimtm_via.not_outside(topmin1_metal).not(topmin1_metal)
  mimtm2_l  = mimtm2_l1.join(mimtm2_l2)
  mimtm2_l.output('MIMTM.2', "MIMTM.2 : Minimum MiM bottom plate overlap of Vian-1 layer.
                    [This is applicable for Vian-1 within 1.06um oversize of FuseTop layer
                    (referenced to virtual bottom plate)]. : 0.4µm")
  mimtm2_l1.forget
  mimtm2_l2.forget
  mimtm2_l.forget
  mimtm_via.forget

  # Rule MIMTM.3: Minimum MiM bottom plate overlap of Top plate.
  logger.info('Executing rule MIMTM.3')
  mimtm3_l1 = fusetop.enclosed(mimtm_virtual, 0.6.um).polygons(0.001.um)
  mimtm3_l2 = fusetop.not_inside(mimtm_virtual)
  mimtm3_l = mimtm3_l1.join(mimtm3_l2)
  mimtm3_l.output('MIMTM.3', 'MIMTM.3 : Minimum MiM bottom plate overlap of Top plate.')
  mimtm3_l.forget
  mimtm3_l1.forget
  mimtm3_l2.forget
  mimtm_virtual.forget

  # Rule MIMTM.4: Minimum MiM top plate (FuseTop) overlap of Vian-1 is 0.4µm.
  logger.info('Executing rule MIMTM.4')
  mimtm4_l1 = fusetop.enclosing(top_via, 0.4.um, euclidian).polygons(0.001.um)
  mimtm4_l2 = top_via.not_outside(fusetop).not(fusetop)
  mimtm4_l  = mimtm4_l1.join(mimtm4_l2)
  mimtm4_l.output('MIMTM.4', 'MIMTM.4 : Minimum MiM top plate (FuseTop) overlap of Vian-1: 0.4µm')
  mimtm4_l1.forget
  mimtm4_l2.forget
  mimtm4_l.forget

  # Rule MIMTM.5: Minimum spacing between top plate and the Vian-1 connecting to the bottom plate. is 0.4µm
  logger.info('Executing rule MIMTM.5')
  mimtm5_l1 = fusetop.separation(top_via.interacting(topmin1_metal), 0.4.um, euclidian)
  mimtm5_l1.output('MIMTM.5',
                   'MIMTM.5 : Minimum spacing between top plate and the Vian-1 connecting to the bottom plate. : 0.4µm')
  mimtm5_l1.forget

  # Rule MIMTM.6: Minimum spacing between unrelated top plates is 0.6µm.
  logger.info('Executing rule MIMTM.6')
  mimtm6_l1 = fusetop.space(0.6.um, euclidian)
  mimtm6_l1.output('MIMTM.6', 'MIMTM.6 : Minimum spacing between unrelated top plates: 0.6µm')
  mimtm6_l1.forget

  # Rule MIMTM.7: Min FuseTop enclosure by CAP_MK is 0um.
  logger.info('Executing rule MIMTM.7')
  mimtm7_l1 = fusetop.not(cap_mk)
  mimtm7_l1.output('MIMTM.7', 'MIMTM.7 : Min FuseTop enclosure by CAP_MK: 0um.')
  mimtm7_l1.forget

  # Rule MIMTM.8a: Minimum MIM cap area (defined by FuseTop area) is 25µm².
  logger.info('Executing rule MIMTM.8a')
  mimtm8a_l1 = fusetop.with_area(nil, 25.um)
  mimtm8a_l1.output('MIMTM.8a', 'MIMTM.8a : Minimum MIM cap area (defined by FuseTop area): 25µm²')
  mimtm8a_l1.forget

  # Rule MIMTM.8b: Maximum single MIM Cap area (Use multiple MIM caps in
  ## parallel connection if bigger capacitors are required) (um2). is 10000µm
  logger.info('Executing rule MIMTM.8b')
  mimtm8b_l1 = fusetop.with_area(10_000.um, nil).not_in(fusetop.with_area(10_000.um))
  mimtm8b_l1.output('MIMTM.8b', "MIMTM.8b : Maximum single MIM Cap area (Use multiple MIM caps in
                       parallel connection if bigger capacitors are required) (um2). : 10000µm")
  mimtm8b_l1.forget

  # Rule MIMTM.9: Min. Via (Vian-1) spacing for sea of Via on MIM top plate. is 0.5µm
  logger.info('Executing rule MIMTM.9')
  mimtm9_l1 = top_via.inside(fusetop).space(0.5.um, euclidian)
  mimtm9_l1.output('MIMTM.9', 'MIMTM.9 : Min. Via (Vian-1) spacing for sea of Via on MIM top plate. : 0.5µm')
  mimtm9_l1.forget

  # Rule MIMTM.10: (a) There cannot be any Vian-2 touching MIM bottom plate Metaln-1.
  ## (b) MIM bottom plate Metaln-1 can only be connected through the higher Via (Vian-1).
  logger.info('Executing rule MIMTM.10')
  mimtm10_l1 = topmin1_via.interacting(topmin1_metal.interacting(fusetop))
  mimtm10_l1.output('MIMTM.10', "MIMTM.10 : (a) There cannot be any Vian-2 touching MIM bottom plate Metaln-1.
                      (b) MIM bottom plate Metaln-1 can only be connected through the higher Via (Vian-1).")
  mimtm10_l1.forget

  # Rule MIMTM.11: Bottom plate of multiple MIM caps can be shared (for common nodes)
  ## as long as total MIM area with that single common plate does not exceed MIMTM.8b rule. is -µm
  logger.info('Executing rule MIMTM.11')
  mimtm11_large_topmin1_metal = topmin1_metal.interacting(fusetop).with_area(10_000, nil)
  mimtm11_large_topmin1_metal_violation = polygon_layer
  mimtm11_large_topmin1_metal.data.each do |p|
    mimtm11_topmin1_metal_polygon_layer = polygon_layer
    mimtm11_topmin1_metal_polygon_layer.data.insert(p)
    fuse_in_polygon = fusetop.and(mimtm11_topmin1_metal_polygon_layer)
    next unless fuse_in_polygon.area > 10_000

    mimtm11_bad_topmin1_metal_polygon = mimtm11_topmin1_metal_polygon_layer.interacting(fuse_in_polygon)
    mimtm11_bad_topmin1_metal_polygon.data.each do |b|
      b.num_points.positive? && mimtm11_large_topmin1_metal_violation.data.insert(b)
    end
  end
  mimtm11_l1 = mimtm11_large_topmin1_metal_violation
  mimtm11_l1.output('MIMTM.11',
                    'MIMTM.11 : Bottom plate of multiple MIM caps can be shared (for common nodes)
                     as long as total MIM area with that single common plate does not exceed MIMTM.8b rule. : -µm')
  mimtm11_l1.forget
  mimtm11_large_topmin1_metal.forget
  mimtm11_large_topmin1_metal_violation.forget

  # Rule MIMTM.12 is not a DRC check
  # Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_4_2.html

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #-------------------10V LDPMOS-------------------
  #================================================

  poly_mdp = poly2.and(pcomp).inside(ldmos_xtor).inside(dualgate)
  mdp_source        = pcomp.interacting(poly_mdp.and(mvpsd)).not(poly2)
  ldpmos            = poly_mdp.not(mvpsd)
  ldpmos_edges      = ldpmos.edges
  ldpmos_gate_ends  = ldpmos_edges.outside_part(pcomp)   # defines the width
  ldpmos_gate_sides = ldpmos_edges.inside_part(pcomp)    # defines the length
  ldpmos_edges.forget
  dnwell_mdp = dnwell.and(dualgate).and(ldmos_xtor)

  # Rule MDP.1: Minimum transistor channel length. is 0.6µm
  logger.info('Executing rule MDP.1')
  mdp1_l1 = mvpsd.enclosed(poly_mdp, 0.6.um, euclidian)
  mdp1_l1.output('MDP.1', 'MDP.1 : Minimum transistor channel length. : 0.6µm')
  mdp1_l1.forget

  # Rule MDP.1a: Max transistor channel length.
  logger.info('Executing rule MDP.1a')
  mdp1a_l1 = ldpmos_gate_sides.not(ldpmos.width(20.um + 1.dbu, projection).edges)
  mdp1a_l1.output('MDP.1a', 'MDP.1a : Max transistor channel length.')
  mdp1a_l1.forget

  # Rule MDP.2: Minimum transistor channel width. is 4µm
  logger.info('Executing rule MDP.2')
  mdp2_l1 = ldpmos_gate_ends.and(ldpmos.width(4.um, projection).edges)
  mdp2_l1.output('MDP.2', 'MDP.2 : Minimum transistor channel width. : 4µm')
  mdp2_l1.forget

  # Rule MDP.3: Each LDPMOS shall be surrounded by non-broken Nplus guard ring inside DNWELL
  logger.info('Executing rule MDP.3')
  mdp3_a = ldpmos.join(mvpsd).join(mdp_source).and(dualgate).and(ldmos_xtor).not_interacting(nplus.holes)
  mdp3_b = nplus.holes.and(dualgate).and(ldmos_xtor).not_interacting(ncomp.interacting(mdp_source))
                .not_interacting(mvpsd, 1, 1)
  mdp3_l1 = mdp3_a.join(mdp3_b)
  mdp3_l1.output('MDP.3', 'MDP.3 : Each LDPMOS shall be surrounded by non-broken Nplus guard ring inside DNWELL')
  mdp3_l1.forget
  mdp3_a.forget
  mdp3_b.forget

  # Rule MDP.3ai: Min NCOMP (Nplus AND COMP) space to MVPSD
  ## (source and body tap non-butted). NCOMP (Nplus AND COMP)
  ## intercept with MVPSD is not allowed.
  logger.info('Executing rule MDP.3ai')
  ncomp_mdp3ai = ncomp.not_interacting(pcomp).and(ldmos_xtor).and(dualgate)
  mdp3ai_l1 = ncomp_mdp3ai.separation(mvpsd, 1.um, euclidian).polygons(0.001.um).join(mvpsd.interacting(ncomp_mdp3ai))
  mdp3ai_l1.output('MDP.3ai', 'MDP.3ai : Min NCOMP (Nplus AND COMP) space to MVPSD
                   (source and body tap non-butted). NCOMP (Nplus AND COMP)
                   intercept with MVPSD is not allowed.')
  mdp3ai_l1.forget
  ncomp_mdp3ai.forget

  # Rule MDP.3aii: Min NCOMP (Nplus AND COMP) space to MVPSD (source and body tap butted).
  ## NCOMP (Nplus AND COMP) intercept with MVPSD is not allowed.
  logger.info('Executing rule MDP.3aii')
  ncomp_mdp3aii = ncomp.interacting(pcomp).and(ldmos_xtor).and(dualgate)
  mdp3aii_l1 = ncomp_mdp3aii.separation(mvpsd, 0.92.um, euclidian).polygons(0.001.um)
  mdp3aii_l2 = mvpsd.interacting(ncomp_mdp3aii)
  mdp3aii_l = mdp3aii_l1.join(mdp3aii_l2)
  mdp3aii_l.output('MDP.3aii', 'MDP.3aii : Min NCOMP (Nplus AND COMP) space to MVPSD (source and body tap butted).
                     NCOMP (Nplus AND COMP) intercept with MVPSD is not allowed.')
  mdp3aii_l.forget
  mdp3aii_l1.forget
  mdp3aii_l2.forget
  ncomp_mdp3aii.forget

  # Rule MDP.3b: Min NCOMP (Nplus AND COMP) space to PCOMP in DNWELL
  ## (Pplus AND COMP AND DNWELL). Use butted source and DNWELL contacts
  ## otherwise and that is best for Latch-up immunity as well. is 0.4µm
  logger.info('Executing rule MDP.3b')
  ncomp_mdp3b = ncomp.and(ldmos_xtor).and(dualgate)
  pcomp_mdp3b = pcomp.and(dnwell).and(ldmos_xtor).and(dualgate)
  mdp3b_l1 = ncomp_mdp3b.not(poly2).not(mvpsd)
  mdp3b_l2 = pcomp_mdp3b.not(poly2).not(mvpsd)
  mdp3b_l = mdp3b_l1.separation(mdp3b_l2, 0.4.um, euclidian)
  mdp3b_l.output('MDP.3b', 'MDP.3b : Min NCOMP (Nplus AND COMP) space to PCOMP in DNWELL
                  (Pplus AND COMP AND DNWELL). Use butted source and DNWELL contacts
                   otherwise and that is best for Latch-up immunity as well. : 0.4µm')
  mdp3b_l.forget
  mdp3b_l1.forget
  mdp3b_l2.forget
  ncomp_mdp3b.forget
  pcomp_mdp3b.forget

  # Rule MDP.3c: Maximum distance of the nearest edge of the DNWELL tab
  ## (NCOMP inside DNWELL) from PCOMP edge (PCOMP inside DNWELL). is 15µm
  logger.info('Executing rule MDP.3c')
  mdp3c_exclude = ncomp.inside(dnwell).drc(separation(pcomp.inside(dnwell)) <= 15.um).first_edges
  mdp3c_l1 = ncomp.inside(dnwell).inside(ldmos_xtor).inside(dualgate).not_interacting(mdp3c_exclude, 4)
  mdp3c_l1.output('MDP.3c', 'MDP.3c : Maximum distance of the nearest edge of the DNWELL tab
                  (NCOMP inside DNWELL) from PCOMP edge (PCOMP inside DNWELL). : 15µm')
  mdp3c_l1.forget

  # Rule MDP.3d: The metal connection for the Nplus guard ring recommended to be continuous.
  ##  The maximum gap between this metal if broken. Note: To put maximum number of contact under
  ## metal for better manufacturability and reliability. is 10µm
  logger.info('Executing rule MDP.3d')
  mdp3d_l1 = ncomp.interacting(ldmos_xtor.interacting(mvpsd))
                  .interacting(dualgate).not(metal1).edges.not(metal1).with_length(10.001.um, nil)
  mdp3d_l1.output('MDP.3d', 'MDP.3d : The metal connection for the Nplus guard ring recommended to be continuous.
                  The maximum gap between this metal if broken. Note: To put maximum number of contact under
                  metal for better manufacturability and reliability. : 10µm')
  mdp3d_l1.forget

  # Rule MDP.4: DNWELL covering LDPMOS shall be surrounded by non broken Pplus guard.
  ## The metal connection for the Pplus guard ring recommended to be continuous,
  ## The maximum gap between this metal if broken. Note: To put maximum number of contact
  ## under metal for better manufacturability and reliability.
  logger.info('Executing rule MDP.4')
  mdp4_metal = pcomp.not_interacting(mvpsd).interacting(ldmos_xtor.interacting(mvpsd))
                    .interacting(dualgate).not(metal1).edges.not(metal1)
                    .with_length(10.001.um, nil)
  mdp4_l1 = pcomp.interacting(metal1).not_interacting(pcomp.holes).edges
                 .and(ldmos_xtor).and(dualgate).join(mdp4_metal)
  mdp4_l1.output('MDP.4', 'MDP.4 : DNWELL covering LDPMOS shall be surrounded by non broken Pplus guard.
                  The metal connection for the Pplus guard ring recommended to be continuous,
                  The maximum gap between this metal if broken. Note: To put maximum number of contact
                  under metal for better manufacturability and reliability.')
  mdp4_l1.forget
  mdp4_metal.forget

  # Rule MDP.4a: Min PCOMP (Pplus AND COMP) space to DNWELL. is 2.5µm
  logger.info('Executing rule MDP.4a')
  mdp4a_l1 = pcomp.and(ldmos_xtor).and(dualgate).separation(dnwell_mdp, 2.5.um, euclidian)
  mdp4a_l1.output('MDP.4a', 'MDP.4a : Min PCOMP (Pplus AND COMP) space to DNWELL. : 2.5µm')
  mdp4a_l1.forget

  # Rule MDP.4b: Maximum distance of the nearest edge of the DNWELL
  ## from the PCOMP Guard ring outside DNWELL. is 15µm
  logger.info('Executing rule MDP.4b')
  mdp4b_dnwell_edges = dnwell.inside(ldmos_xtor).inside(dualgate).edges.centers(0, 0.99)
  mdp4b_pcomp = pcomp.inside(ldmos_xtor.interacting(mvpsd)).inside(dualgate).not_interacting(mvpsd)
  mdp4b_not_error = dnwell.drc(separation(mdp4b_pcomp, euclidian) <= 15.um).polygons(0.001.um)
  mdp4b_l1 = mdp4b_dnwell_edges.not_interacting(mdp4b_not_error).and(pcomp.holes)
  mdp4b_l1.output('MDP.4b', 'MDP.4b : Maximum distance of the nearest edge of the DNWELL
                from the PCOMP Guard ring outside DNWELL. : 15µm')
  mdp4b_l1.forget
  mdp4b_dnwell_edges.forget
  mdp4b_not_error.forget

  # Rule MDP.5: Each LDPMOS shall be covered by Dualgate layer.
  logger.info('Executing rule MDP.5')
  mdp5_l1 = pcomp.not(poly2).not(mvpsd).join(pgate.not(mvpsd)).join(pcomp.and(mvpsd)).and(ldmos_xtor).not(dualgate)
  mdp5_l1.output('MDP.5', 'MDP.5 : Each LDPMOS shall be covered by Dualgate layer.')
  mdp5_l1.forget

  # Rule MDP.5a: Minimum Dualgate enclose Plus guarding ring PCOMP (Pplus AND COMP). is 0.5µm
  logger.info('Executing rule MDP.5a')
  pcomp_mdp5a = pcomp.inside(ldmos_xtor)
  mdp5a_l1 = pcomp_mdp5a.enclosed(dualgate.and(ldmos_xtor), 0.5.um, euclidian).polygons(0.001.um)
  mdp5a_l2 = pcomp_mdp5a.not_outside(dualgate.and(ldmos_xtor)).not(dualgate.and(ldmos_xtor))
  mdp5a_l  = mdp5a_l1.join(mdp5a_l2)
  mdp5a_l.output('MDP.5a', 'MDP.5a : Minimum Dualgate enclose Plus guarding ring PCOMP (Pplus AND COMP). : 0.5µm')
  mdp5a_l1.forget
  mdp5a_l2.forget
  mdp5a_l.forget
  pcomp_mdp5a.forget

  # Rule MDP.6: Each LDPMOS shall be covered by LDMOS_XTOR (GDS#226) layer.
  logger.info('Executing rule MDP.6')
  mdp6_l1 = mvpsd.not_inside(ldmos_xtor)
  mdp6_l1.output('MDP.6', 'MDP.6 : Each LDPMOS shall be covered by LDMOS_XTOR (GDS#226) layer.')
  mdp6_l1.forget

  # Rule MDP.6a: Minimum LDMOS_XTOR enclose Dualgate.
  logger.info('Executing rule MDP.6a')
  mdp6a_l1 = ldmos_xtor.not_covering(dualgate)
  mdp6a_l1.output('MDP.6a', 'MDP.6a : Minimum LDMOS_XTOR enclose Dualgate.')
  mdp6a_l1.forget

  # Rule MDP.7: Minimum LDMOS_XTOR layer space to Nwell outside LDMOS_XTOR. is 2µm
  logger.info('Executing rule MDP.7')
  mdp7_l1 = ldmos_xtor.separation(nwell.outside(ldmos_xtor), 2.um, euclidian)
  mdp7_l1.output('MDP.7', 'MDP.7 : Minimum LDMOS_XTOR layer space to Nwell outside LDMOS_XTOR. : 2µm')
  mdp7_l1.forget

  # Rule MDP.8: Minimum LDMOS_XTOR layer space to NCOMP outside LDMOS_XTOR. is 1.5µm
  logger.info('Executing rule MDP.8')
  mdp8_l1 = ldmos_xtor.separation(ncomp.outside(ldmos_xtor), 1.5.um, euclidian)
  mdp8_l1.output('MDP.8', 'MDP.8 : Minimum LDMOS_XTOR layer space to NCOMP outside LDMOS_XTOR. : 1.5µm')
  mdp8_l1.forget

  # Rule MDP.9a: Min LDPMOS POLY2 width. is 1.2µm
  logger.info('Executing rule MDP.9a')
  mdp9a_l1 = poly2.inside(dnwell_mdp).width(1.2.um, euclidian)
  mdp9a_l1.output('MDP.9a', 'MDP.9a : Min LDPMOS POLY2 width. : 1.2µm')
  mdp9a_l1.forget

  # Rule MDP.9b: Min POLY2 extension beyond COMP in the width
  ## direction of the transistor (other than the LDMOS drain direction). is 0.4µm
  logger.info('Executing rule MDP.9b')
  mdp9b_a = poly2.inside(dnwell_mdp).edges.interacting(mvpsd).not(mvpsd).enclosing(comp.edges, 0.4.um).edges
  mdp9b_b = poly2.inside(dnwell_mdp).edges.interacting(mvpsd).not(mvpsd).interacting(pcomp)
  mdp9b_l1 = mdp9b_a.join(mdp9b_b)
  mdp9b_l1.output('MDP.9b', 'MDP.9b : Min POLY2 extension beyond COMP in the width
                   direction of the transistor (other than the LDMOS drain direction). : 0.4µm')
  mdp9b_l1.forget
  mdp9b_a.forget
  mdp9b_b.forget

  # Rule MDP.9c: Min/Max POLY2 extension beyond COMP on the field towards
  ## LDPMOS drain (MVPSD AND COMP AND Pplus NOT POLY2) direction.
  logger.info('Executing rule MDP.9c')
  mdp9c_exclude = poly2.drc(enclosing(comp, projection) == 0.2.um)
  mdp9c_l1 = poly2.edges.in(poly2.inside(dnwell_mdp).edges.inside_part(mvpsd)).not_interacting(mdp9c_exclude)
  mdp9c_l1.output('MDP.9c', "MDP.9c : Min/Max POLY2 extension beyond COMP on the field towards
                     LDPMOS drain (MVPSD AND COMP AND Pplus NOT POLY2) direction.")
  mdp9c_l1.forget
  mdp9c_exclude.forget

  # Rule MDP.9d: Min/Max POLY2 on field to LDPMOS drain COMP
  ## (MVPSD AND COMP AND Pplus NOT POLY2) space.
  logger.info('Executing rule MDP.9d')
  mdp9d_exclude = mvpsd.and(pcomp).not(poly2).sized(0.16.um)
  mdp9d_l1 = poly2.and(dualgate).and(ldmos_xtor).overlapping(mdp9d_exclude)
  mdp9d_l2 = poly2.and(dualgate).and(ldmos_xtor.interacting(mvpsd)).not_interacting(mdp9d_exclude)
  mdp9d_l = mdp9d_l1.join(mdp9d_l2)
  mdp9d_l.output('MDP.9d', 'MDP.9d : Min/Max POLY2 on field to LDPMOS drain COMP
                  (MVPSD AND COMP AND Pplus NOT POLY2) space.')
  mdp9d_l.forget
  mdp9d_l1.forget
  mdp9d_l2.forget
  mdp9d_exclude.forget

  # Rule MDP.9ei: Min LDMPOS gate Poly2 space to Nplus guardring
  ## (source and body tap non-butted).
  ldpmos_poly2_gate = poly2.interacting(pgate.and(dualgate).not(mvpsd))
  ncomp_not_butted = ncomp.not(pplus).not_interacting(pcomp.not(nplus)).or(ncomp.overlapping(pcomp))
  mdp9ei_a = ldpmos_poly2_gate.inside(dualgate).inside(ldmos_xtor).separation(ncomp_not_butted,
                                                                              0.4.um).polygons(0.001.um)
  mdp9ei_b = ldpmos_poly2_gate.inside(dualgate).inside(ldmos_xtor).and(ncomp_not_butted)
  logger.info('Executing rule MDP.9ei')
  mdp9ei_l1 = mdp9ei_a.or(mdp9ei_b)
  mdp9ei_l1.output('MDP.9ei', 'MDP.9ei : Min LDMPOS gate Poly2 space to Nplus guardring
                 (source and body tap non-butted).')
  mdp9ei_l1.forget
  ncomp_not_butted.forget
  mdp9ei_a.forget
  mdp9ei_b.forget

  # Rule MDP.9eii: Min LDMPOS gate Poly2 space to Nplus guardring
  ## (source and body tap butted) is 0.32um.
  logger.info('Executing rule MDP.9eii')
  ncomp_butted = ncomp.interacting(pcomp)
  ldpmos_poly2_gate_mdp = ldpmos_poly2_gate.and(dualgate).and(ldmos_xtor)
  mdp9eii_a    = ldpmos_poly2_gate_mdp.separation(ncomp_butted, 0.32.um).polygons(0.001.um)
  mdp9eii_b    = ldpmos_poly2_gate_mdp.and(ncomp_butted)
  mdp9eii_l1 = mdp9eii_a.join(mdp9eii_b)
  mdp9eii_l1.output('MDP.9eii', "MDP.9eii : Min LDMPOS gate Poly2 space to Nplus guardring
                      (source and body tap butted): 0.32um")
  mdp9eii_l1.forget
  ncomp_butted.forget
  mdp9eii_a.forget
  mdp9eii_b.forget

  # Rule MDP.9f: Poly2 interconnect is not allowed in LDPMOS region
  ## (LDMOS_XTOR marked region)
  logger.info('Executing rule MDP.9f')
  mdp9f_poly = poly2.and(dualgate).and(ldmos_xtor)
  mdp9f_l1 = mdp9f_poly.not(pplus).interacting(mdp9f_poly.and(pplus), 2)
  mdp9f_l1.output('MDP.9f', 'MDP.9f : Poly2 interconnect is not allowed in LDPMOS region
                  (LDMOS_XTOR marked region).')
  mdp9f_l1.forget
  mdp9f_poly.forget

  # Rule MDP.10: Min/Max MVPSD overlap onto the channel
  ## (LDMOS_XTOR AND COMP AND POLY2 AND Pplus) is 0.4um.
  logger.info('Executing rule MDP.10')
  mvpsd_mv = mvpsd.and(dualgate).and(ldmos_xtor)
  mdp10_exclude = mvpsd.drc(overlap(ldmos_xtor.and(comp).and(poly2).and(pplus), projection) == 0.4.um)
  mdp10_l1 = mvpsd_mv.not_interacting(mdp10_exclude)
  mdp10_l1.output('MDP.10', 'MDP.10 : Min/Max MVPSD overlap onto the channel
                  (LDMOS_XTOR AND COMP AND POLY2 AND Pplus): 0.4 um')
  mdp10_l1.forget
  mdp10_exclude.forget
  mvpsd_mv.forget

  if CONNECTIVITY_RULES
    logger.info('CONNECTIVITY_RULES section')

    connected_mdp_10b, unconnected_mdp_10a = conn_space(mvpsd, 1, 2, euclidian)

    # Rule MDP.10a: Min MVPSD space within LDMOS_XTOR marking [diff potential]. is 2µm
    logger.info('Executing rule MDP.10a')
    mdp10a_l1 = unconnected_mdp_10a
    mdp10a_l1.output('MDP.10a', 'MDP.10a : Min MVPSD space within LDMOS_XTOR marking [diff potential]. : 2µm')
    mdp10a_l1.forget

    # Rule MDP.10b: Min MVPSD space [same potential]. Merge if space less than 1um. is 1µm
    logger.info('Executing rule MDP.10b')
    mdp10b_l1 = connected_mdp_10b
    mdp10b_l1.output('MDP.10b', 'MDP.10b : Min MVPSD space [same potential]. Merge if space less than 1um. : 1µm')
    mdp10b_l1.forget

  else
    logger.info('CONNECTIVITY_RULES disabled section')

    # Rule MDP.10a: Min MVPSD space within LDMOS_XTOR marking [diff potential]. is 2µm
    logger.info('Executing rule MDP.10a')
    mdp10a_l1 = mvpsd.space(2.um, euclidian)
    mdp10a_l1.output('MDP.10a', 'MDP.10a : Min MVPSD space within LDMOS_XTOR marking [diff potential]. : 2µm')
    mdp10a_l1.forget

  end

  # Rule MDP.11: Min MVPSD enclosing PCOMP in the drain
  ## (MVPSD AND COMP NOT POLY2) direction and in the direction along the transistor width.
  logger.info('Executing rule MDP.11')
  mdp11_l1 = mvpsd.edges.not_interacting(pcomp.edges).enclosing(pcomp.edges, 0.8.um, euclidian).polygons(0.001.um)
  mdp11_l2 = mvpsd.interacting(mvpsd.edges.and(pcomp.edges))
  mdp11_l = mdp11_l1.join(mdp11_l2)
  mdp11_l.output('MDP.11', "MDP.11 : Min MVPSD enclosing PCOMP in the drain
                    (MVPSD AND COMP NOT POLY2) direction and in the direction along the transistor width.")
  mdp11_l.forget
  mdp11_l1.forget
  mdp11_l2.forget

  # Rule MDP.12: Min DNWELL enclose Nplus guard ring (NCOMP). is 0.66µm
  logger.info('Executing rule MDP.12')
  mdp12_l1 = dnwell_mdp.enclosing(ncomp.inside(dualgate).inside(ldmos_xtor), 0.66.um, euclidian).polygons(0.001.um)
  mdp12_l2 = ncomp.inside(dualgate).inside(ldmos_xtor).not_outside(dnwell_mdp).not(dnwell_mdp)
  mdp12_l  = mdp12_l1.join(mdp12_l2)
  mdp12_l.output('MDP.12', 'MDP.12 : Min DNWELL enclose Nplus guard ring (NCOMP). : 0.66µm')
  mdp12_l1.forget
  mdp12_l2.forget
  mdp12_l.forget
  dnwell_mdp.forget

  # Rule MDP.13 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_12_2.html

  # Rule MDP.13a: Max single finger width. is 50µm
  logger.info('Executing rule MDP.13a')
  mdp13a_l1 = poly2.and(pcomp).not(mvpsd).inside(dualgate).inside(ldmos_xtor).edges.with_length(50.001.um, nil)
  mdp13a_l1.output('MDP.13a', 'MDP.13a : Max single finger width. : 50µm')
  mdp13a_l1.forget

  # Rule MDP.13b: Layout shall have alternative source & drain.
  logger.info('Executing rule MDP.13b')
  mdp13b_l1 = ldpmos.not_interacting(mdp_source, 1, 1).join(ldpmos.not_interacting(mvpsd, 1, 1))
  mdp13b_l2 = mdp_source.interacting(mvpsd)
  mdp13b_l = mdp13b_l1.join(mdp13b_l2)
  mdp13b_l.output('MDP.13b', 'MDP.13b : Layout shall have alternative source & drain.')
  mdp13b_l.forget
  mdp13b_l1.forget
  mdp13b_l2.forget

  # Rule MDP.13c: Both sides of the transistor shall be terminated by source.
  logger.info('Executing rule MDP.13c')
  mdp_13c_source_side1 = mdp_source.interacting(ldpmos, 2, 2)
  mdp_13c_source_side2 = mdp_source.interacting(ncomp.interacting(mdp_source, 2, 2))
  mdp_13c_source_side = ldpmos.interacting(mdp_13c_source_side1.join(mdp_13c_source_side2))
  mdp13c_l1 = mvpsd.covering(pcomp.not_interacting(poly2)).interacting(pcomp, 2, 2).interacting(mdp_13c_source_side)
  mdp13c_l1.output('MDP.13c', 'MDP.13c : Both sides of the transistor shall be terminated by source.')
  mdp13c_l1.forget
  mdp_13c_source_side1.forget
  mdp_13c_source_side2.forget
  mdp_13c_source_side.forget

  # Rule MDP.14 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_12_2.html

  # Rule MDP.15: Min DNWELL enclosing MVPSD to any DNWELL spacing. is 6µm
  logger.info('Executing rule MDP.15')
  mdp15_l1 = dnwell.separation(dnwell.covering(mvpsd).inside(dualgate).inside(ldmos_xtor), 6.um, euclidian)
  mdp15_l1.output('MDP.15', 'MDP.15 : Min DNWELL enclosing MVPSD to any DNWELL spacing. : 6µm')
  mdp15_l1.forget

  # Rule MDP.16a: Min LDPMOS drain COMP width. is 0.22µm
  logger.info('Executing rule MDP.16a')
  mdp16a_l1 = comp.inside(mvpsd).inside(dualgate).inside(ldmos_xtor).width(0.22.um, euclidian)
  mdp16a_l1.output('MDP.16a', 'MDP.16a : Min LDPMOS drain COMP width. : 0.22µm')
  mdp16a_l1.forget

  # Rule MDP.16b: Min LDPMOS drain COMP enclose contact. is 0µm
  logger.info('Executing rule MDP.16b')
  mdp16b_l1 = contact.interacting(pcomp.inside(mvpsd).and(dualgate).and(ldmos_xtor)).not_inside(pcomp.inside(mvpsd))
  mdp16b_l1.output('MDP.16b', 'MDP.16b : Min LDPMOS drain COMP enclose contact. : 0µm')
  mdp16b_l1.forget

  # Rule MDP.17a: For better latch up immunity, it is necessary to put DNWELL
  ## guard ring between MVPSD Inside DNWELL covered by LDMOS_XTOR and NCOMP
  ## (outside DNWELL and outside Nwell) when spacing between them is less than 40um.
  logger.info('Executing rule MDP.17a')
  mdp17_a1 = mvpsd.inside(dnwell).inside(ldmos_xtor)
  mdp17_a2 = ncomp.outside(dnwell).outside(nwell)
  mdp17a_l1 = mdp17_a1.separation(mdp17_a2, transparent,
                                  40.um).polygons(0.001.um).not_interacting(ncomp.and(dnwell).holes)
  mdp17a_l1.output('MDP.17a', "MDP.17a : For better latch up immunity, it is necessary to put DNWELL
                      guard ring between MVPSD Inside DNWELL covered by LDMOS_XTOR and NCOMP
                      (outside DNWELL and outside Nwell) when spacing between them is less than 40um.")
  mdp17a_l1.forget
  mdp17_a1.forget
  mdp17_a2.forget

  # Rule MDP.17c: DNWELL guard ring shall have NCOMP tab to be connected to highest potential
  logger.info('Executing rule MDP.17c')
  mdp17c_l1 = dnwell.with_holes.not_covering(ncomp)
  mdp17c_l1.output('MDP.17c', 'MDP.17c : DNWELL guard ring shall have NCOMP tab to be connected to highest potential')
  mdp17c_l1.forget
  mdp_source.forget
  ldpmos.forget
  poly_mdp.forget
  ldpmos_gate_ends.forget
  ldpmos_gate_sides.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #--------------------CONTACT---------------------
  #================================================

  logger.info('Starting CONTACT derivations')

  contact_edges = contact.edges
  main_contact = contact.not(sramcore)
  main_contact_edges = main_contact.edges
  metal1_edges = metal1.edges

  # Rule CO.1: Min/max contact size. is 0.22µm
  logger.info('Executing rule CO.1')
  co1_l1 = contact_edges.without_length(0.22.um)
  co1_l1.output('CO.1', 'CO.1 : Min/max contact size. : 0.22µm')
  co1_l1.forget

  # Rule CO.2a: min. contact spacing is 0.25µm
  logger.info('Executing rule CO.2a')
  co2a_l1 = contact.space(0.25.um, euclidian)
  co2a_l1.output('CO.2a', 'CO.2a : min. contact spacing : 0.25µm')
  co2a_l1.forget

  # Rule CO.2b: Space in 4x4 or larger contact array. is 0.28µm
  logger.info('Executing rule CO.2b')
  # Array to be filterd
  ## array_length = 3 * exact_size + 3 * min_space
  co2b_egde_length = 0.22 * 3 + 3 * 0.28
  poss_4_4_contact = contact.sized(0.16, 'square_limit').merged.sized(-0.16, 'square_limit')
  co_4x4_all = poss_4_4_contact.with_bbox_min(co2b_egde_length..nil).interacting(contact, 16..nil)
  co_4x4_loc_exc = co_4x4_all.width(co2b_egde_length,
                                    projection_limits(co2b_egde_length..1000 * co2b_egde_length)).polygons
  co_4x4_loc = co_4x4_all.not_interacting(co_4x4_loc_exc)
  selected_co = contact.interacting(co_4x4_loc)
  co2b_l1 = selected_co.space(0.28.um, euclidian)
  co2b_l1.output('CO.2b', 'CO.2b : Space in 4x4 or larger contact array. : 0.28µm')

  # Rule CO.3: Poly2 overlap of contact. is 0.07µm
  logger.info('Executing rule CO.3')
  co3_l1 = main_contact.enclosed(poly2, 0.07.um, euclidian).polygons(0.001.um)
  co3_l2 = main_contact.not_outside(poly2).not(poly2)
  co3_l = co3_l1.or(co3_l2)
  co3_l.output('CO.3', 'CO.3 : Poly2 overlap of contact. : 0.07µm')
  co3_l.forget
  co3_l1.forget
  co3_l2.forget

  # Rule CO.4: COMP overlap of contact. is 0.07µm
  logger.info('Executing rule CO.4')
  co4_l1 = main_contact.enclosed(comp, 0.07.um, euclidian).polygons(0.001.um)
  co4_l2 = main_contact.not_outside(comp).not(comp)
  co4_l = co4_l1.or(co4_l2)
  co4_l.output('CO.4', 'CO.4 : COMP overlap of contact. : 0.07µm')
  co4_l.forget
  co4_l1.forget
  co4_l2.forget

  # Rule CO.5a: Nplus overlap of contact on COMP
  ## (Only for contacts to butted Nplus and Pplus COMP areas). is 0.1µm
  logger.info('Executing rule CO.5a')
  co_5a_ncomp_butted = ncomp.interacting(pcomp).not_overlapping(pcomp)
  co_ncomp_check = contact.interacting(co_5a_ncomp_butted)
  co5a_l1 = co_ncomp_check.enclosed(co_5a_ncomp_butted, 0.1.um, euclidian)
  co5a_l1.output('CO.5a', 'CO.5a : Nplus overlap of contact on COMP
                    (Only for contacts to butted Nplus and Pplus COMP areas). : 0.1µm')
  co5a_l1.forget
  co_ncomp_check.forget
  co_5a_ncomp_butted.forget

  # Rule CO.5b: Pplus overlap of contact on COMP
  ## (Only for contacts to butted Nplus and Pplus COMP areas). is 0.1µm
  logger.info('Executing rule CO.5b')
  co_5b_pcomp_butted = pcomp.interacting(ncomp).not_overlapping(ncomp)
  co_pcomp_check = contact.interacting(co_5b_pcomp_butted)
  co5b_l1 = co_pcomp_check.enclosed(co_5b_pcomp_butted, 0.1.um, euclidian)
  co5b_l1.output('CO.5b', 'CO.5b : Pplus overlap of contact on COMP
                    (Only for contacts to butted Nplus and Pplus COMP areas). : 0.1µm')
  co5b_l1.forget
  co_pcomp_check.forget
  co_5b_pcomp_butted.forget

  # Rule CO.6: Metal1 overlap of contact >= 0.005 um.
  logger.info('Executing rule CO.6')
  co6_l1 = contact.enclosed(metal1, 0.005.um, euclidian).polygons(0.001.um)
  co6_l2 = contact.not(metal1)
  co6_l = co6_l1.or(co6_l2)
  co6_l.output('CO.6', 'CO.6 : Metal1 overlap of contact >= 0.005 um')
  co6_l1.forget
  co6_l2.forget
  co6_l.forget

  # Rule CO.6a: (i) Metal1 (< 0.34um) end-of-line overlap. is 0.06µm.
  ## (Applies to all < 0.34µm wide metal lines,
  ## excluding metal branches shorter than 0.24µm.)
  logger.info('Executing rule CO.6a')
  cont_6a_cond = metal1.width(0.34.um + 1.dbu).with_length(0.24.um, nil, both)
  cont_6a_cond_edge1 = cont_6a_cond.first_edges
  cont_6a_cond_edge2 = cont_6a_cond.second_edges
  cont_6a_eol = metal1_edges.with_length(nil, 0.34.um).interacting(cont_6a_cond_edge1).interacting(cont_6a_cond_edge2)
                            .not(cont_6a_cond_edge1).not(cont_6a_cond_edge2)
  cont_6a_l1 = contact_edges.enclosed(cont_6a_eol, 0.06.um, projection)
  cont_6a_l1.output('CO.6a', 'CO.6a : (i) Metal1 (< 0.34um) end-of-line overlap contact
                     (Applies to all < 0.34µm wide metal lines,
                     excluding metal branches shorter than 0.24µm) : 0.06µm')
  cont_6a_l1.forget
  cont_6a_cond.forget
  cont_6a_eol.forget
  cont_6a_cond.forget
  cont_6a_cond_edge1.forget
  cont_6a_cond_edge2.forget
  contact_edges.forget

  # Rule CO.6b: (ii) If Metal1 overlaps contact by < 0.04um on one side,
  ## adjacent metal1 edges overlap is 0.06µm
  logger.info('Executing rule CO.6b')
  cont_6b_cond_edges = main_contact_edges.not_outside(main_contact.enclosed(metal1, 0.04.um, projection).edges)
  cont_6b_check_corner = cont_6b_cond_edges.extended_in(0.002.um)
  cont_6b_check = main_contact_edges.interacting(cont_6b_check_corner).not(cont_6b_cond_edges)
  cont_6b_cond_corner = cont_6b_cond_edges.width(0.002.um, angle_limit(135)).polygons(0.001.um)
  cont_6b_l1 = cont_6b_check.enclosed(metal1_edges, 0.06.um, projection).polygons(0.001.um)
  cont_6b_l2 = main_contact.interacting(cont_6b_cond_corner)
  cont_6b_l = cont_6b_l1.or(cont_6b_l2)
  cont_6b_l.output('CO.6b', 'CO.6b : (ii) If Metal1 overlaps contact by < 0.04um on one side,
                      adjacent metal1 edges overlap : 0.06µm')
  cont_6b_l2.forget
  cont_6b_l1.forget
  cont_6b_cond_corner.forget
  cont_6b_check.forget
  cont_6b_check_corner.forget
  cont_6b_cond_edges.forget
  metal1_edges.forget
  main_contact_edges.forget

  # Rule CO.6c is a guideline rule.
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_13.html

  # Rule CO.7: Space from COMP contact to Poly2 on COMP. is 0.15µm
  logger.info('Executing rule CO.7')
  co7_l1 = contact.and(comp).not(otp_mk).separation(tgate.not(otp_mk), 0.15.um, euclidian)
  co7_l1.output('CO.7', 'CO.7 : Space from COMP contact to Poly2 on COMP. : 0.15µm')
  co7_l1.forget

  # Rule CO.8: Space from Poly2 contact to COMP. is 0.17µm
  logger.info('Executing rule CO.8')
  co8_l1 = contact.and(poly2).separation(comp, 0.17.um, euclidian)
  co8_l1.output('CO.8', 'CO.8 : Space from Poly2 contact to COMP. : 0.17µm')
  co8_l1.forget

  # Rule CO.9: Contact on NCOMP to PCOMP butting edge is forbidden (contact must not straddle butting edge).
  logger.info('Executing rule CO.9')
  co9_l1 = contact.interacting(ncomp.edges.and(pcomp.edges))
  co9_l1.output('CO.9',
                'CO.9 : Contact on NCOMP to PCOMP butting edge is forbidden (contact must not straddle butting edge).')
  co9_l1.forget

  # Rule CO.10: Contact on Poly2 gate over COMP is forbidden.
  logger.info('Executing rule CO.10')
  co10_l1 = contact.and(tgate)
  co10_l1.output('CO.10', 'CO.10 : Contact on Poly2 gate over COMP is forbidden.')
  co10_l1.forget

  # Rule CO.11: Contact on field oxide is forbidden.
  logger.info('Executing rule CO.11')
  co11_l1 = contact.not(poly2).not(comp)
  co11_l1.output('CO.11', 'CO.11 : Contact on field oxide is forbidden.')
  co11_l1.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #--------------------DRC_BJT---------------------
  #================================================

  # Rule BJT.1: Min. DRC_BJT overlap of DNWELL for NPN BJT is 0um.
  logger.info('Executing rule BJT.1')
  bjt1_l1 = drc_bjt.not_covering(dnwell.interacting(drc_bjt))
  bjt1_l1.output('BJT.1', 'BJT.1 : Min. DRC_BJT overlap of DNWELL for NPN BJT: 0um')
  bjt1_l1.forget

  # Rule BJT.2: Min. DRC_BJT overlap of PCOM in Psub is 0um.
  logger.info('Executing rule BJT.2')
  bjt2_l1 = drc_bjt.not_covering(pcomp.outside(all_nwell).interacting(drc_bjt))
  bjt2_l1.output('BJT.2', 'BJT.2 : Min. DRC_BJT overlap of PCOM in Psub: 0um')
  bjt2_l1.forget

  # Rule BJT.3: Minimum space of DRC_BJT layer to unrelated COMP. is 0.1µm
  logger.info('Executing rule BJT.3')
  bjt3_l1 = comp.outside(drc_bjt).separation(drc_bjt, 0.1.um, euclidian)
  bjt3_l1.output('BJT.3', 'BJT.3 : Minimum space of DRC_BJT layer to unrelated COMP. : 0.1µm')
  bjt3_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #-------------------10V LDNMOS-------------------
  #================================================

  # MDN derivations
  logger.info('Starting 10V LDNMOS derivations')

  poly_ld = poly2.and(ldmos_xtor).and(dualgate)
  poly_mdn = poly_ld.and(ncomp)
  ldnmos = poly_mdn.not(mvsd)
  ldnmos_edges = ldnmos.edges
  ldnmos_gate_ends = ldnmos_edges.outside_part(ncomp)
  comp_mdn  = comp.and(ldmos_xtor).and(dualgate)
  ncomp_ld  = ncomp.and(ldmos_xtor)
  ncomp_mdn  = ncomp_ld.and(dualgate)
  pcomp_mdn  = pcomp.and(ldmos_xtor).and(dualgate)
  ldnmos_source = ncomp.interacting(poly2.and(dualgate).and(ldmos_xtor).and(mvsd)).not(poly2)
  mvsd_mdn = mvsd.and(dualgate).and(ldmos_xtor)
  pcomp_holes = pcomp.holes

  # Rule MDN.1: Min MVSD width (for litho purpose). is 1µm
  logger.info('Executing rule MDN.1')
  mdn1_l1 = mvsd.width(1.um, euclidian)
  mdn1_l1.output('MDN.1', 'MDN.1 : Min MVSD width (for litho purpose). : 1µm')
  mdn1_l1.forget

  if CONNECTIVITY_RULES
    logger.info('CONNECTIVITY_RULES section')
    connected_mdn_2a, unconnected_mdn_2b = conn_space(mvsd, 1.um, 2.um, euclidian)

    # Rule MDN.2a: Min MVSD space [Same Potential]. is 1µm
    logger.info('Executing rule MDN.2a')
    mdn2a_l1 = connected_mdn_2a
    mdn2a_l1.output('MDN.2a', 'MDN.2a : Min MVSD space [Same Potential]. : 1µm')
    mdn2a_l1.forget

    # Rule MDN.2b: Min MVSD space [Diff Potential]. is 2µm
    logger.info('Executing rule MDN.2b')
    mdn2b_l1 = unconnected_mdn_2b

  else
    logger.info('CONNECTIVITY_RULES disabled section')
    # Rule MDN.2b: Min MVSD space [Diff Potential]. is 2µm
    logger.info('Executing rule MDN.2b')
    mdn2b_l1 = mvsd.space(2.um, euclidian)

  end
  mdn2b_l1.output('MDN.2b', 'MDN.2b : Min MVSD space [Diff Potential]. : 2µm')
  mdn2b_l1.forget # CONNECTIVITY_RULES

  # Rule MDN.3a: Min transistor channel length is 0.6µm
  logger.info('Executing rule MDN.3a')
  mdn3a_l1 = mvsd.enclosed(poly_mdn, 0.6.um, euclidian)
  mdn3a_l1.output('MDN.3a', 'MDN.3a : Min transistor channel length. : 0.6µm')
  mdn3a_l1.forget

  # Rule MDN.3b: Max transistor channel length is 20um.
  logger.info('Executing rule MDN.3b')
  mdn3b_pass = ldnmos.width(20.um + 1.dbu, projection).edges
  mdn3b_l1 = ldnmos_edges.inside_part(ncomp).not(mdn3b_pass)
  mdn3b_l1.output('MDN.3b', 'MDN.3b : Max transistor channel length: 20um')
  mdn3b_l1.forget
  mdn3b_pass.forget

  # Rule MDN.4a: Min transistor channel width is 4µm.
  logger.info('Executing rule MDN.4a')
  mdn4a_fail = ldnmos.width(4.um, projection).edges
  mdn4a_l1 = ldnmos_gate_ends.and(mdn4a_fail)
  mdn4a_l1.output('MDN.4a', 'MDN.4a : Min transistor channel width. : 4µm')
  mdn4a_l1.forget
  mdn4a_fail.forget

  # Rule MDN.4b: Max transistor channel width is 50um.
  logger.info('Executing rule MDN.4b')
  mdn4b_pass = ldnmos.width(50.um + 1.dbu, projection).edges
  mdn4b_l1 = ldnmos_gate_ends.not(mdn4b_pass)
  mdn4b_l1.output('MDN.4b', 'MDN.4b : Max transistor channel width : 50 um ')
  mdn4b_l1.forget
  mdn4b_pass.forget

  # Rule MDN.5ai: Min PCOMP (Pplus AND COMP) space to LDNMOS Drain MVSD
  ## (source and body tap non-butted) is 1um. PCOMP (Pplus AND COMP)
  ## intercept with LDNMOS Drain MVSD is not allowed.
  logger.info('Executing rule MDN.5ai')
  pcomp_mdn5ai = pcomp_mdn.not_interacting(ncomp)
  mdn5ai_l1 = mvsd.and(pcomp_mdn5ai)
  mdn5ai_l2 = pcomp_mdn5ai.separation(mvsd, 1.um, euclidian).polygons(0.001.um)
  mdn5ai_l = mdn5ai_l1.join(mdn5ai_l2)
  mdn5ai_l.output('MDN.5ai', "MDN.5ai : Min PCOMP (Pplus AND COMP) space to LDNMOS Drain MVSD
                    (source and body tap non-butted): 1um. PCOMP (Pplus AND COMP)
                    intercept with LDNMOS Drain MVSD is not allowed.")
  mdn5ai_l.forget
  mdn5ai_l1.forget
  mdn5ai_l2.forget
  pcomp_mdn5ai.forget

  # Rule MDN.5aii: Min PCOMP (Pplus AND COMP) space to LDNMOS Drain MVSD
  ## (source and body tap butted) is 0.92um. PCOMP (Pplus AND COMP)
  ## intercept with LDNMOS Drain MVSD is not allowed. is 0.92µm
  logger.info('Executing rule MDN.5aii')
  pcomp_mdn5aii = pcomp_mdn.interacting(ncomp)
  mdn5aii_l1  = mvsd.and(pcomp_mdn5aii)
  mdn5aii_l2  = pcomp_mdn5aii.separation(mvsd, 0.92.um, euclidian).polygons(0.001.um)
  mdn5aii_l = mdn5aii_l1.join(mdn5aii_l2)
  mdn5aii_l.output('MDN.5aii', "MDN.5aii : Min PCOMP (Pplus AND COMP) space to LDNMOS Drain MVSD
                     (source and body tap butted): 0.92um. PCOMP (Pplus AND COMP)
                     intercept with LDNMOS Drain MVSD is not allowed. : 0.92µm")
  mdn5aii_l.forget
  mdn5aii_l1.forget
  mdn5aii_l2.forget
  pcomp_mdn5aii.forget

  # Rule MDN.5b: Min PCOMP (Pplus AND COMP) space to LDNMOS Source
  ## (Nplus AND COMP) is 0.4um. Use butted source and p-substrate tab
  ## otherwise and that is good for Latch-up immunity as well.
  logger.info('Executing rule MDN.5b')
  mdn5b_l1 = ldnmos_source.and(pcomp_mdn)
  mdn5b_l2 = ldnmos_source.separation(pcomp_mdn, 0.4.um, euclidian).polygons
  mdn5b_l = mdn5b_l1.join(mdn5b_l2)
  mdn5b_l.output('MDN.5b', 'MDN.5b : Min PCOMP (Pplus AND COMP) space to LDNMOS Source
                 (Nplus AND COMP): 0.4um. Use butted source and p-substrate tab
                 otherwise and that is good for Latch-up immunity as well.')
  mdn5b_l.forget
  mdn5b_l1.forget
  mdn5b_l2.forget

  # Rule MDN.5c: Maximum distance of the nearest edge of the substrate tab from NCOMP edge is 15µm.
  logger.info('Executing rule MDN.5c')
  mdn_5c_ncompsd = ncomp_mdn.interacting(mvsd).sized(0.36.um).sized(-0.36.um).extents
  mdn_5c_error_exclude = mdn_5c_ncompsd.drc(separation(pcomp, euclidian) <= 15.um).polygons(0.001.um)
  mdn_5c_error = mdn_5c_ncompsd.edges.centers(0, 0.99).not_interacting(mdn_5c_error_exclude)
  mdn5c_l1 = mdn_5c_error.and(ncomp).and(pcomp_holes)
  mdn5c_l1.output('MDN.5c',
                  'MDN.5c : Maximum distance of the nearest edge of the substrate tab from NCOMP edge: 15µm')
  mdn5c_l1.forget
  mdn_5c_ncompsd.forget
  mdn_5c_error.forget
  mdn_5c_error_exclude.forget

  # Rule MDN.6: ALL LDNMOS shall be covered by Dualgate layer.
  logger.info('Executing rule MDN.6')
  mdn6_l1 = ncomp.join(poly2).join(mvsd).and(ldmos_xtor).not(dualgate)
  mdn6_l1.output('MDN.6', 'MDN.6 : ALL LDNMOS shall be covered by Dualgate layer.')
  mdn6_l1.forget

  # Rule MDN.6a: Min Dualgate enclose NCOMP.
  logger.info('Executing rule MDN.6a')
  mdn6a_l1 = ncomp_ld.enclosed(dualgate, 0.5.um, euclidian).polygons(0.001.um).join(ncomp_ld.not(dualgate))
  mdn6a_l1.output('MDN.6a', 'MDN.6a : Min Dualgate enclose NCOMP.')
  mdn6a_l1.forget

  # Rule MDN.7: Each LDNMOS shall be covered by LDMOS_XTOR (GDS#226) mark layer.
  logger.info('Executing rule MDN.7')
  mdn7_l1 = ncomp.interacting(mvsd).not(poly2).not(mvsd)
  mdn7_l2 = ngate.interacting(mvsd).not(mvsd)
  mdn7_l3 = ncomp.and(mvsd)
  mdn7_l = mdn7_l1.join(mdn7_l2).join(mdn7_l3).and(dualgate).not(ldmos_xtor)
  mdn7_l.output('MDN.7', 'MDN.7 : Each LDNMOS shall be covered by LDMOS_XTOR (GDS#226) mark layer.')
  mdn7_l1.forget
  mdn7_l2.forget
  mdn7_l3.forget

  # Rule MDN.7a: Min LDMOS_XTOR enclose Dualgate. is 0um.
  logger.info('Executing rule MDN.7a')
  mdn7a_l1 = dualgate.not_outside(ldmos_xtor).not(ldmos_xtor).join(dualgate.and(mvsd).not(ldmos_xtor))
  mdn7a_l1.output('MDN.7a', 'MDN.7a : Min LDMOS_XTOR enclose Dualgate.: 0 um')
  mdn7a_l1.forget

  if CONNECTIVITY_RULES
    logger.info('CONNECTIVITY_RULES section')
    connected_mdn_8a, unconnected_mdn_8b = conn_separation(mvsd, nwell, 1, 2, euclidian)

    # Rule MDN.8a: Min LDNMOS drain MVSD space to any other equal potential Nwell space.
    logger.info('Executing rule MDN.8a')
    mdn8a_l1 = connected_mdn_8a.join(mvsd.not_outside(nwell))
    mdn8a_l1.output('MDN.8a', 'MDN.8a : Min LDNMOS drain MVSD space to any other equal potential Nwell space.')
    mdn8a_l1.forget

    # Rule MDN.8b: Min LDNMOS drain MVSD space to any other different potential Nwell space.
    logger.info('Executing rule MDN.8b')
    mdn8b_l1 = unconnected_mdn_8b.join(mvsd.not_outside(nwell))

  else
    logger.info('CONNECTIVITY_RULES disabled section')
    # Rule MDN.8b: Min LDNMOS drain MVSD space to any other different potential Nwell space.
    logger.info('Executing rule MDN.8b')
    mdn8b_l1 = mvsd.separation(nwell, 2.um, euclidian).polygons(0.001.um).join(mvsd.not_outside(nwell))

  end
  mdn8b_l1.output('MDN.8b', 'MDN.8b : Min LDNMOS drain MVSD space to any other different potential Nwell space.')
  mdn8b_l1.forget # CONNECTIVITY_RULES

  # Rule MDN.9: Min LDNMOS drain MVSD space to NCOMP (Nplus AND COMP) outside LDNMOS drain MVSD. is 4µm
  logger.info('Executing rule MDN.9')
  mdn9_l1 = mvsd_mdn.separation(ncomp.not_interacting(mvsd), 4.um, euclidian)
  mdn9_l1.output('MDN.9',
                 'MDN.9 : Min LDNMOS drain MVSD space to NCOMP (Nplus AND COMP) outside LDNMOS drain MVSD. : 4µm')
  mdn9_l1.forget

  # Rule MDN.10 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_12_1.html

  # Rule MDN.10a: Min LDNMOS POLY2 width. is 1.2µm
  logger.info('Executing rule MDN.10a')
  poly_mdn10 = poly2.and(dualgate).and(ldmos_xtor.interacting(mvsd))
  mdn10a_l1  = poly_mdn10.width(1.2.um, euclidian)
  mdn10a_l1.output('MDN.10a', 'MDN.10a : Min LDNMOS POLY2 width. : 1.2µm')
  mdn10a_l1.forget

  # Rule MDN.10b: Min POLY2 extension beyond COMP in the width direction of the transistor
  ## (other than the LDNMOS drain direction). is 0.4µm
  logger.info('Executing rule MDN.10b')
  mdn10b_l1 = ncomp.interacting(poly_mdn10).edges.interacting(ncomp.edges.not_interacting(poly2))
  mdn10b_l = mdn10b_l1.enclosed(poly_mdn10.edges, 0.4.um, euclidian)
  mdn10b_l.output('MDN.10b', 'MDN.10b : Min POLY2 extension beyond COMP in the width direction of the transistor
                  (other than the LDNMOS drain direction). : 0.4µm')
  mdn10b_l.forget
  mdn10b_l1.forget

  # Rule MDN.10c: Min/Max POLY2 extension beyond COMP on the field
  ## towards LDNMOS drain COMP direction. is 0.2 um.
  logger.info('Executing rule MDN.10c')
  mdn_10c_all_errors   = poly_mdn10.drc(enclosing(ncomp.interacting(poly_mdn10), euclidian) != 0.2.um)
  mdn_10c_error_region = ncomp_mdn.sized(0.36.um).sized(-0.36.um).extents.and(mvsd).and(poly2)
  mdn10c_l1 = mdn_10c_all_errors.and(mdn_10c_error_region)
  mdn10c_l1.output('MDN.10c', 'MDN.10c : Min/Max POLY2 extension beyond COMP on the field
                   towards LDNMOS drain COMP direction.: 0.2 um')
  mdn10c_l1.forget
  mdn_10c_all_errors.forget
  mdn_10c_error_region.forget

  # Rule MDN.10d: Min/Max POLY2 on field space to LDNMOS drain COMP.
  logger.info('Executing rule MDN.10d')
  mdn_10d_field   = ncomp.and(poly2).sized(1.um, 0).and(poly2)
  mdn_10d_not_max = ncomp_mdn.inside(mvsd).drc(separation(mdn_10d_field) <= 0.16.um)
  mdn_10d_ext     = ncomp.sized(0.36.um).sized(-0.36.um).extents
  mdn_10d_max     = mdn_10d_ext.not(mdn_10d_not_max.polygons).not(ncomp).not(poly2).inside(mvsd)
  mdn_10d_min     = ncomp_mdn.inside(mvsd).separation(mdn_10d_field, 0.16.um).polygons(0.001.um)
  mdn_10d_overlap = ncomp_mdn.inside(mvsd).and(poly2)
  mdn10d_l1 = mdn_10d_max.join(mdn_10d_min).join(mdn_10d_overlap)
  mdn10d_l1.output('MDN.10d', 'MDN.10d : Min/Max POLY2 on field space to LDNMOS drain COMP.')
  mdn10d_l1.forget
  mdn_10d_field.forget
  mdn_10d_not_max.forget
  mdn_10d_ext.forget
  mdn_10d_max.forget
  mdn_10d_min.forget
  mdn_10d_overlap.forget

  # Rule MDN.10ei: Min POLY2 space to Psub tap (source and body tap non-butted).
  logger.info('Executing rule MDN.10ei')
  mdn10ei_l1 = poly_mdn10.separation(pcomp.not_interacting(ncomp), 0.4.um).polygons(0.001.um)
  mdn10ei_l2 = poly_mdn10.and(pcomp.not_interacting(ncomp))
  mdn10ei_l = mdn10ei_l1.join(mdn10ei_l2)
  mdn10ei_l.output('MDN.10ei', 'MDN.10ei : Min POLY2 space to Psub tap (source and body tap non-butted).')
  mdn10ei_l.forget
  mdn10ei_l1.forget
  mdn10ei_l2.forget

  # Rule MDN.10eii: Min POLY2 space to Psub tap (source and body tap butted). is 0.32µm
  logger.info('Executing rule MDN.10eii')
  mdn10eii_l1 = poly_mdn10.separation(pcomp.interacting(ncomp), 0.32.um, euclidian)
  mdn10eii_l1.output('MDN.10eii', 'MDN.10eii : Min POLY2 space to Psub tap (source and body tap butted). : 0.32µm')
  mdn10eii_l1.forget

  # Rule MDN.10f: Poly2 interconnect in HV region (LDMOS_XTOR marked region) not allowed.
  ## Also, any Poly2 interconnect with poly2 to substrate potential greater than 6V is not allowed.
  logger.info('Executing rule MDN.10f')
  mdn10f_l1 = poly_mdn10.not(nplus).interacting(poly_mdn10.and(nplus), 2)
  mdn10f_l2 = poly2.and(ldmos_xtor).interacting(poly2.not(ldmos_xtor))
  mdn10f_l = mdn10f_l1.join(mdn10f_l2)
  mdn10f_l.output('MDN.10f', "MDN.10f : Poly2 interconnect in HV region (LDMOS_XTOR marked region) not allowed.
                     Also, any Poly2 interconnect with poly2 to substrate potential greater than 6V is not allowed.")
  mdn10f_l1.forget
  mdn10f_l2.forget
  poly_mdn10.forget

  # Rule MDN.11: Min/Max MVSD overlap channel COMP
  ##    ((((LDMOS_XTOR AND MVSD) AND COMP) AND POLY2) AND NPlus).
  logger.info('Executing rule MDN.11')
  mdn_11_layer      = ldmos_xtor.and(mvsd).and(comp).and(poly2).and(nplus)
  mdn_11_max        = mdn_11_layer.not(mdn_11_layer.drc(width <= 0.4.um).polygons)
  mdn_11_min        = mdn_11_layer.width(0.4.um).polygons(0.001.um).not_interacting(mdn_11_max)
  mdn_11_no_channel_l1 = mvsd.covering(ncomp).outside(tgate).and(dualgate).and(ldmos_xtor)
  mdn_11_no_channel_l2 = mvsd.not_covering(ncomp.not_interacting(poly2)).and(dualgate).and(ldmos_xtor)
  mdn_11_no_channel = mdn_11_no_channel_l1.join(mdn_11_no_channel_l2)
  mdn11_l1 = mdn_11_max.join(mdn_11_min).join(mdn_11_no_channel)
  mdn11_l1.output('MDN.11', 'MDN.11 : Min/Max MVSD overlap channel COMP
                  ((((LDMOS_XTOR AND MVSD) AND COMP) AND POLY2) AND NPlus).')
  mdn11_l1.forget
  mdn_11_layer.forget
  mdn_11_max.forget
  mdn_11_min.forget
  mdn_11_no_channel_l1.forget
  mdn_11_no_channel_l2.forget
  mdn_11_no_channel.forget

  # Rule MDN.12: Min MVSD enclose NCOMP in the LDNMOS drain
  ## and in the direction along the transistor width.
  logger.info('Executing rule MDN.12')
  mdn12_a1 = mvsd_mdn.covering(ncomp_mdn.not_interacting(poly2))
  mdn12_a = ncomp_mdn.enclosed(mdn12_a1, 0.5.um, transparent).polygons(0.001.um).outside(poly2)
  mdn12_b = mvsd_mdn.not_covering(ncomp.not_interacting(poly2))
  mdn12_l1 = mdn12_a.join(mdn12_b)
  mdn12_l1.output('MDN.12', 'MDN.12 : Min MVSD enclose NCOMP in the LDNMOS drain
                   and in the direction along the transistor width.')
  mdn12_l1.forget
  mdn12_a1.forget
  mdn12_a.forget
  mdn12_b.forget

  # Rule MDN.13 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_12_1.html

  # Rule MDN.13a: Max single finger width. is 50µm
  logger.info('Executing rule MDN.13a')
  mdn13a_l1 = poly_mdn.not(mvsd).drc(length > 50.um)
  mdn13a_l1.output('MDN.13a', 'MDN.13a : Max single finger width. : 50µm')
  mdn13a_l1.forget

  # Rule MDN.13b: Layout shall have alternative source & drain.
  logger.info('Executing rule MDN.13b')
  mdn_source = ncomp.interacting(poly2.and(dualgate).and(ldmos_xtor).and(mvsd)).not(poly2)
  mdn_ldnmos = poly_mdn.not(mvsd)
  mdn13b_l1 = mdn_ldnmos.not_interacting(mdn_source, 1, 1)
  mdn13b_l2 = mdn_ldnmos.not_interacting(mvsd, 1, 1)
  mdn13b_l3 = mdn_source.interacting(mvsd)
  mdn13b_l = mdn13b_l1.join(mdn13b_l2).join(mdn13b_l3)
  mdn13b_l.output('MDN.13b', 'MDN.13b : Layout shall have alternative source & drain.')
  mdn13b_l.forget
  mdn13b_l1.forget
  mdn13b_l2.forget
  mdn13b_l3.forget

  # Rule MDN.13c: Both sides of the transistor shall be terminated by source.
  logger.info('Executing rule MDN.13c')
  mdn_13c_source_side_l1 = mdn_source.interacting(mdn_ldnmos, 2, 2)
  mdn_13c_source_side_l2 = mdn_source.interacting(pcomp.interacting(mdn_source, 2, 2))
  mdn_13c_source_side = mdn_ldnmos.interacting(mdn_13c_source_side_l1.join(mdn_13c_source_side_l2))
  mdn13c_l1 = mvsd.covering(ncomp.not_interacting(poly2)).interacting(ncomp, 2, 2).interacting(mdn_13c_source_side)
  mdn13c_l1.output('MDN.13c', 'MDN.13c : Both sides of the transistor shall be terminated by source.')
  mdn13c_l1.forget
  mdn_13c_source_side_l1.forget
  mdn_13c_source_side_l2.forget
  mdn_13c_source_side.forget

  # Rule MDN.13d: Every two poly fingers shall be surrounded by a P-sub guard ring.
  ## (Exclude the case when each LDNMOS transistor have full width butting to well tap).
  logger.info('Executing rule MDN.13d')
  mdn_13d_single      = mvsd_mdn.covering(ncomp.not_interacting(poly2)).interacting(ncomp, 2, 2)
  mdn_13d_multi       = mvsd_mdn.covering(ncomp.not_interacting(poly2)).interacting(ncomp, 3, 3)
  mdn_13d_butted_well = mdn_source.sized(1.um).sized(-1.um).extents.not(pcomp).interacting(mdn_ldnmos, 2, 2)
  mdn13d_l1 = pcomp_holes.covering(mdn_13d_single, 2)
  mdn13d_l2 = pcomp_holes.covering(mdn_13d_single).covering(mdn_13d_multi)
  mdn13d_l = mdn13d_l1.join(mdn13d_l2).join(mdn_13d_butted_well)
  mdn13d_l.output('MDN.13d', "MDN.13d : Every two poly fingers shall be surrounded by a P-sub guard ring.
                    (Exclude the case when each LDNMOS transistor have full width butting to well tap).")
  mdn13d_l.forget
  mdn13d_l1.forget
  mdn13d_l2.forget
  mdn_13d_single.forget
  mdn_13d_multi.forget
  mdn_13d_butted_well.forget
  mdn_source.forget
  mdn_ldnmos.forget

  # Rule MDN.14: Min MVSD space to any DNWELL.
  logger.info('Executing rule MDN.14')
  mdn14_l1 = mvsd.separation(dnwell, 6.0.um).polygons(0.001.um).join(mvsd.not_outside(dnwell))
  mdn14_l1.output('MDN.14', 'MDN.14 : Min MVSD space to any DNWELL.')
  mdn14_l1.forget

  # Rule MDN.15a: Min LDNMOS drain COMP width. is 0.22µm
  logger.info('Executing rule MDN.15a')
  mdn15a_l1 = comp_mdn.and(mvsd).width(0.22.um, euclidian)
  mdn15a_l1.output('MDN.15a', 'MDN.15a : Min LDNMOS drain COMP width. : 0.22µm')
  mdn15a_l1.forget

  # Rule MDN.15b: Min LDNMOS drain COMP enclose contact. is 0µm
  logger.info('Executing rule MDN.15b')
  mdn15b_l1 = contact.interacting(ncomp_mdn.and(mvsd)).not(ncomp.and(mvsd))
  mdn15b_l1.output('MDN.15b', 'MDN.15b : Min LDNMOS drain COMP enclose contact. : 0µm')
  mdn15b_l1.forget

  # Rule MDN.16 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_12_1.html

  # Rule MDN.17: It is recommended to surround the LDNMOS transistor with
  ## non-broken Psub guard ring to improve the latch up immunity.
  ## Guideline to improve the latch up immunity.
  logger.info('Executing rule MDN.17')
  mdn_17_pcomp = pcomp_holes.and(ldmos_xtor.interacting(mvsd))
  mdn_17_ldnmos = ncomp_ld.join(poly_ld).join(mvsd_mdn)
  mdn17_l1 = mdn_17_ldnmos.not_inside(mdn_17_pcomp)
  mdn17_l2 = ldmos_xtor.and(dualgate).interacting(mvsd).not_covering(pcomp)
  mdn17_l = mdn17_l1.join(mdn17_l2)
  mdn17_l.output('MDN.17', "MDN.17 : It is recommended to surround the LDNMOS transistor with
                   non-broken Psub guard ring to improve the latch up immunity.
                   Guideline to improve the latch up immunity.")
  mdn17_l.forget
  mdn17_l1.forget
  mdn17_l2.forget
  mdn_17_ldnmos.forget
  mdn_17_pcomp.forget
  ldnmos_gate_ends.forget
  ldnmos_edges.forget
  ldnmos.forget
  poly_mdn.forget
  pcomp_holes.forget
  poly_ld.forget
  ncomp_ld.forget
  mvsd_mdn.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #---------------------NPLUS----------------------
  #================================================

  logger.info('Starting NPLUS derivations')

  nplus_edges = nplus.edges
  pcomp_edges = pcomp.edges
  nplus_n_dn = nplus.not(dnwell)
  ncomp_butted = ncomp.interacting(pcomp)
  nplus_butted_edges = nplus.edges.and(pcomp.edges)
  nwell_n_dn_sized_out = nwell_n_dn.sized(0.429.um)
  nwell_n_dn_sized_in  = nwell_n_dn.sized(-0.429.um)
  lvpwell_dn_sized_out = lvpwell_dn.sized(0.429.um)
  lvpwell_dn_sized_in  = lvpwell_dn.sized(-0.429.um)

  # Rule NP.1: min. nplus width is 0.4µm
  logger.info('Executing rule NP.1')
  np1_l1 = nplus.width(0.4.um, euclidian)
  np1_l1.output('NP.1', 'NP.1 : min. nplus width : 0.4µm')
  np1_l1.forget

  # Rule NP.2: min. nplus spacing is 0.4µm
  logger.info('Executing rule NP.2')
  np2_l1 = nplus.space(0.4.um, euclidian)
  np2_l1.output('NP.2', 'NP.2 : min. nplus spacing : 0.4µm')
  np2_l1.forget

  # Rule NP.3a: Space to PCOMP for PCOMP:
  ## (1) Inside Nwell (2) Outside LVPWELL but inside DNWELL. is 0.16µm
  logger.info('Executing rule NP.3a')
  np3_nplus = nplus.not_interacting(ncomp_butted)
  np3a_pcomp = pcomp.and(nwell).join(pcomp.not(lvpwell).and(dnwell))
  np3a_l1 = np3_nplus.separation(np3a_pcomp, 0.16.um, euclidian)
  np3a_l1.output('NP.3a', 'NP.3a : Space to PCOMP for PCOMP:
                  (1) Inside Nwell (2) Outside LVPWELL but inside DNWELL. : 0.16µm')
  np3a_l1.forget
  np3a_pcomp.forget

  # Rule NP.3bi: Space to PCOMP: For Inside DNWELL, inside LVPWELL:
  ## (i) For PCOMP overlap by LVPWELL < 0.43um is 0.16µm.
  logger.info('Executing rule NP.3bi')
  np_3bi_pcomp = pcomp.and(lvpwell_dn.not(lvpwell_dn_sized_in))
  np3bi_l1 = np3_nplus.and(lvpwell_dn).separation(np_3bi_pcomp, 0.16.um, euclidian)
  np3bi_l1.output('NP.3bi', 'NP.3bi : Space to PCOMP: For Inside DNWELL, inside LVPWELL:
                   (i) For PCOMP overlap by LVPWELL < 0.43um. : 0.16µm')
  np3bi_l1.forget
  np_3bi_pcomp.forget

  # Rule NP.3bii: Space to PCOMP: For Inside DNWELL, inside LVPWELL:
  ## (ii) For PCOMP overlap by LVPWELL >= 0.43um. is 0.08µm
  logger.info('Executing rule NP.3bii')
  np_3bii_pcomp = pcomp.and(lvpwell_dn_sized_in)
  np3bii_l1 = np3_nplus.and(lvpwell_dn).separation(np_3bii_pcomp, 0.08.um, euclidian)
  np3bii_l1.output('NP.3bii', 'NP.3bii : Space to PCOMP: For Inside DNWELL, inside LVPWELL:
                    (ii) For PCOMP overlap by LVPWELL >= 0.43um. : 0.08µm')
  np3bii_l1.forget
  np_3bii_pcomp.forget

  # Rule NP.3ci: Space to PCOMP: For Outside DNWELL:
  ## (i) For PCOMP space to Nwell < 0.43um. is 0.16µm
  logger.info('Executing rule NP.3ci')
  np_3ci_pcomp = pcomp.not(dnwell).and(nwell_n_dn_sized_out)
  np3ci_l1 = np3_nplus.not(dnwell).separation(np_3ci_pcomp, 0.16.um, euclidian)
  np3ci_l1.output('NP.3ci', 'NP.3ci : Space to PCOMP: For Outside DNWELL:
                   (i) For PCOMP space to Nwell < 0.43um. : 0.16µm')
  np3ci_l1.forget
  np_3ci_pcomp.forget

  # Rule NP.3cii: Space to PCOMP: For Outside DNWELL:
  ## (ii) For PCOMP space to Nwell >= 0.43um. is 0.08µm
  logger.info('Executing rule NP.3cii')
  np_3cii_pcomp = pcomp.not(dnwell).not(nwell_n_dn_sized_out)
  np3cii_l1 = np3_nplus.not(dnwell).separation(np_3cii_pcomp, 0.08.um, euclidian)
  np3cii_l1.output('NP.3cii', 'NP.3cii : Space to PCOMP: For Outside DNWELL:
                    (ii) For PCOMP space to Nwell >= 0.43um. : 0.08µm')
  np3cii_l1.forget
  np_3cii_pcomp.forget

  # Rule NP.3d: Min/max space to a butted PCOMP is 0um.
  logger.info('Executing rule NP.3d')
  np3d_l1 = ncomp.and(pcomp)
  np3d_l1.output('NP.3d', 'NP.3d : Min/max space to a butted PCOMP: 0um')
  np3d_l1.forget

  # Rule NP.3e: Space to related PCOMP edge adjacent to a butting edge is 0um.
  logger.info('Executing rule NP.3e')
  np3e_l1 = nplus.and(pcomp)
  np3e_l1.output('NP.3e', 'NP.3e : Space to related PCOMP edge adjacent to a butting edge: 0um')
  np3e_l1.forget

  # Rule NP.4a: Space to related P-channel gate at a butting edge parallel to gate. is 0.32µm
  logger.info('Executing rule NP.4a')
  np4a_l1 = nplus_edges.and(pcomp_edges).separation(pgate.edges, 0.32.um, projection)
  np4a_l1.output('NP.4a', 'NP.4a : Space to related P-channel gate at a butting edge parallel to gate. : 0.32µm')
  np4a_l1.forget

  # Rule NP.4b: Within 0.32um of channel, space to P-channel gate extension perpendicular
  ## to the direction of Poly2.
  np_4b_poly = poly2.edges.interacting(pgate.edges.not(pcomp_edges)).centers(0, 0.99).and(pgate.sized(0.32.um))
  logger.info('Executing rule NP.4b')
  np4b_l1 = nplus.interacting(nplus_edges.separation(np_4b_poly, 0.22.um, projection).polygons(0.001.um))
  np4b_l1.output('NP.4b', 'NP.4b : Within 0.32um of channel, space to P-channel gate extension perpendicular
                  to the direction of Poly2.')
  np4b_l1.forget
  np_4b_poly.forget

  # Rule NP.5a: Overlap of N-channel gate. is 0.23µm
  logger.info('Executing rule NP.5a')
  np5a_l1 = ngate.enclosed(nplus, 0.23.um, euclidian).polygons(0.001.um)
  np5a_l2 = ngate.not_outside(nplus).not(nplus)
  np5a_l  = np5a_l1.or(np5a_l2)
  np5a_l.output('NP.5a', 'NP.5a : Overlap of N-channel gate. : 0.23µm')
  np5a_l1.forget
  np5a_l2.forget
  np5a_l.forget

  # Rule NP.5b: Extension beyond COMP for the COMP
  ## (1) inside LVPWELL (2) outside Nwell and DNWELL is 0.16µm.
  logger.info('Executing rule PP.5b')
  np5b_nplus_slct = nplus.edges.not(nplus_butted_edges)
  np5b_nplus = np5b_nplus_slct.and(lvpwell).join(np5b_nplus_slct.not(nwell).not(dnwell))
  np5b_l1 = ncomp.edges.enclosed(np5b_nplus, 0.16.um, projection)
  np5b_l1.output('NP.5b', 'NP.5b : Extension beyond COMP for the COMP
                  (1) inside LVPWELL (2) outside Nwell and DNWELL. : 0.16µm')
  np5b_l1.forget
  np5b_nplus.forget
  np5b_nplus_slct.forget

  # Rule NP.5ci: Extension beyond COMP: For Inside DNWELL: (i)For Nplus < 0.43um
  ## from LVPWELL edge for Nwell or DNWELL tap inside DNWELL. is 0.16µm
  logger.info('Executing rule NP.5ci')
  np_5ci_background = nplus.not_inside(lvpwell).inside(dnwell).edges
  np_5ci_foreground = ncomp.not_inside(lvpwell).inside(dnwell).edges.not(pplus.edges).and(lvpwell_dn_sized_out)
  np5ci_l1 = np_5ci_background.enclosing(np_5ci_foreground, 0.16.um, projection)
  np5ci_l1.output('NP.5ci', 'NP.5ci : Extension beyond COMP: For Inside DNWELL: (i)For Nplus < 0.43um
                   from LVPWELL edge for Nwell or DNWELL tap inside DNWELL. : 0.16µm')
  np5ci_l1.forget
  np_5ci_background.forget
  np_5ci_foreground.forget

  # Rule NP.5cii: Extension beyond COMP: For Inside DNWELL: (ii) For Nplus >= 0.43um
  ## from LVPWELL edge for Nwell or DNWELL tap inside DNWELL. is 0.02µm
  logger.info('Executing rule NP.5cii')
  np_5cii_background = nplus.not_inside(lvpwell).inside(dnwell).edges
  np_5cii_foreground = ncomp.not_inside(lvpwell).inside(dnwell).edges.not(pplus.edges).not(lvpwell_dn_sized_out)
  np5cii_l1 = np_5cii_background.enclosing(np_5cii_foreground, 0.02.um, projection)
  np5cii_l1.output('NP.5cii', 'NP.5cii : Extension beyond COMP: For Inside DNWELL: (ii) For Nplus >= 0.43um
                    from LVPWELL edge for Nwell or DNWELL tap inside DNWELL. : 0.02µm')
  np5cii_l1.forget
  np_5cii_background.forget
  np_5cii_foreground.forget
  lvpwell_dn_sized_out.forget

  # Rule NP.5di: Extension beyond COMP: For Outside DNWELL, inside Nwell:
  ## (i) For Nwell overlap of Nplus < 0.43um. is 0.16µm
  logger.info('Executing rule NP.5di')
  np_5di_background = nplus_n_dn.not_outside(nwell).edges
  np_5di_extend     = nwell_n_dn.not(nwell_n_dn_sized_in)
  np_5di_foreground = ncomp.not_outside(nwell).outside(dnwell).edges.not(pplus.edges).and(np_5di_extend)
  np5di_l1 = np_5di_background.enclosing(np_5di_foreground, 0.16.um, projection)
  np5di_l1.output('NP.5di', 'NP.5di : Extension beyond COMP: For Outside DNWELL, inside Nwell:
                  (i) For Nwell overlap of Nplus < 0.43um. : 0.16µm')
  np5di_l1.forget
  np_5di_background.forget
  np_5di_extend.forget
  np_5di_foreground.forget

  # Rule NP.5dii: Extension beyond COMP: For Outside DNWELL, inside Nwell:
  ## (ii) For Nwell overlap of Nplus >= 0.43um. is 0.02µm
  logger.info('Executing rule NP.5dii')
  np_5dii_background = nplus_n_dn.not_outside(nwell).edges.not(pplus.edges)
  np_5dii_foreground = ncomp.not_outside(nwell).outside(dnwell).edges.not(pplus.edges).and(nwell_n_dn_sized_in)
  np5dii_l1 = np_5dii_background.enclosing(np_5dii_foreground, 0.02.um, euclidian)
  np5dii_l1.output('NP.5dii', 'NP.5dii : Extension beyond COMP: For Outside DNWELL, inside Nwell:
                    (ii) For Nwell overlap of Nplus >= 0.43um. : 0.02µm')
  np5dii_l1.forget
  np_5dii_background.forget
  nwell_n_dn_sized_in.forget
  np_5dii_foreground.forget
  nplus_n_dn.forget

  # Rule NP.6: Overlap with NCOMP butted to PCOMP. is 0.22µm
  logger.info('Executing rule NP.6')
  np6_l1 = comp.interacting(nplus).enclosing(pcomp.interacting(nplus), 0.22.um, projection).polygons
  np6_l1.output('NP.6', 'NP.6 : Overlap with NCOMP butted to PCOMP. : 0.22µm')
  np6_l1.forget

  # Rule NP.7: Space to unrelated unsalicided Poly2. is 0.18µm
  logger.info('Executing rule NP.7')
  np7_l1 = nplus.separation(poly2.and(sab), 0.18.um, euclidian)
  np7_l1.output('NP.7', 'NP.7 : Space to unrelated unsalicided Poly2. : 0.18µm')
  np7_l1.forget

  # Rule NP.8a: Minimum Nplus area (um2). is 0.35µm²
  logger.info('Executing rule NP.8a')
  np8a_l1 = nplus.with_area(nil, 0.35.um)
  np8a_l1.output('NP.8a', 'NP.8a : Minimum Nplus area (um2). : 0.35µm²')
  np8a_l1.forget

  # Rule NP.8b: Minimum area enclosed by Nplus (um2). is 0.35µm²
  logger.info('Executing rule NP.8b')
  np8b_l1 = nplus.holes.with_area(nil, 0.35.um)
  np8b_l1.output('NP.8b', 'NP.8b : Minimum area enclosed by Nplus (um2). : 0.35µm²')
  np8b_l1.forget

  # Rule NP.9: Overlap of unsalicided Poly2. is 0.18µm
  logger.info('Executing rule NP.9')
  np9_l1 = nplus.enclosing(poly2.and(sab), 0.18.um, euclidian).polygons(0.001.um)
  np9_l2 = poly2.and(sab).not_outside(nplus).not(nplus)
  np9_l  = np9_l1.or(np9_l2)
  np9_l.output('NP.9', 'NP.9 : Overlap of unsalicided Poly2. : 0.18µm')
  np9_l1.forget
  np9_l2.forget
  np9_l.forget

  # Rule NP.10: Overlap of unsalicided COMP. is 0.18µm
  logger.info('Executing rule NP.10')
  np10_l1 = nplus.enclosing(comp.and(sab), 0.18.um, euclidian)
  np10_l1.output('NP.10', 'NP.10 : Overlap of unsalicided COMP. : 0.18µm')
  np10_l1.forget

  # Rule NP.11: Butting Nplus and PCOMP is forbidden within 0.43um of Nwell edge (for outside DNWELL)
  ## and of LVPWELL edge (for inside DNWELL case).
  logger.info('Executing rule NP.11')
  np_11_nwell_exclusion_area = nwell_n_dn_sized_out.not(nwell_n_dn)
  np_11_lvpwell_exclude_area = lvpwell_dn.not(lvpwell_dn_sized_in)
  np11_l1 = nplus_butted_edges.and(np_11_nwell_exclusion_area)
  np11_l2 = nplus_butted_edges.and(np_11_lvpwell_exclude_area)
  np11_l = np11_l1.join(np11_l2)
  np11_l.output('NP.11',
                'NP.11 : Butting Nplus and PCOMP is forbidden within 0.43um of Nwell edge (for outside DNWELL)
                  and of LVPWELL edge (for inside DNWELL case).')
  np11_l.forget
  np11_l1.forget
  np11_l2.forget
  np_11_nwell_exclusion_area.forget
  np_11_lvpwell_exclude_area.forget
  nplus_butted_edges.forget
  nwell_n_dn_sized_out.forget
  lvpwell_dn_sized_in.forget

  # Rule NP.12: Overlap with P-channel poly2 gate extension is forbidden
  ## within 0.32um of P-channel gate.
  logger.info('Executing rule NP.12')
  np12_l1 = nplus.interacting(nplus_edges.separation(pgate.edges.and(pcomp_edges), 0.32.um,
                                                     euclidian).polygons(0.001.um))
  np12_l1.output('NP.12', 'NP.12 : Overlap with P-channel poly2 gate extension is forbidden
                  within 0.32um of P-channel gate.')
  np12_l1.forget
  nplus_edges.forget
  pcomp_edges.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #--------------------YMTP_MK---------------------
  #================================================

  logger.info('Starting YMTP_MK derivations')

  ymtp_mk_lv = ymtp_mk.not_interacting(v5_xtor).not_interacting(dualgate)
  ymtp_mk_mv = ymtp_mk.overlapping(dualgate)
  comp_ymtp_lv = comp.and(ymtp_mk_lv)
  comp_ymtp_mv = comp.and(ymtp_mk_mv)
  poly_ymtp_lv = poly2.and(ymtp_mk_lv)
  poly_ymtp_mv = poly2.and(ymtp_mk_mv)

  # Rule Y.NW.2b_LV: Min. Nwell Space
  ## (Outside DNWELL, Inside YMTP_MK) [Different potential]. is 1µm
  logger.info('Executing rule Y.NW.2b_LV')
  ynw2b_l1 = nwell_n_dn.and(ymtp_mk_lv).space(1.um, euclidian)
  ynw2b_l1.output('Y.NW.2b_LV', "Y.NW.2b_LV : Min. Nwell Space
                    (Outside DNWELL, Inside YMTP_MK) [Different potential]. : 1µm")
  ynw2b_l1.forget

  # Rule Y.NW.2b_MV: Min. Nwell Space
  ## (Outside DNWELL, Inside YMTP_MK) [Different potential]. is 1µm
  logger.info('Executing rule Y.NW.2b_MV')
  ynw2b_l1 = nwell_n_dn.and(ymtp_mk_mv).space(1.um, euclidian)
  ynw2b_l1.output('Y.NW.2b_MV', "Y.NW.2b_MV : Min. Nwell Space
                     (Outside DNWELL, Inside YMTP_MK) [Different potential]. : 1µm")
  ynw2b_l1.forget

  # Rule Y.DF.4d_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_13.html

  # Rule Y.DF.4d_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_13.html

  # Rule Y.DF.6_MV: Min. COMP extend beyond gate
  ## (it also means source/drain overhang) inside YMTP_MK. is 0.15µm
  logger.info('Executing rule Y.DF.6_MV')
  ydf6_l1 = poly_ymtp_mv.enclosed(comp.not(otp_mk).and(ymtp_mk_mv), 0.15.um, euclidian)
  ydf6_l1.output('Y.DF.6_MV', "Y.DF.6_MV : Min. COMP extend beyond gate
                    (it also means source/drain overhang) inside YMTP_MK. : 0.15µm")
  ydf6_l1.forget

  # Rule Y.DF.16_LV: Min. space from (Nwell outside DNWELL) to
  ## (unrelated NCOMP outside Nwell and DNWELL) (inside YMTP_MK). is 0.27µm
  logger.info('Executing rule Y.DF.16_LV')
  ydf16_l1 = ncomp.and(ymtp_mk_lv).outside(all_nwell).separation(nwell_n_dn, 0.27.um, euclidian)
  ydf16_l1.output('Y.DF.16_LV', "Y.DF.16_LV : Min. space from (Nwell outside DNWELL) to
                    (unrelated NCOMP outside Nwell and DNWELL) (inside YMTP_MK). : 0.27µm")
  ydf16_l1.forget
  ymtp_mk_lv.forget

  # Rule Y.DF.16_MV: Min. space from (Nwell outside DNWELL) to
  ## (unrelated NCOMP outside Nwell and DNWELL) (inside YMTP_MK). is 0.23µm
  logger.info('Executing rule Y.DF.16_MV')
  ydf16_l1 = ncomp.and(ymtp_mk_mv).outside(all_nwell).separation(nwell_n_dn, 0.23.um, euclidian)
  ydf16_l1.output('Y.DF.16_MV', "Y.DF.16_MV : Min. space from (Nwell outside DNWELL) to
                     (unrelated NCOMP outside Nwell and DNWELL) (inside YMTP_MK). : 0.23µm")
  ydf16_l1.forget
  ymtp_mk_mv.forget

  # Rule Y.PL.1_LV: Interconnect Width (inside YMTP_MK). is 0.13µm
  logger.info('Executing rule Y.PL.1_LV')
  ypl1_l1 = poly_ymtp_lv.outside(plfuse).width(0.13.um, euclidian)
  ypl1_l1.output('Y.PL.1_LV', 'Y.PL.1_LV : Interconnect Width (inside YMTP_MK). : 0.13µm')
  ypl1_l1.forget

  # Rule Y.PL.1_MV: Interconnect Width (inside YMTP_MK).
  ## This rule is currently not applicable for 5V.
  logger.info('Executing rule Y.PL.1_MV')
  ypl1_l1 = poly_ymtp_mv.outside(plfuse)
  ypl1_l1.output('Y.PL.1_MV', "Y.PL.1_MV : Interconnect Width (inside YMTP_MK).
                    This rule is currently not applicable for 5V.")
  ypl1_l1.forget

  # Rule Y.PL.2_LV: Gate Width (Channel Length) (inside YMTP_MK) is 0.13µm.
  logger.info('Executing rule Y.PL.2_LV')
  ypl2_l1 = poly_ymtp_lv.edges.and(tgate.edges).not(otp_mk).width(0.13.um, euclidian)
  ypl2_l1.output('Y.PL.2_LV', 'Y.PL.2_LV : Gate Width (Channel Length) (inside YMTP_MK): 0.13µm')
  ypl2_l1.forget

  # Rule Y.PL.2_MV: Gate Width (Channel Length) (inside YMTP_MK) is 0.47µm.
  logger.info('Executing rule Y.PL.2_MV')
  ypl2_l1 = poly_ymtp_mv.edges.and(tgate.edges).not(otp_mk).width(0.47.um, euclidian)
  ypl2_l1.output('Y.PL.2_MV', 'Y.PL.2_MV : Gate Width (Channel Length) (inside YMTP_MK): 0.47µm')
  ypl2_l1.forget

  # Rule Y.PL.4_MV: Poly2 extension beyond COMP to form Poly2 end cap (inside YMTP_MK) is 0.16µm.
  logger.info('Executing rule Y.PL.4_MV')
  ypl4_l1 = comp_ymtp_mv.enclosed(poly_ymtp_mv, 0.16.um, euclidian)
  ypl4_l1.output('Y.PL.4_MV',
                 'Y.PL.4_MV : Poly2 extension beyond COMP to form Poly2 end cap (inside YMTP_MK): 0.16µm')
  ypl4_l1.forget

  # Rule Y.PL.5a_LV: Space from field Poly2 to unrelated COMP (inside YMTP_MK).
  ##  Space from field Poly2 to Guard-ring (inside YMTP_MK). is 0.04µm
  logger.info('Executing rule Y.PL.5a_LV')
  ypl5a_l1 = poly_ymtp_lv.separation(comp_ymtp_lv, 0.04.um, euclidian)
  ypl5a_l1.output('Y.PL.5a_LV', "Y.PL.5a_LV : Space from field Poly2 to unrelated COMP (inside YMTP_MK).
                     Space from field Poly2 to Guard-ring (inside YMTP_MK). : 0.04µm")
  ypl5a_l1.forget

  # Rule Y.PL.5a_MV: Space from field Poly2 to unrelated COMP (inside YMTP_MK).
  ## Space from field Poly2 to Guard-ring (inside YMTP_MK). is 0.2µm
  logger.info('Executing rule Y.PL.5a_MV')
  ypl5a_l1 = poly_ymtp_mv.separation(comp_ymtp_mv, 0.2.um, euclidian)
  ypl5a_l1.output('Y.PL.5a_MV', "Y.PL.5a_MV : Space from field Poly2 to unrelated COMP (inside YMTP_MK).
                     Space from field Poly2 to Guard-ring (inside YMTP_MK). : 0.2µm")
  ypl5a_l1.forget

  # Rule Y.PL.5b_LV: Space from field Poly2 to related COMP (inside YMTP_MK). is 0.04µm
  logger.info('Executing rule Y.PL.5b_LV')
  ypl5b_l1 = poly_ymtp_lv.separation(comp_ymtp_lv, 0.04.um, euclidian)
  ypl5b_l1.output('Y.PL.5b_LV', 'Y.PL.5b_LV : Space from field Poly2 to related COMP (inside YMTP_MK). : 0.04µm')
  ypl5b_l1.forget
  comp_ymtp_lv.forget
  poly_ymtp_lv.forget

  # Rule Y.PL.5b_MV: Space from field Poly2 to related COMP (inside YMTP_MK). is 0.2µm
  logger.info('Executing rule Y.PL.5b_MV')
  ypl5b_l1 = poly_ymtp_mv.separation(comp_ymtp_mv, 0.2.um, euclidian)
  ypl5b_l1.output('Y.PL.5b_MV', 'Y.PL.5b_MV : Space from field Poly2 to related COMP (inside YMTP_MK). : 0.2µm')
  ypl5b_l1.forget
  poly_ymtp_mv.forget
  comp_ymtp_mv.forget

  # Rule Y.PL.6_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_13.html

  # Rule Y.PL.6_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_13.html
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if BEOL && (METAL_LEVEL == '6LM')
  #================================================
  #---------------------METAL5---------------------
  #================================================

  # Rule M5.1: min. metal5 width is 0.28µm
  logger.info('Executing rule M5.1')
  m51_l1 = metal5.width(0.28.um, euclidian)
  m51_l1.output('M5.1', 'M5.1 : min. metal5 width : 0.28µm')
  m51_l1.forget

  # Rule M5.2a: min. metal5 spacing is 0.28µm
  logger.info('Executing rule M5.2a')
  m52a_l1 = metal5.space(0.28.um, euclidian)
  m52a_l1.output('M5.2a', 'M5.2a : min. metal5 spacing : 0.28µm')
  m52a_l1.forget

  # Rule M5.2b: Space to wide Metal5 (length & width > 10um) is 0.3µm
  logger.info('Executing rule M5.2b')
  wide_m5 = metal5.not_interacting(metal5.edges.with_length(nil, 10.um))
  m52b_l1 = metal5.separation(wide_m5, 0.3.um, euclidian)
  m52b_l1.output('M5.2b', 'M5.2b : Space to wide Metal5 (length & width > 10um) : 0.3µm')
  m52b_l1.forget
  wide_m5.forget

  # Rule M5.3: Minimum metal5 area is 0.1444µm²
  logger.info('Executing rule M5.3')
  m53_l1 = metal5.with_area(nil, 0.1444.um)
  m53_l1.output('M5.3', 'M5.3 : Minimum metal5 area : 0.1444µm²')
  m53_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #----------------N+ POLY RESISTOR----------------
  #================================================

  logger.info('Starting LRES derivations')
  lres_poly = poly2.and(nplus).interacting(sab).interacting(res_mk)

  # Rule LRES.1: Minimum width of Poly2 resistor. is 0.8µm
  logger.info('Executing rule LRES.1')
  lres1_l1 = lres_poly.width(0.8.um, euclidian)
  lres1_l1.output('LRES.1', 'LRES.1 : Minimum width of Poly2 resistor. : 0.8µm')
  lres1_l1.forget

  # Rule LRES.2: Minimum space between Poly2 resistors. is 0.4µm
  logger.info('Executing rule LRES.2')
  lres2_l1 = lres_poly.isolated(0.4.um, euclidian)
  lres2_l1.output('LRES.2', 'LRES.2 : Minimum space between Poly2 resistors. : 0.4µm')
  lres2_l1.forget

  # Rule LRES.3: Minimum space from Poly2 resistor to COMP.
  logger.info('Executing rule LRES.3')
  lres3_l1 = lres_poly.separation(comp, 0.6.um, euclidian).polygons(0.001.um).or(comp.not_outside(lres_poly))
  lres3_l1.output('LRES.3', 'LRES.3 : Minimum space from Poly2 resistor to COMP.')
  lres3_l1.forget

  # Rule LRES.4: Minimum space from Poly2 resistor to unrelated Poly2. is 0.6µm
  logger.info('Executing rule LRES.4')
  lres4_l1 = lres_poly.separation(poly2.not_interacting(sab), 0.6.um, euclidian)
  lres4_l1.output('LRES.4', 'LRES.4 : Minimum space from Poly2 resistor to unrelated Poly2. : 0.6µm')
  lres4_l1.forget

  # Rule LRES.5: Minimum Nplus implant overlap of Poly2 resistor. is 0.3µm
  logger.info('Executing rule LRES.5')
  lres5_l1 = lres_poly.enclosed(nplus, 0.3.um, euclidian).polygons(0.001.um)
  lres5_l2 = lres_poly.not_outside(nplus).not(nplus)
  lres5_l  = lres5_l1.or(lres5_l2)
  lres5_l.output('LRES.5', 'LRES.5 : Minimum Nplus implant overlap of Poly2 resistor. : 0.3µm')
  lres5_l1.forget
  lres5_l2.forget
  lres5_l.forget

  # Rule LRES.6: Minimum salicide block overlap of Poly2 resistor in width direction. is 0.28µm
  logger.info('Executing rule LRES.6')
  lres6_l1 = lres_poly.enclosed(sab, 0.28.um)
  lres6_l1.output('LRES.6', 'LRES.6 : Minimum salicide block overlap of Poly2 resistor in width direction. : 0.28µm')
  lres6_l1.forget

  # Rule LRES.7: Space from salicide block to contact on Poly2 resistor.
  logger.info('Executing rule LRES.7')
  cont_lres7 = contact.and(lres_poly)
  lres7_l1 = cont_lres7.separation(sab, 0.22.um).polygons(0.001.um)
  lres7_l2 = cont_lres7.interacting(sab)
  lres7_l = lres7_l1.or(lres7_l2)
  lres7_l.output('LRES.7', 'LRES.7 : Space from salicide block to contact on Poly2 resistor.')
  lres7_l.forget
  lres7_l1.forget
  lres7_l2.forget
  cont_lres7.forget

  # Rule LRES.8 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_02.html#n-poly-resistor-low-sheet-rho

  # Rule LRES.9a: Nplus Poly2 resistor shall be covered by RES_MK marking.
  ## RES_MK length shall be coincide with resistor length (Defined by SAB length)
  ## and width covering the width of Poly2.
  logger.info('Executing rule LRES.9a')
  mk_lres9 = res_mk.edges.not(poly2.and(nplus).and(sab).edges).inside_part(poly2)
  lres9a_l1 = res_mk.interacting(lres_poly).interacting(mk_lres9)
  lres9a_l1.output('LRES.9a',
                   'LRES.9a : Nplus Poly2 resistor shall be covered by RES_MK marking.
                    RES_MK length shall be coincide with resistor length (Defined by SAB length)
                    and width covering the width of Poly2. ')
  lres9a_l1.forget
  mk_lres9.forget

  # Rule LRES.9b: If the size of single RES_MK mark layer is greater than 15000um2
  ## and both side (X and Y) are greater than 80um.
  ## then the minimum spacing to adjacent RES_MK layer. is 20µm
  logger.info('Executing rule LRES.9b')
  lres9b = res_mk.with_area(15_000.001.um, nil).edges.with_length(80.001.um, nil)
  lres9b_l1 = lres9b.separation(res_mk.edges, 20.um)
  lres9b_l1.output('LRES.9b',
                   'LRES.9b : If the size of single RES_MK mark layer is greater than 15000um2
                    and both side (X and Y) are greater than 80um.
                    then the minimum spacing to adjacent RES_MK layer. : 20µm')
  lres9b_l1.forget
  lres9b.forget
  lres_poly.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if BEOL && (METAL_LEVEL == '5LM' || METAL_LEVEL == '6LM')
  #================================================
  #---------------------METAL4---------------------
  #================================================

  # Rule M4.1: min. metal4 width is 0.28µm
  logger.info('Executing rule M4.1')
  m41_l1 = metal4.width(0.28.um, euclidian)
  m41_l1.output('M4.1', 'M4.1 : min. metal4 width : 0.28µm')
  m41_l1.forget

  # Rule M4.2a: min. metal4 spacing is 0.28µm
  logger.info('Executing rule M4.2a')
  m42a_l1 = metal4.space(0.28.um, euclidian)
  m42a_l1.output('M4.2a', 'M4.2a : min. metal4 spacing : 0.28µm')
  m42a_l1.forget

  # Rule M4.2b: Space to wide Metal4 (length & width > 10um) is 0.3µm
  logger.info('Executing rule M4.2b')
  wide_m4 = metal4.not_interacting(metal4.edges.with_length(nil, 10.um))
  m42b_l1 = metal4.separation(wide_m4, 0.3.um, euclidian)
  m42b_l1.output('M4.2b', 'M4.2b : Space to wide Metal4 (length & width > 10um) : 0.3µm')
  m42b_l1.forget
  wide_m4.forget

  # Rule M4.3: Minimum metal4 area is 0.1444µm²
  logger.info('Executing rule M4.3')
  m43_l1 = metal4.with_area(nil, 0.1444.um)
  m43_l1.output('M4.3', 'M4.3 : Minimum metal4 area : 0.1444µm²')
  m43_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

# Metal stack
if BEOL && (METAL_LEVEL == '4LM' || METAL_LEVEL == '5LM' || METAL_LEVEL == '6LM')
  #================================================
  #----------------------via3----------------------
  #================================================

  # Rule V3.1: Min/max Via1 size . is 0.26µm
  logger.info('Executing rule V3.1')
  v31_l1 = via3.edges.without_length(0.26.um)
  v31_l1.output('V3.1', 'V3.1 : Min/max Via1 size . : 0.26µm')
  v31_l1.forget

  # Rule V3.2a: min. via3 spacing is 0.26µm
  logger.info('Executing rule V3.2a')
  v32a_l1 = via3.space(0.26.um, euclidian)
  v32a_l1.output('V3.2a', 'V3.2a : min. via3 spacing : 0.26µm')
  v32a_l1.forget

  # Rule V3.2b: via3 Space in 4x4 or larger via3 array is 0.36µm
  logger.info('Executing rule V3.2b')
  via3_egde_length = 0.26 * 3 + 3 * 0.36
  poss_4_4_via3 = via3.sized(0.2, 'square_limit').merged.sized(-0.2, 'square_limit')
  via3_4x4_all = poss_4_4_via3.with_bbox_min(via3_egde_length..nil).interacting(via3, 16..nil)
  via3_4x4_loc_exc = via3_4x4_all.width(via3_egde_length,
                                        projection_limits(via3_egde_length..1000 * via3_egde_length)).polygons
  via3_4x4_loc = via3_4x4_all.not_interacting(via3_4x4_loc_exc)
  selected_via3 = via3.interacting(via3_4x4_loc)
  via3b_l1 = selected_via3.space(0.36.um, euclidian)
  via3b_l1.output('V3.2b', 'V3.2b : via3 Space in 4x4 or larger via3 array : 0.36µm')
  via3b_l1.forget
  poss_4_4_via3.forget
  via3_4x4_all.forget
  via3_4x4_loc_exc.forget
  via3_4x4_loc.forget
  selected_via3.forget

  # Rule V3.3a is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V3.3b: metal3 overlap of via3.
  logger.info('Executing rule V3.3b')
  v33b_l1 = via3.not(metal3)
  v33b_l2 = via3.enclosed(metal3, 0.01.um, euclidian).polygons(0.001.um)
  v33b_l = v33b_l1.or(v33b_l2)
  v33b_l.output('V3.3b', 'V3.3b : metal3 overlap of via3 >= 0.01')
  v33b_l1.forget
  v33b_l2.forget
  v33b_l.forget

  # Rule V3.3c: metal3 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V3.3c')
  v3p3c_cond = metal3.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v3p3c_eol_allowed = metal3.edges.with_length(nil, 0.34.um)
  v3p3c_cond_edge1 = v3p3c_cond.first_edges
  v3p3c_cond_edge2 = v3p3c_cond.second_edges
  v3p3c_eol = v3p3c_eol_allowed.interacting(v3p3c_cond_edge1).interacting(v3p3c_cond_edge2)
                               .not(v3p3c_cond_edge1).not(v3p3c_cond_edge2)
  v3p3c_l1 = via3.edges.enclosed(v3p3c_eol, 0.06.um, projection)
  v3p3c_l1.output('V3.3c', 'V3.3c : metal3 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v3p3c_l1.forget
  v3p3c_cond.forget
  v3p3c_eol.forget
  v3p3c_eol_allowed.forget
  v3p3c_cond_edge1.forget
  v3p3c_cond_edge2.forget

  # Rule V3.3d:  If metal3 overlap via3 by < 0.04um on one side, adjacent metal3 edges overlap. : 0.06µm
  logger.info('Executing rule V3.3d')
  via3_3d_cond_edges = via3.edges.not_outside(via3.enclosed(metal3, 0.04.um, projection).edges)
  via3_3d_check_corner = via3_3d_cond_edges.extended_in(0.002.um)
  via3_3d_check = via3.edges.interacting(via3_3d_check_corner).not(via3_3d_cond_edges)
  via3_cond_corner = via3_3d_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via3_3d_l1 = via3_3d_check.enclosed(metal3.edges, 0.06.um, projection).polygons
  via3_3d_l2 = via3.interacting(via3_cond_corner)
  via3_3d_l = via3_3d_l1.or(via3_3d_l2)
  via3_3d_l.output('V3.3d',
                   'V3.3d : If metal3 overlap via3 by < 0.04um on one side, adjacent metal3 edges overlap. : 0.06µm')
  via3_3d_l.forget
  via3_3d_l2.forget
  via3_3d_l1.forget
  via3_3d_cond_edges.forget
  via3_3d_check_corner.forget
  via3_cond_corner.forget
  via3_3d_check.forget

  # Rule V3.3e is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V3.4a: metal4 overlap of via3.
  logger.info('Executing rule V3.4a')
  via3_4a_l1 = via3.enclosed(metal4, 0.01.um, euclidian).polygons(0.001.um)
  via3_4a_l2 = via3.not(metal4)
  via3_4a_l = via3_4a_l1.or(via3_4a_l2)
  via3_4a_l.output('V3.4a', 'V3.4a : metal4 overlap of via3 >= 0.01 um')
  via3_4a_l1.forget
  via3_4a_l2.forget
  via3_4a_l.forget

  # Rule V3.4b: metal4 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V3.4b')
  v3p4b_cond = metal4.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v3p4b_eol_allowed = metal4.edges.with_length(nil, 0.34.um)
  v3p4b_eol = v3p4b_eol_allowed.interacting(v3p4b_cond.first_edges).interacting(v3p4b_cond.second_edges)
                               .not(v3p4b_cond.first_edges).not(v3p4b_cond.second_edges)
  v3p4b_l1 = via3.edges.enclosed(v3p4b_eol, 0.06.um, projection)
  v3p4b_l1.output('V3.4b', 'V3.4p : metal4 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v3p4b_l1.forget
  v3p4b_cond.forget
  v3p4b_eol.forget
  v3p4b_eol_allowed.forget

  # Rule V3.4c: If metal4 overlap via3 by < 0.04um on one side, adjacent metal4 edges overlap. : 0.06µm
  logger.info('Executing rule V3.4c')
  via3_4c_cond_edges = via3.edges.not_outside(via3.enclosed(metal4, 0.04.um, projection).edges)
  via3_4c_check_corner = via3_4c_cond_edges.extended_in(0.002.um)
  via3_4c_check = via3.edges.interacting(via3_4c_check_corner).not(via3_4c_cond_edges)
  via3_4c_cond_corner = via3_4c_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via3_4c_l1 = via3_4c_check.enclosed(metal4.edges, 0.06.um, projection).polygons
  via3_4c_l2 = via3.interacting(via3_4c_cond_corner)
  via3_4c_l = via3_4c_l1.or(via3_4c_l2)
  via3_4c_l.output('V3.4c',
                   'V3.4c : If metal4 overlap via3 by < 0.04um on one side, adjacent metal4 edges overlap. : 0.06µm')
  via3_4c_l.forget
  via3_4c_l2.forget
  via3_4c_l1.forget
  via3_4c_cond_edges.forget
  via3_4c_check_corner.forget
  via3_4c_cond_corner.forget
  via3_4c_check.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #---------------------OTP_MK---------------------
  #================================================

  logger.info('Starting OTP_MK derivations')

  comp_otp = comp.and(otp_mk)
  poly_otp = poly2.and(otp_mk)
  sab_otp = sab.and(otp_mk)
  tgate_edges = tgate.edges

  # Rule O.DF.3a: Min. COMP Space. P-substrate tap (PCOMP outside NWELL) can be butted
  ##  for different voltage devices as the potential is same. is 0.24µm
  logger.info('Executing rule O.DF.3a')
  odf3a_l1 = comp_otp.space(0.24.um, euclidian)
  odf3a_l1.output('O.DF.3a', 'O.DF.3a : Min. COMP Space. P-substrate tap (PCOMP outside NWELL)
                   can be butted for different voltage devices as the potential is same. : 0.24µm')
  odf3a_l1.forget

  # Rule O.DF.6: Min. COMP extend beyond poly2 (it also means source/drain overhang). is 0.22µm
  logger.info('Executing rule O.DF.6')
  odf6_l1 = poly_otp.enclosed(comp_otp, 0.22.um, projection)
  odf6_l1.output('O.DF.6', 'O.DF.6 : Min. COMP extend beyond poly2 (it also means source/drain overhang). : 0.22µm')
  odf6_l1.forget

  # Rule O.DF.9: Min. COMP area (um2). is 0.1444µm²
  logger.info('Executing rule O.DF.9')
  odf9_l1 = comp_otp.with_area(nil, 0.1444.um)
  odf9_l1.output('O.DF.9', 'O.DF.9 : Min. COMP area (um2). : 0.1444µm²')
  odf9_l1.forget

  # Rule O.PL.2: Min. poly2 width. is 0.22µm
  logger.info('Executing rule O.PL.2')
  opl2_l1 = poly_otp.edges.and(tgate_edges).width(0.22.um, euclidian)
  opl2_l1.output('O.PL.2', 'O.PL.2 : Min. poly2 width. : 0.22µm')
  opl2_l1.forget

  # Rule O.PL.3a: Min. poly2 Space on COMP. is 0.18µm
  logger.info('Executing rule O.PL.3a')
  opl3a_l1 = tgate.join(poly2.not(comp)).and(otp_mk).space(0.18.um, euclidian)
  opl3a_l1.output('O.PL.3a', 'O.PL.3a : Min. poly2 Space on COMP. : 0.18µm')
  opl3a_l1.forget

  # Rule O.PL.4: Min. extension beyond COMP to form Poly2 end cap. is 0.14µm
  logger.info('Executing rule O.PL.4')
  opl4_l1 = comp_otp.enclosed(poly_otp, 0.14.um, euclidian)
  opl4_l1.output('O.PL.4', 'O.PL.4 : Min. extension beyond COMP to form Poly2 end cap. : 0.14µm')
  opl4_l1.forget

  # Rule O.PL.5a is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_10.html

  # Rule O.PL.5b is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_10.html

  # Rule O.SB.2: Min. salicide Block Space. is 0.28µm
  logger.info('Executing rule O.SB.2')
  osb2_l1 = sab_otp.space(0.28.um, euclidian)
  osb2_l1.output('O.SB.2', 'O.SB.2 : Min. salicide Block Space. : 0.28µm')
  osb2_l1.forget

  # Rule O.SB.3: Min. space from salicide block to unrelated COMP. is 0.09µm
  logger.info('Executing rule O.SB.3')
  osb3_l1 = sab.outside(comp).and(otp_mk).separation(comp.outside(sab), 0.09.um, euclidian)
  osb3_l1.output('O.SB.3', 'O.SB.3 : Min. space from salicide block to unrelated COMP. : 0.09µm')
  osb3_l1.forget

  # Rule O.SB.4: Min. space from salicide block to contact.
  logger.info('Executing rule O.SB.4')
  osb4_l1 = sab_otp.separation(contact, 0.03.um, euclidian).polygons(0.001.um).or(sab_otp.and(contact))
  osb4_l1.output('O.SB.4', 'O.SB.4 : Min. space from salicide block to contact.')
  osb4_l1.forget

  # Rule O.SB.5a is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_10.html

  # Rule O.SB.5b_LV: Min. space from salicide block to unrelated Poly2 on COMP. is 0.1µm
  logger.info('Executing rule O.SB.5b_LV')
  sab_otp_lv = sab_otp.not_interacting(v5_xtor).not_interacting(dualgate)
  osb5b_l1 = sab_otp_lv.outside(tgate).separation(tgate.outside(sab), 0.1.um, euclidian)
  osb5b_l1.output('O.SB.5b_LV', 'O.SB.5b_LV : Min. space from salicide block to unrelated Poly2 on COMP. : 0.1µm')
  osb5b_l1.forget
  sab_otp_lv.forget

  # Rule O.SB.5b_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_10.html

  # Rule O.SB.9: Min. salicide block extension beyond unsalicided Poly2. is 0.1µm
  logger.info('Executing rule O.SB.9')
  osb9_l1 = poly_otp.enclosed(sab_otp, 0.1.um, euclidian)
  osb9_l1.output('O.SB.9', 'O.SB.9 : Min. salicide block extension beyond unsalicided Poly2. : 0.1µm')
  osb9_l1.forget

  # Rule O.SB.11: Min. salicide block overlap with COMP. is 0.04µm
  logger.info('Executing rule O.SB.11')
  osb11_l1 = sab_otp.overlap(comp, 0.04.um, euclidian)
  osb11_l1.output('O.SB.11', 'O.SB.11 : Min. salicide block overlap with COMP. : 0.04µm')
  osb11_l1.forget

  # Rule O.SB.12 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_10.html

  # Rule O.SB.13_LV: Min. area of silicide block (um2). is 1.488µm²
  logger.info('Executing rule O.SB.13_LV')
  osb13_l1 = sab_otp.with_area(nil, 1.488.um).not_interacting(v5_xtor).not_interacting(dualgate)
  osb13_l1.output('O.SB.13_LV', 'O.SB.13_LV : Min. area of silicide block (um2). : 1.488µm²')
  osb13_l1.forget

  # Rule O.SB.13_MV: Min. area of silicide block (um2). is 2µm²
  logger.info('Executing rule O.SB.13_MV')
  osb13_l1 = sab_otp.and(v5_xtor).with_area(nil, 2.um)
  osb13_l1.output('O.SB.13_MV', 'O.SB.13_MV : Min. area of silicide block (um2). : 2µm²')
  osb13_l1.forget

  # Rule O.SB.15b is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_10_10.html

  # Rule O.CO.7: Min. space from COMP contact to Poly2 on COMP. is 0.13µm
  logger.info('Executing rule O.CO.7')
  oco7_l1 = contact.not_outside(comp_otp).separation(tgate.and(otp_mk), 0.13.um, euclidian)
  oco7_l1.output('O.CO.7', 'O.CO.7 : Min. space from COMP contact to Poly2 on COMP. : 0.13µm')
  oco7_l1.forget

  # Rule O.PL.ORT: Orientation-restricted gates must have the gate width
  ## aligned along the X-axis (poly line running horizontally)
  ## in reference to wafer notch down.
  logger.info('Executing rule O.PL.ORT')
  oplort_l1 = comp_otp.not(poly_otp).edges.and(tgate_edges).without_angle(0.um).not_interacting(v5_xtor)
  oplort_l1.output('O.PL.ORT', 'O.PL.ORT : Orientation-restricted gates must have the gate width
                    aligned along the X-axis (poly line running horizontally)
                    in reference to wafer notch down.')
  oplort_l1.forget
  tgate_edges.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #--------------------DUALGATE--------------------
  #================================================

  # Rule DV.1: Min. Dualgate enclose DNWELL. is 0.5µm
  logger.info('Executing rule DV.1')
  dv1_l1 = dualgate.enclosing(dnwell, 0.5.um, euclidian).polygons(0.001.um)
  dv1_l2 = dnwell.not_outside(dualgate).not(dualgate)
  dv1_l  = dv1_l1.or(dv1_l2)
  dv1_l.output('DV.1', 'DV.1 : Min. Dualgate enclose DNWELL. : 0.5µm')
  dv1_l1.forget
  dv1_l2.forget
  dv1_l.forget

  # Rule DV.2: Min. Dualgate Space. Merge if Space is less than this design rule. is 0.44µm
  logger.info('Executing rule DV.2')
  dv2_l1 = dualgate.space(0.44.um, euclidian)
  dv2_l1.output('DV.2', 'DV.2 : Min. Dualgate Space. Merge if Space is less than this design rule. : 0.44µm')
  dv2_l1.forget

  # Rule DV.3: Min. Dualgate to COMP space [unrelated]. is 0.24µm
  logger.info('Executing rule DV.3')
  dv3_l1 = dualgate.separation(comp.outside(dualgate), 0.24.um, euclidian)
  dv3_l1.output('DV.3', 'DV.3 : Min. Dualgate to COMP space [unrelated]. : 0.24µm')
  dv3_l1.forget

  # rule DV.4 is not a DRC check
  # Refer to: https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_07.html

  # Rule DV.5: Min. Dualgate width. is 0.7µm
  logger.info('Executing rule DV.5')
  dv5_l1 = dualgate.width(0.7.um, euclidian)
  dv5_l1.output('DV.5', 'DV.5 : Min. Dualgate width. : 0.7µm')
  dv5_l1.forget

  comp_dv = comp.not(pcomp.outside(nwell))
  # Rule DV.6: Min. Dualgate enclose COMP (except substrate tap). is 0.24µm
  logger.info('Executing rule DV.6')
  dv6_l1 = dualgate.enclosing(comp_dv, 0.24.um, euclidian).polygons(0.001.um)
  dv6_l2 = comp_dv.not_outside(dualgate).not(dualgate)
  dv6_l  = dv6_l1.or(dv6_l2)
  dv6_l.output('DV.6', 'DV.6 : Min. Dualgate enclose COMP (except substrate tap). : 0.24µm')
  dv6_l1.forget
  dv6_l2.forget
  dv6_l.forget

  # Rule DV.7: COMP (except substrate tap) can not be partially overlapped by Dualgate.
  logger.info('Executing rule DV.7')
  dv7_l1 = dualgate.not_outside(comp_dv).not(dualgate.covering(comp_dv))
  dv7_l1.output('DV.7', 'DV.7 : COMP (except substrate tap) can not be partially overlapped by Dualgate.')
  dv7_l1.forget

  comp_dv.forget

  # Rule DV.8: Min Dualgate enclose Poly2. is 0.4µm
  logger.info('Executing rule DV.8')
  dv8_l1 = dualgate.enclosing(poly2, 0.4.um, euclidian).polygons(0.001.um)
  dv8_l2 = poly2.not_outside(dualgate).not(dualgate)
  dv8_l  = dv8_l1.or(dv8_l2)
  dv8_l.output('DV.8', 'DV.8 : Min Dualgate enclose Poly2. : 0.4µm')
  dv8_l1.forget
  dv8_l2.forget
  dv8_l.forget

  # Rule DV.9: 3.3V and 5V/6V PMOS cannot be sitting inside same NWELL.
  logger.info('Executing rule DV.9')
  dv9_l1 = nwell.covering(pgate.and(dualgate)).covering(pgate.not_inside(v5_xtor).not_inside(dualgate))
  dv9_l1.output('DV.9', 'DV.9 : 3.3V and 5V/6V PMOS cannot be sitting inside same NWELL.')
  dv9_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #-----------------NATIVE VT NMOS-----------------
  #================================================

  logger.info('Starting NAT derivations')

  poly_nat = poly2.and(nat)
  poly_nat_lv = poly_nat.not_interacting(v5_xtor).not_interacting(dualgate)
  poly_nat_mv = poly_nat.overlapping(dualgate)

  # Rule NAT.1: Min. NAT Overlap of COMP of Native Vt NMOS. is 2µm
  logger.info('Executing rule NAT.1')
  nat1_l1 = ncomp.outside(nwell).interacting(nat).enclosed(nat, 2.um, euclidian)
  nat1_l1.output('NAT.1', 'NAT.1 : Min. NAT Overlap of COMP of Native Vt NMOS. : 2µm')
  nat1_l1.forget

  # Rule NAT.2: Space to unrelated COMP (outside NAT). is 0.3µm
  logger.info('Executing rule NAT.2')
  nat2_l1 = nat.separation(comp.outside(nat), 0.3.um, euclidian)
  nat2_l1.output('NAT.2', 'NAT.2 : Space to unrelated COMP (outside NAT). : 0.3µm')
  nat2_l1.forget

  # Rule NAT.3: Space to NWell edge. is 0.5µm
  logger.info('Executing rule NAT.3')
  nat3_l1 = nat.separation(nwell, 0.5.um, euclidian)
  nat3_l1.output('NAT.3', 'NAT.3 : Space to NWell edge. : 0.5µm')
  nat3_l1.forget

  # Rule NAT.4: Minimum channel length for 3.3V Native Vt NMOS
  ## (For smaller L Ioff will be higher than Spec). is 1.8µm
  logger.info('Executing rule NAT.4')
  nat4_l1 = poly_nat_lv.edges.and(ngate.edges).not(nwell).width(1.8.um, euclidian)
  nat4_l1.output('NAT.4', "NAT.4 : Minimum channel length for 3.3V Native Vt NMOS
                    (For smaller L Ioff will be higher than Spec). : 1.8µm")
  nat4_l1.forget
  poly_nat_lv.forget

  # Rule NAT.5: Minimum channel length for 6.0V Native Vt NMOS
  ## (For smaller L Ioff will be higher than Spec). is 1.8µm
  logger.info('Executing rule NAT.5')
  nat5_l1 = poly_nat_mv.edges.and(ngate.edges).not(nwell).width(1.8.um, euclidian)
  nat5_l1.output('NAT.5', "NAT.5 : Minimum channel length for 6.0V Native Vt NMOS
                    (For smaller L Ioff will be higher than Spec). : 1.8µm")
  nat5_l1.forget
  poly_nat_mv.forget

  if CONNECTIVITY_RULES
    logger.info('CONNECTIVITY_RULES section')
    _connected_nat, unconnected_nat = conn_space(natcomp, 10, 10, transparent)

    # Rule NAT.6: Two or more COMPs if connected to different potential
    ## are not allowed under same NAT layer.
    logger.info('Executing rule NAT.6')
    nat6_l1 = comp.and(nat).interacting(unconnected_nat.inside(nat.covering(comp, 2)).not(poly2))
    nat6_l1.output('NAT.6', "NAT.6 : Two or more COMPs if connected to different potential
                        are not allowed under same NAT layer.")
    nat6_l1.forget
  end
  natcomp.forget

  # Rule NAT.7: Minimum NAT to NAT spacing. is 0.74µm
  logger.info('Executing rule NAT.7')
  nat7_l1 = nat.space(0.74.um, euclidian)
  nat7_l1.output('NAT.7', 'NAT.7 : Minimum NAT to NAT spacing. : 0.74µm')
  nat7_l1.forget

  # Rule NAT.8: Min. Dualgate overlap of NAT (for 5V/6V) native VT NMOS only is 0um.
  logger.info('Executing rule NAT.8')
  nat8_l1 = nat.not_outside(dualgate).not(dualgate)
  nat8_l1.output('NAT.8', 'NAT.8 : Min. Dualgate overlap of NAT (for 5V/6V) native VT NMOS only: 0um')
  nat8_l1.forget

  # Rule NAT.9: Poly interconnect under NAT layer is not allowed,
  ## minimum spacing of un-related poly from the NAT layer is 0.3um
  logger.info('Executing rule NAT.9')
  nat9_a = poly2.and(nat).not(ncomp).interacting(ngate.and(nat), 2)
  nat9_b = poly2.not(nat).separation(nat, 0.3.um, euclidian).polygons(0.001.um)
  nat9_l1 = nat9_a.join(nat9_b)
  nat9_l1.output('NAT.9', "NAT.9 : Poly interconnect under NAT layer is not allowed,
                    minimum spacing of un-related poly from the NAT layer: 0.3um")
  nat9_l1.forget
  nat9_a.forget
  nat9_b.forget

  # Rule NAT.10: Nwell inside NAT layer are not allowed.
  logger.info('Executing rule NAT.10')
  nat10_l1 = nwell.and(nat)
  nat10_l1.output('NAT.10', 'NAT.10 : Nwell inside NAT layer are not allowed.')
  nat10_l1.forget

  # Rule NAT.11: NCOMP not intersecting to Poly2, is not allowed inside NAT layer.
  logger.info('Executing rule NAT.11')
  nat11_l1 = ncomp.and(nat).not_interacting(poly2)
  nat11_l1.output('NAT.11', 'NAT.11 : NCOMP not intersecting to Poly2, is not allowed inside NAT layer.')
  nat11_l1.forget

  # Rule NAT.12: Poly2 not intersecting with COMP is not allowed inside NAT
  ## (Poly2 resistor is not allowed inside NAT).
  logger.info('Executing rule NAT.12')
  nat12_l1 = poly_nat.not_interacting(comp).or(poly_nat.and(res_mk))
  nat12_l1.output('NAT.12', "NAT.12 : Poly2 not intersecting with COMP is not allowed inside NAT
                     (Poly2 resistor is not allowed inside NAT).")
  nat12_l1.forget
  poly_nat.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if BEOL && (METAL_TOP == '30K')

  #================================================
  #---------------- METALTOP 30K ------------------
  #================================================

  logger.info('MetalTop thickness 30K section')

  # Rule MT30.1a: Min. thick MetalTop width. is 1.8µm
  logger.info('Executing rule MT30.1a')
  mt301a_l1 = top_metal.width(1.8.um, euclidian)
  mt301a_l1.output('MT30.1a', 'MT30.1a : Min. thick MetalTop width. : 1.8µm')
  mt301a_l1.forget

  # Rule MT30.1b: Min width for >1000um long metal line (based on metal edge). is 2.2µm
  logger.info('Executing rule MT30.1b')
  long_edge = top_metal.edges.with_length(1000.um, nil)
  mt301b_l1 = top_metal.interacting(long_edge).width(2.2.um, euclidian)
  mt301b_l1.output('MT30.1b', 'MT30.1b : Min width for >1000um long metal line (based on metal edge). : 2.2µm')
  mt301b_l1.forget
  long_edge.forget

  # Rule MT30.2: Min. thick MetalTop space. is 1.8µm
  logger.info('Executing rule MT30.2')
  mt302_l1 = top_metal.space(1.8.um, euclidian)
  mt302_l1.output('MT30.2', 'MT30.2 : Min. thick MetalTop space. : 1.8µm')
  mt302_l1.forget

  # Rule MT30.3: The separation of two corners should satisfy the minimum spacing. is 1.8µm
  logger.info('Executing rule MT30.4')
  mt303_l1 = top_metal.space(1.8.um, euclidian)
  mt303_l1.output('MT30.3', 'MT30.3 : The separation of two corners should satisfy the minimum spacing. : 1.8µm')
  mt303_l1.forget

  # Rule MT30.4: The separation of single metal line from a any degree
  ## metal line should satisfy the minimum spacing is 1.8µm
  logger.info('Executing rule MT30.4')
  mt304_l1 = top_metal.space(1.8.um, euclidian)
  mt304_l1.output('MT30.4', "MT30.4 : The separation of single metal line from a any degree
                         metal line should satisfy the minimum spacing : 1.8µm")
  mt304_l1.forget

  # Rule MT30.5: Minimum thick MetalTop enclose underlying via
  ## (for example: via5 for 6LM case) [Outside Not Allowed] is 0.12um.
  logger.info('Executing rule MT30.5')
  mt305_l1 = top_via.enclosed(top_metal, 0.12.um, euclidian).polygons(0.001.um)
  mt305_l2 = top_via.not_inside(top_metal)
  mt305_l = mt305_l1.join(mt305_l2)
  mt305_l.output('MT30.5', "MT30.5 : Minimum thick MetalTop enclose underlying via
                       (for example: via5 for 6LM case) [Outside Not Allowed]: 0.12um")
  mt305_l.forget
  mt305_l1.forget
  mt305_l2.forget

  # Rule MT30.6: Thick MetalTop end-of-line (width <2.5um) enclose underlying via
  ## (for example: via5 for 6LM case) [Outside Not Allowed] is 0.25um.
  logger.info('Executing rule MT30.6')
  mt30p6_cond = top_metal.width(2.5.um)
  mt30p6_cond_edge1 = mt30p6_cond.first_edges
  mt30p6_cond_edge2 = mt30p6_cond.second_edges
  mt30p6_eol_allowed = top_metal.edges.with_length(nil, 2.5.um)
  mt30p6_eol = mt30p6_eol_allowed.interacting(mt30p6_cond_edge1).interacting(mt30p6_cond_edge2)
                                 .not(mt30p6_cond_edge1).not(mt30p6_cond_edge2)
  mt306_l1 = mt30p6_eol.enclosing(top_via.edges, 0.25.um, projection)
  mt306_l1.output('MT30.6', "MT30.6 : Thick MetalTop end-of-line (width <2.5um) enclose underlying via
                        (for example: via5 for 6LM case) [Outside Not Allowed]: 0.25um")
  mt306_l1.forget
  mt30p6_cond.forget
  mt30p6_eol.forget
  mt30p6_cond_edge1.forget
  mt30p6_cond_edge2.forget
  mt30p6_eol_allowed.forget

  # Rule MT30.8: There shall be minimum 2X2 array of vias
  ## (top vias) at one location connecting to 3um thick top metal.
  logger.info('Executing rule MT30.8')
  mt308_egde_length = 0.26 * 1 + 1 * 0.26
  top_via_not_seal_ring = top_via.not(guard_ring_mk)
  metal_top_intersections = top_metal.and(topmin1_metal).not(guard_ring_mk).interacting(top_via_not_seal_ring)
  mt308_l1 = metal_top_intersections.interacting(top_via_not_seal_ring, 1, 3)
  mt308_poss_l2 = metal_top_intersections.interacting(top_via_not_seal_ring, 4..nil)
  mt308_poss_via = top_via_not_seal_ring.interacting(mt308_poss_l2)
  mt308_poss_via_over_under = mt308_poss_via.sized(0.16, 'square_limit').merged.sized(-0.16, 'square_limit')
  mt308_all = mt308_poss_via_over_under.with_bbox_min(mt308_egde_length..nil)
  mt308_loc_exc = mt308_all.width(mt308_egde_length,
                                  projection_limits(mt308_egde_length..1000 * mt308_egde_length)).polygons
  mt308_loc = mt308_all.not_interacting(mt308_loc_exc)
  mt308_l2 = mt308_poss_l2.not_interacting(mt308_loc)
  mt308_l = mt308_l1.join(mt308_l2)
  mt308_l.output('MT30.8', 'MT30.8 : There shall be minimum 2X2 array of vias
                       (top vias) at one location connecting to 3um thick top metal.')
  top_via_not_seal_ring.forget
  metal_top_intersections.forget
  mt308_l1.forget
  mt308_poss_l2.forget
  mt308_poss_via.forget
  mt308_poss_via_over_under.forget
  mt308_all.forget
  mt308_loc_exc.forget
  mt308_loc.forget
  mt308_l2.forget
  mt308_l.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #--------------------LVS_BJT---------------------
  #================================================

  # Rule LVS_BJT.1: Minimum LVS_BJT enclosure of NPN or PNP Emitter COMP layers is 0um.
  logger.info('Executing rule LVS_BJT.1')
  vnpn_e = ncomp.interacting(lvs_bjt).inside(dnwell)
  vpnp_e = pcomp.interacting(lvs_bjt).inside(nwell)
  lvs_l1 = vnpn_e.join(vpnp_e).not(lvs_bjt)
  lvs_l1.output('LVS_BJT.1', 'LVS_BJT.1 : Minimum LVS_BJT enclosure of NPN or PNP Emitter COMP layers: 0um')
  lvs_l1.forget
  vnpn_e.forget
  vpnp_e.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL

  #================================================
  #-------------------3.3V SRAM--------------------
  #================================================

  logger.info('Starting 3.3V SRAM derivations')

  sram_lv = sramcore.not_interacting(v5_xtor).not_interacting(dualgate)
  nw_n_dn_sram = nwell_n_dn.and(sram_lv)
  poly_sram = poly2.and(sram_lv)
  comp_sram = comp.and(sram_lv)
  contact_sram = contact.and(sram_lv)
  metal1_sram = metal1.and(sram_lv)

  # Rule S.DF.4c_LV: Min. (Nwell overlap of PCOMP) outside DNWELL is 0.4µm.
  logger.info('Executing rule S.DF.4c_LV')
  pcomp_out_dn_sram = pcomp.outside(dnwell).and(sram_lv)
  sdf4c_l1 = pcomp_out_dn_sram.enclosed(nw_n_dn_sram, 0.4.um, euclidian).polygons(0.001.um)
  sdf4c_l2 = pcomp_out_dn_sram.not_outside(nw_n_dn_sram).not(nw_n_dn_sram)
  sdf4c_l  = sdf4c_l1.or(sdf4c_l2)
  sdf4c_l.output('S.DF.4c_LV', 'S.DF.4c_LV : Min. (Nwell overlap of PCOMP) outside DNWELL: 0.4µm')
  sdf4c_l1.forget
  sdf4c_l2.forget
  sdf4c_l.forget
  pcomp_out_dn_sram.forget

  # Rule S.DF.16_LV: Min. space from (Nwell outside DNWELL) to
  ## (NCOMP outside Nwell and DNWELL) is 0.4µm.
  logger.info('Executing rule S.DF.16_LV')
  sdf16_l1 = ncomp.outside(nwell).outside(dnwell).and(sram_lv).separation(nw_n_dn_sram, 0.4.um, euclidian)
  sdf16_l1.output('S.DF.16_LV', "S.DF.16_LV : Min. space from (Nwell outside DNWELL) to
                     (NCOMP outside Nwell and DNWELL): 0.4µm")
  sdf16_l1.forget
  nw_n_dn_sram.forget
  sram_lv.forget

  # Rule S.CO.3_LV: Poly2 overlap of contact is 0.04µm.
  logger.info('Executing rule S.CO.3_LV')
  sco3_l1 = contact_sram.enclosed(poly_sram, 0.04.um, euclidian).polygons(0.001.um)
  sco3_l2 = contact_sram.not_outside(poly_sram).not(poly_sram)
  sco3_l  = sco3_l1.or(sco3_l2)
  sco3_l.output('S.CO.3_LV', 'S.CO.3_LV : Poly2 overlap of contact: 0.04µm')
  sco3_l1.forget
  sco3_l2.forget
  sco3_l.forget
  poly_sram.forget

  # Rule S.CO.4_LV: COMP overlap of contact is 0.03µm.
  logger.info('Executing rule S.CO.4_LV')
  sco4_l1 = comp_sram.enclosing(contact_sram, 0.03.um, euclidian).polygons(0.001.um)
  sco4_l2 = contact_sram.not_outside(comp_sram).not(comp_sram)
  sco4_l  = sco4_l1.or(sco4_l2)
  sco4_l.output('S.CO.4_LV', 'S.CO.4_LV : COMP overlap of contact: 0.03µm')
  sco4_l1.forget
  sco4_l2.forget
  sco4_l.forget
  comp_sram.forget

  # Rule S.CO.6_ii_LV: (ii) If Metal1 overlaps contact
  ## by < 0.04um on one side, adjacent metal1 edges overlap is 0.02.um
  logger.info('Executing rule S.CO.6_ii_LV')
  s_co6_cond_edges = contact_sram.edges.not_outside(contact_sram.enclosed(metal1_sram, 0.02.um, projection).edges)
  s_co6_check_corner = s_co6_cond_edges.extended_in(0.002.um)
  s_co6_check = contact_sram.edges.interacting(s_co6_check_corner).not(s_co6_cond_edges)
  s_co6_cond_corner = s_co6_cond_edges.width(0.002.um, angle_limit(135)).polygons
  s_co6_l1 = s_co6_check.enclosed(metal1_sram.edges, 0.04.um, projection).polygons
  s_co6_l2 = contact_sram.interacting(s_co6_cond_corner)
  s_co6_l = s_co6_l1.or(s_co6_l2)
  s_co6_l.output('S.CO.6_ii_LV', 'S.CO.6_ii_LV : (ii) If Metal1 overlaps contact
                  by < 0.04um on one side, adjacent metal1 edges overlap: 0.02.um')
  s_co6_l.forget
  s_co6_l1.forget
  s_co6_l2.forget
  s_co6_cond_edges.forget
  s_co6_check_corner.forget
  s_co6_cond_corner.forget
  s_co6_check.forget
  contact_sram.forget

  # Rule S.M1.1_LV: min. metal1 width is 0.22µm
  logger.info('Executing rule S.M1.1_LV')
  sm11_l1 = metal1_sram.width(0.22.um, euclidian)
  sm11_l1.output('S.M1.1_LV', 'S.M1.1_LV : min. metal1 width : 0.22µm')
  sm11_l1.forget
  metal1_sram.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #----------------------COMP----------------------
  #================================================

  logger.info('Starting comp derivations')

  # Comp derivations
  comp_3p3v = comp.not_interacting(v5_xtor).not_interacting(dualgate)
  comp_56v = comp.overlapping(dualgate)

  ncomp_3p3v = nplus.and(comp_3p3v)
  ncomp_56v = nplus.and(comp_56v)

  pcomp_dn3p3v = pcomp.and(dnwell_3p3v)
  pcomp_dn56v = pcomp.and(dnwell_56v)

  ncomp_butted = ncomp.interacting(pcomp)

  ntap_dn3p3V = ntap_dn.and(dnwell_3p3v)
  ntap_dn56v = ntap_dn.and(dnwell_56v)

  nwell_n_dn3p3v = nwell_n_dn.not_interacting(v5_xtor).not_interacting(dualgate)
  nwell_n_dn56v = nwell_n_dn.overlapping(dualgate)

  ncomp_out_nw_dn = ncomp.not(nwell).not(dnwell)
  pcomp_out_nw_dn = pcomp.not(nwell).not(dnwell)

  # Rule DF.1a_LV: Min. COMP Width. is 0.22µm
  logger.info('Executing rule DF.1a_LV')
  df1a_l1 = comp_3p3v.width(0.22.um, euclidian)
  df1a_l1.output('DF.1a_LV', 'DF.1a_LV : Min. COMP Width. : 0.22µm')
  df1a_l1.forget

  # Rule DF.1a_MV: Min. COMP Width. is 0.3µm
  logger.info('Executing rule DF.1a_MV')
  df1a_l1 = comp_56v.not(mvsd.or(mvpsd)).width(0.3.um, euclidian)
  df1a_l1.output('DF.1a_MV', 'DF.1a_MV : Min. COMP Width. : 0.3µm')
  df1a_l1.forget

  # Rule DF.1b_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_06.html

  # Rule DF.1b_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_06.html

  # Rule DF.1c: Min. COMP Width for MOSCAP. is 1µm
  logger.info('Executing rule DF.1c')
  df1c_l1 = comp.and(mos_cap_mk).width(1.um, euclidian)
  df1c_l1.output('DF.1c', 'DF.1c : Min. COMP Width for MOSCAP. : 1µm')
  df1c_l1.forget

  # Rule DF.2a_LV: Min Channel Width. is 0.22µm
  logger.info('Executing rule DF.2a_LV')
  df_2a_3p3v = comp_3p3v.not(poly2).edges.and(tgate.edges)
  df2a_l1 = df_2a_3p3v.with_length(nil, 0.22.um)
  df2a_l1.output('DF.2a_LV', 'DF.2a_LV : Min Channel Width. : 0.22µm')
  df2a_l1.forget
  df_2a_3p3v.forget

  # Rule DF.2a_MV: Min Channel Width. is nil,0.3µm
  logger.info('Executing rule DF.2a_MV')
  df_2a_56v = comp_56v.not(poly2).edges.and(tgate.edges)
  df2a_l1 = df_2a_56v.with_length(nil, 0.3.um)
  df2a_l1.output('DF.2a_MV', 'DF.2a_MV : Min Channel Width. : nil,0.3µm')
  df2a_l1.forget
  df_2a_56v.forget

  # Rule DF.2b: Max. COMP width for all cases except those used for capacitors,
  ## marked by ‘MOS_CAP_MK’ layer. is 100um
  logger.info('Executing rule DF.2b')
  df2b_l1 = comp.not(mos_cap_mk).sized(-50.um).sized(50.um)
  df2b_l1.output('DF.2b',
                 "DF.2b : Max. COMP width for all cases except those used for capacitors,
                  marked by 'MOS_CAP_MK' layer: 100um")
  df2b_l1.forget

  # Rule DF.3a_LV:  Min. COMP Space : 0.28µm. [P-substrate tap (PCOMP outside NWELL and DNWELL)
  ## can be butted for different voltage devices as the potential is same]
  logger.info('Executing rule DF.3a_LV')
  df3a_l1 = comp_3p3v.not(otp_mk).space(0.28.um, euclidian)
  df3a_l1.output('DF.3a_LV',
                 'DF.3a_LV : Min. COMP Space is : 0.28µm. [P-substrate tap (PCOMP outside NWELL and DNWELL)
                  can be butted for different voltage devices as the potential is same]')
  df3a_l1.forget

  # Rule DF.3a_MV:  Min. COMP Space is : 0.36µm. [P-substrate tap (PCOMP outside NWELL and DNWELL)
  ## can be butted for different voltage devices as the potential is same]
  logger.info('Executing rule DF.3a_MV')
  df3a_l1 = comp_56v.not(otp_mk).space(0.36.um, euclidian)
  df3a_l1.output('DF.3a_MV',
                 'DF.3a_MV :  Min. COMP Space is : 0.36µm. [P-substrate tap (PCOMP outside NWELL and DNWELL)
                  can be butted for different voltage devices as the potential is same]')
  df3a_l1.forget

  # Rule DF.3b: Min./Max. NCOMP Space to PCOMP in the same well for butted COMP.
  ## (MOSCAP butting is not allowed). is 0 um
  logger.info('Executing rule DF.3b')
  df_3b_same_well = ntap.not_outside(pactive).or(ptap.not_outside(nactive))
  df_3b_moscap = ncomp_butted.and(mos_cap_mk)
  df3b_l1 = comp.and(df_3b_same_well.or(df_3b_moscap))
  df3b_l1.output('DF.3b',
                 'DF.3b : Min./Max. NCOMP Space to PCOMP in the same well for butted COMP
                  (MOSCAP butting is not allowed): 0 um')
  df3b_l1.forget

  # Rule DF.3c_LV: Min. COMP Space in BJT area (area marked by DRC_BJT layer). is 0.32µm
  logger.info('Executing rule DF.3c_LV')
  df3c_l1 = comp_3p3v.and(drc_bjt).space(0.32.um, euclidian)
  df3c_l1.output('DF.3c_LV', 'DF.3c_LV : Min. COMP Space in BJT area (area marked by DRC_BJT layer). : 0.32µm')
  df3c_l1.forget

  # Rule DF.3c_MV: Min. COMP Space in BJT area (area marked by DRC_BJT layer) hasn’t been assessed.
  logger.info('Executing rule DF.3c_MV')
  df3c_l1 = comp_56v.and(drc_bjt.interacting(comp_56v, 2))
  df3c_l1.output('DF.3c_MV',
                 "DF.3c_MV : Min. COMP Space in BJT area (area marked by DRC_BJT layer) hasn't been assessed.")
  df3c_l1.forget

  # Rule DF.4a_LV: Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. is 0.12µm
  logger.info('Executing rule DF.4a_LV')
  df4a_l1 = ntap_dn3p3V.separation(lvpwell_dn3p3v, 0.12.um, euclidian)
  df4a_l1.output('DF.4a_LV', 'DF.4a_LV : Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. : 0.12µm')
  df4a_l1.forget

  # Rule DF.4a_MV: Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. is 0.16µm
  logger.info('Executing rule DF.4a_MV')
  df4a_l1 = ntap_dn56v.separation(lvpwell_dn56v, 0.16.um, euclidian)
  df4a_l1.output('DF.4a_MV', 'DF.4a_MV : Min. (LVPWELL Space to NCOMP well tap) inside DNWELL. : 0.16µm')
  df4a_l1.forget

  # Rule DF.4b_LV: Min. DNWELL overlap of NCOMP well tap. is 0.62µm
  logger.info('Executing rule DF.4b_LV')
  df4b_l1 = ntap_dn3p3V.enclosed(dnwell_3p3v, 0.62.um, euclidian)
  df4b_l1.output('DF.4b_LV', 'DF.4b_LV : Min. DNWELL overlap of NCOMP well tap. : 0.62µm')
  df4b_l1.forget
  ntap_dn3p3V.forget

  # Rule DF.4b_MV: Min. DNWELL overlap of NCOMP well tap. is 0.66µm
  logger.info('Executing rule DF.4b_MV')
  df4b_l1 = ntap_dn56v.enclosed(dnwell_56v, 0.66.um, euclidian)
  df4b_l1.output('DF.4b_MV', 'DF.4b_MV : Min. DNWELL overlap of NCOMP well tap. : 0.66µm')
  df4b_l1.forget
  ntap_dn56v.forget

  # Rule DF.4c_LV: Min. (Nwell overlap of PCOMP) outside DNWELL. is 0.43µm
  logger.info('Executing rule DF.4c_LV')
  nw_n_dn_n_srm = nwell_n_dn.not(sramcore)
  nw_n_dn_n_srm3p3v = nw_n_dn_n_srm.not_interacting(v5_xtor).not_interacting(dualgate)
  df4c_pcomp3p3v = pcomp.and(nw_n_dn_n_srm3p3v)
  df4c_l1 = df4c_pcomp3p3v.enclosed(nw_n_dn_n_srm3p3v, 0.43.um, euclidian)
  df4c_l1.output('DF.4c_LV', 'DF.4c_LV : Min. (Nwell overlap of PCOMP) outside DNWELL. : 0.43µm')
  df4c_l1.forget
  nw_n_dn_n_srm3p3v.forget
  df4c_pcomp3p3v.forget

  # Rule DF.4c_MV: Min. (Nwell overlap of PCOMP) outside DNWELL. is 0.6µm
  logger.info('Executing rule DF.4c_MV')
  nw_n_dn_n_srm56v = nw_n_dn_n_srm.overlapping(dualgate)
  df4c_pcomp56v = pcomp.and(nw_n_dn_n_srm56v)
  df4c_l1 = df4c_pcomp56v.enclosed(nw_n_dn_n_srm, 0.6.um, euclidian)
  df4c_l1.output('DF.4c_MV', 'DF.4c_MV : Min. (Nwell overlap of PCOMP) outside DNWELL. : 0.6µm')
  df4c_l1.forget
  nw_n_dn_n_srm56v.forget
  nw_n_dn_n_srm.forget
  df4c_pcomp56v.forget

  # Rule DF.4d_LV: Min. (Nwell overlap of NCOMP) outside DNWELL. is 0.12µm
  logger.info('Executing rule DF.4d_LV')
  df_4d_nwell = nwell_n_dn.not(ymtp_mk).not(neo_ee_mk)
  df_4d_ncomp3p3v = ncomp_3p3v.and(df_4d_nwell)
  df4d_l1 = df_4d_ncomp3p3v.enclosed(df_4d_nwell, 0.12.um, euclidian)
  df4d_l1.output('DF.4d_LV', 'DF.4d_LV : Min. (Nwell overlap of NCOMP) outside DNWELL. : 0.12µm')
  df4d_l1.forget
  df_4d_ncomp3p3v.forget

  # Rule DF.4d_MV: Min. (Nwell overlap of NCOMP) outside DNWELL. is 0.16µm
  logger.info('Executing rule DF.4d_MV')
  df_4d_ncomp56v = ncomp_56v.and(df_4d_nwell)
  df4d_l1 = df_4d_ncomp56v.enclosed(df_4d_nwell, 0.16.um, euclidian)
  df4d_l1.output('DF.4d_MV', 'DF.4d_MV : Min. (Nwell overlap of NCOMP) outside DNWELL. : 0.16µm')
  df4d_l1.forget
  df_4d_ncomp56v.forget

  # Rule DF.4e_LV: Min. DNWELL overlap of PCOMP. is 0.93µm
  logger.info('Executing rule DF.4e_LV')
  df4e_l1 = pcomp_dn3p3v.enclosed(dnwell_3p3v, 0.93.um, euclidian)
  df4e_l1.output('DF.4e_LV', 'DF.4e_LV : Min. DNWELL overlap of PCOMP. : 0.93µm')
  df4e_l1.forget

  # Rule DF.4e_MV: Min. DNWELL overlap of PCOMP. is 1.1µm
  logger.info('Executing rule DF.4e_MV')
  df4e_l1 = pcomp_dn56v.enclosed(dnwell_56v, 1.1.um, euclidian)
  df4e_l1.output('DF.4e_MV', 'DF.4e_MV : Min. DNWELL overlap of PCOMP. : 1.1µm')
  df4e_l1.forget

  # Rule DF.5_LV: Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. is 0.12µm
  logger.info('Executing rule DF.5_LV')
  df5_l1 = ptap.and(lvpwell_dn3p3v).enclosed(lvpwell_dn3p3v, 0.12.um, euclidian)
  df5_l1.output('DF.5_LV', 'DF.5_LV : Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. : 0.12µm')
  df5_l1.forget

  # Rule DF.5_MV: Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. is 0.16µm
  logger.info('Executing rule DF.5_MV')
  df5_l1 = ptap.and(lvpwell_dn56v).enclosed(lvpwell_dn56v, 0.16.um, euclidian)
  df5_l1.output('DF.5_MV', 'DF.5_MV : Min. (LVPWELL overlap of PCOMP well tap) inside DNWELL. : 0.16µm')
  df5_l1.forget

  # Rule DF.6_LV: Min. COMP extend beyond gate (it also means source/drain overhang). is 0.24µm
  logger.info('Executing rule DF.6_LV')
  df6_exclude = otp_mk.or(ymtp_mk).or(sramcore).or(mvsd).or(mvpsd)
  df6_comp = comp.interacting(tgate).not(df6_exclude)
  df6_poly = poly2.not(df6_exclude)
  df6_l1 = df6_poly.enclosed(comp_3p3v.and(df6_comp), 0.24.um, euclidian)
  df6_l1.output('DF.6_LV', 'DF.6_LV : Min. COMP extend beyond gate (it also means source/drain overhang). : 0.24µm')
  df6_l1.forget

  # Rule DF.6_MV: Min. COMP extend beyond gate (it also means source/drain overhang). is 0.4µm
  logger.info('Executing rule DF.6_MV')
  df6_l1 = df6_poly.enclosed(comp_56v.and(df6_comp), 0.4.um, euclidian)
  df6_l1.output('DF.6_MV', 'DF.6_MV : Min. COMP extend beyond gate (it also means source/drain overhang). : 0.4µm')
  df6_l1.forget
  df6_exclude.forget
  df6_comp.forget
  df6_poly.forget

  # Rule DF.7_LV: Min. (LVPWELL Spacer to PCOMP) inside DNWELL. is 0.43µm
  logger.info('Executing rule DF.7_LV')
  df7_l1 = pcomp_dn3p3v.separation(lvpwell_dn3p3v, 0.43.um, euclidian)
  df7_l1.output('DF.7_LV', 'DF.7_LV : Min. (LVPWELL Spacer to PCOMP) inside DNWELL. : 0.43µm')
  df7_l1.forget
  pcomp_dn3p3v.forget

  # Rule DF.7_MV: Min. (LVPWELL Spacer to PCOMP) inside DNWELL. is 0.6µm
  logger.info('Executing rule DF.7_MV')
  df7_l1 = pcomp_dn56v.not(sramcore).separation(lvpwell_dn56v, 0.6.um, euclidian)
  df7_l1.output('DF.7_MV', 'DF.7_MV : Min. (LVPWELL Spacer to PCOMP) inside DNWELL. : 0.6µm')
  df7_l1.forget
  pcomp_dn56v.forget

  # Rule DF.8_LV: Min. (LVPWELL overlap of NCOMP) Inside DNWELL. is 0.43µm
  logger.info('Executing rule DF.8_LV')
  ncomp_dn3p3v = ncomp.and(dnwell_3p3v)
  df8_l1 = ncomp_dn3p3v.and(lvpwell_dn3p3v).enclosed(lvpwell_dn3p3v, 0.43.um, euclidian)
  df8_l1.output('DF.8_LV', 'DF.8_LV : Min. (LVPWELL overlap of NCOMP) Inside DNWELL. : 0.43µm')
  df8_l1.forget
  ncomp_dn3p3v.forget

  # Rule DF.8_MV: Min. (LVPWELL overlap of NCOMP) Inside DNWELL. is 0.6µm
  logger.info('Executing rule DF.8_MV')
  ncomp_dn56v = ncomp.and(dnwell_56v)
  df8_l1 = ncomp_dn56v.and(lvpwell_dn56v).not(sramcore).enclosed(lvpwell_dn56v, 0.6.um, euclidian)
  df8_l1.output('DF.8_MV', 'DF.8_MV : Min. (LVPWELL overlap of NCOMP) Inside DNWELL. : 0.6µm')
  df8_l1.forget
  ncomp_dn56v.forget

  # Rule DF.9: Min. COMP area (um2). is 0.2025µm²
  logger.info('Executing rule DF.9')
  df9_l1 = comp.not(otp_mk).with_area(nil, 0.2025.um)
  df9_l1.output('DF.9', 'DF.9 : Min. COMP area (um2). : 0.2025µm²')
  df9_l1.forget

  # Rule DF.10: Min. field area (um2). is 0.26µm²
  logger.info('Executing rule DF.10')
  df10_l1 = comp.holes.not(comp).with_area(nil, 0.26.um)
  df10_l1.output('DF.10', 'DF.10 : Min. field area (um2). : 0.26µm²')
  df10_l1.forget

  # Rule DF.11: Min. Length of butting COMP edge. is 0.3µm
  logger.info('Executing rule DF.11')
  df11_l1 = comp.interacting(ncomp_butted).width(0.3.um)
  df11_l1.output('DF.11', 'DF.11 : Min. Length of butting COMP edge. : 0.3µm')
  df11_l1.forget
  ncomp_butted.forget

  # Rule DF.12: COMP not covered by Nplus or Pplus is forbidden (except those COMP under marking).
  logger.info('Executing rule DF.12')
  df12_l1 = comp.not_interacting(schottky_diode).not(nplus).not(pplus)
  df12_l1.output('DF.12',
                 'DF.12 : COMP not covered by Nplus or Pplus is forbidden (except those COMP under marking).')
  df12_l1.forget

  # Rule DF.13_LV: Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell) is 20um.
  logger.info('Executing rule DF.13_LV')
  pactive_3p3v = pactive.not_interacting(v5_xtor).not_interacting(dualgate)
  df13_s_active = pactive_3p3v.sized(20.0.um, diamond_limit).and(nwell)
  df13_poss_bad_active = pactive_3p3v.interacting(df13_s_active.not_interacting(ntap))
  df13_poss_good_bad_active = df13_poss_bad_active.separation(ntap, 20.0.um).polygons
  df13_good_bad_active = df13_poss_good_bad_active.interacting(nwell, 1..1)
  df13_l1 = df13_poss_bad_active.not_interacting(df13_good_bad_active)
  df13_l1.output('DF.13_LV',
                 'DF.13_LV : Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell): 20um')
  df13_l1.forget
  df13_s_active.forget
  df13_poss_bad_active.forget
  df13_poss_good_bad_active.forget
  df13_good_bad_active.forget

  # Rule DF.13_MV: Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell) is 15um.
  logger.info('Executing rule DF.13_MV')
  pactive_56v = pactive.overlapping(dualgate)
  df13_s_active = pactive_56v.sized(15.0.um, diamond_limit).and(nwell)
  df13_poss_bad_active = pactive_56v.interacting(df13_s_active.not_interacting(ntap))
  df13_poss_good_bad_active = df13_poss_bad_active.separation(ntap, 15.0.um).polygons
  df13_good_bad_active = df13_poss_good_bad_active.interacting(nwell, 1..1)
  df13_l1 = df13_poss_bad_active.not_interacting(df13_good_bad_active)
  df13_l1.output('DF.13_MV',
                 'DF.13_MV : Max distance of Nwell tap (NCOMP inside Nwell) from (PCOMP inside Nwell): 20um')
  df13_l1.forget
  pactive_56v.forget
  df13_s_active.forget
  df13_poss_bad_active.forget
  df13_poss_good_bad_active.forget
  df13_good_bad_active.forget

  # Rule DF.14_LV: Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell) is 20um.
  logger.info('Executing rule DF.14_LV')
  nactive_3p3v = nactive.not_interacting(v5_xtor).not_interacting(dualgate)
  df14_s_active = nactive_3p3v.sized(20.0.um, diamond_limit).not(nwell)
  df14_poss_bad_active = nactive.interacting(df14_s_active.not_interacting(ptap))
  df14_good_active = df14_poss_bad_active.sep(ptap, 20.0.um).polygons
  df14_l1 = df14_poss_bad_active.not_interacting(df14_good_active)
  df14_l1.output('DF.14_LV',
                 'DF.14_LV : Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell): 20um')
  df14_l1.forget
  nactive_3p3v.forget
  df14_s_active.forget
  df14_poss_bad_active.forget
  df14_good_active.forget

  # Rule DF.14_MV: Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell) is 15um.
  logger.info('Executing rule DF.14_MV')
  nactive_56v = nactive.overlapping(dualgate)
  df14_s_active = nactive_56v.sized(15.0.um, diamond_limit).not(nwell)
  df14_poss_bad_active = nactive.interacting(df14_s_active.not_interacting(ptap))
  df14_good_active = df14_poss_bad_active.sep(ptap, 15.0.um).polygons
  df14_l1 = df14_poss_bad_active.not_interacting(df14_good_active)
  df14_l1.output('DF.14_MV',
                 'DF.14_MV : Max distance of substrate tap (PCOMP outside Nwell) from (NCOMP outside Nwell): 20um')
  df14_l1.forget
  nactive_56v.forget
  df14_s_active.forget
  df14_poss_bad_active.forget
  df14_good_active.forget

  # Rule DF.15a_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_06.html

  # Rule DF.15a_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_06.html

  # Rule DF.15b_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_06.html

  # Rule DF.15b_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_06.html

  # Rule DF.16_LV: Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). is 0.43µm
  logger.info('Executing rule DF.16_LV')
  df16_l1 = ncomp_out_nw_dn.interacting(ncomp_3p3v).not(ymtp_mk.or(sramcore)).separation(
    nwell_n_dn3p3v.not(ymtp_mk), 0.43.um, euclidian
  )
  df16_l1.output('DF.16_LV',
                 'DF.16_LV : Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). : 0.43µm')
  df16_l1.forget

  # Rule DF.16_MV: Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). is 0.6µm
  logger.info('Executing rule DF.16_MV')
  df16_l1 = ncomp_out_nw_dn.interacting(ncomp_56v).not_inside(ymtp_mk.or(sramcore)).separation(
    nwell_n_dn56v.not(ymtp_mk), 0.6.um, euclidian
  )
  df16_l1.output('DF.16_MV',
                 'DF.16_MV : Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). : 0.6µm')
  df16_l1.forget

  # Rule DF.17_LV: Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL) is 0.12µm.
  logger.info('Executing rule DF.17_LV')
  pcomp_3p3v = pplus.and(comp_3p3v)
  df17_l1 = pcomp_3p3v.and(pcomp_out_nw_dn).separation(nwell_n_dn3p3v, 0.12.um, euclidian)
  df17_l1.output('DF.17_LV',
                 'DF.17_LV : Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL). : 0.12µm')
  df17_l1.forget
  nwell_n_dn3p3v.forget
  pcomp_3p3v.forget

  # Rule DF.17_MV: Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL) is 0.16µm.
  logger.info('Executing rule DF.17_MV')
  pcomp_56v = pplus.and(comp_56v)
  df17_l1 = pcomp_56v.and(pcomp_out_nw_dn).separation(nwell_n_dn56v, 0.16.um, euclidian)
  df17_l1.output('DF.17_MV',
                 'DF.17_MV : Min. space from (Nwell Outside DNWELL) to (PCOMP outside Nwell and DNWELL). : 0.16µm')
  df17_l1.forget
  nwell_n_dn56v.forget
  pcomp_56v.forget

  # Rule DF.18: Min. DNWELL space to (PCOMP outside Nwell and DNWELL) is 2.5µm.
  logger.info('Executing rule DF.18')
  df18_l1 = pcomp_out_nw_dn.separation(dnwell, 2.5.um, euclidian)
  df18_l1.output('DF.18', 'DF.18 : Min. DNWELL space to (PCOMP outside Nwell and DNWELL). : 2.5µm')
  df18_l1.forget
  pcomp_out_nw_dn.forget

  # Rule DF.19_LV: Min. DNWELL space to (NCOMP outside Nwell and DNWELL) is 3.2µm.
  logger.info('Executing rule DF.19_LV')
  df19_l1 = ncomp_out_nw_dn.interacting(ncomp_3p3v).separation(dnwell, 3.2.um, euclidian)
  df19_l1.output('DF.19_LV', 'DF.19_LV : Min. DNWELL space to (NCOMP outside Nwell and DNWELL). : 3.2µm')
  df19_l1.forget
  ncomp_3p3v.forget

  # Rule DF.19_MV: Min. DNWELL space to (NCOMP outside Nwell and DNWELL) is 3.28µm.
  logger.info('Executing rule DF.19_MV')
  df19_l1 = ncomp_out_nw_dn.interacting(ncomp_56v).separation(dnwell, 3.28.um, euclidian)
  df19_l1.output('DF.19_MV', 'DF.19_MV : Min. DNWELL space to (NCOMP outside Nwell and DNWELL). : 3.28µm')
  df19_l1.forget
  ncomp_out_nw_dn.forget
  ncomp_56v.forget
  comp_3p3v.forget
  comp_56v.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #----------------------SAB-----------------------
  #================================================

  # sab derivations
  logger.info('Starting sab derivations')

  sab_out_otp = sab.outside(otp_mk)
  poly_sab = poly2.interacting(sab)
  comp_sab = comp.interacting(sab)
  sab_poly = sab.and(poly2)

  # Rule SB.1: min. sab width is 0.42µm
  logger.info('Executing rule SB.1')
  sb1_l1 = sab.width(0.42.um, euclidian)
  sb1_l1.output('SB.1', 'SB.1 : min. sab width : 0.42µm')
  sb1_l1.forget

  # Rule SB.2: min. sab spacing is 0.42µm
  logger.info('Executing rule SB.2')
  sb2_l1 = sab_out_otp.space(0.42.um, euclidian)
  sb2_l1.output('SB.2', 'SB.2 : min. sab spacing : 0.42µm')
  sb2_l1.forget

  # Rule SB.3: Space from salicide block to unrelated COMP. is 0.22µm
  logger.info('Executing rule SB.3')
  sb13_comp = comp.not_overlapping(sab_out_otp)
  sb3_l1 = sab_out_otp.separation(sb13_comp, 0.22.um, euclidian)
  sb3_l1.output('SB.3', 'SB.3 : Space from salicide block to unrelated COMP. : 0.22µm')
  sb3_l1.forget
  sb13_comp.forget

  # Rule SB.4: Space from salicide block to contact is 0.15 um.
  logger.info('Executing rule SB.4')
  sb4_l1 = sab_out_otp.separation(contact, 0.15.um, euclidian).polygons(0.001.um).or(sab_out_otp.and(contact))
  sb4_l1.output('SB.4', 'SB.4 : Space from salicide block to contact: 0.15 um')
  sb4_l1.forget

  # Rule SB.5a: Space from salicide block to unrelated Poly2 on field. is 0.3µm
  logger.info('Executing rule SB.5a')
  sb5a_poly = poly2.not(comp).not_overlapping(sab)
  sb5a_l1 = sab_out_otp.separation(sb5a_poly, 0.3.um, euclidian)
  sb5a_l1.output('SB.5a', 'SB.5a : Space from salicide block to unrelated Poly2 on field. : 0.3µm')
  sb5a_l1.forget
  sb5a_poly.forget

  # Rule SB.5b: Space from salicide block to unrelated Poly2 on COMP. is 0.28µm
  logger.info('Executing rule SB.5b')
  sb5b_l1 = sab_out_otp.separation(poly2.and(comp), 0.28.um, euclidian)
  sb5b_l1.output('SB.5b', 'SB.5b : Space from salicide block to unrelated Poly2 on COMP. : 0.28µm')
  sb5b_l1.forget

  # Rule SB.6: Salicide block extension beyond related COMP. is 0.22µm
  logger.info('Executing rule SB.6')
  sb6_l1 = comp_sab.enclosed(sab, 0.22.um, euclidian)
  sb6_l1.output('SB.6', 'SB.6 : Salicide block extension beyond related COMP. : 0.22µm')
  sb6_l1.forget

  # Rule SB.7: COMP extension beyond related salicide block. is 0.22µm
  logger.info('Executing rule SB.7')
  sb7_l1 = sab.enclosed(comp_sab, 0.22.um, euclidian).polygons
  sb7_l1.output('SB.7', 'SB.7 : COMP extension beyond related salicide block. : 0.22µm')
  sb7_l1.forget

  # Rule SB.8: Non-salicided contacts are forbidden.
  logger.info('Executing rule SB.8')
  sb8_l1 = contact.and(sab)
  sb8_l1.output('SB.8', 'SB.8 : Non-salicided contacts are forbidden.')
  sb8_l1.forget

  # Rule SB.9: Salicide block extension beyond unsalicided Poly2. is 0.22µm
  logger.info('Executing rule SB.9')
  sb9_l1 = poly_sab.enclosed(sab_out_otp, 0.22.um, euclidian).polygons
  sb9_l1.output('SB.9', 'SB.9 : Salicide block extension beyond unsalicided Poly2. : 0.22µm')
  sb9_l1.forget

  # Rule SB.10: Poly2 extension beyond related salicide block. is 0.22µm
  logger.info('Executing rule SB.10')
  sb10_l1 = sab.enclosed(poly_sab, 0.22.um, euclidian)
  sb10_l1.output('SB.10', 'SB.10 : Poly2 extension beyond related salicide block. : 0.22µm')
  sb10_l1.forget

  # Rule SB.11: Overlap with COMP. is 0.22µm
  logger.info('Executing rule SB.11')
  sb11_l1 = sab_out_otp.overlap(comp_sab, 0.22.um, euclidian).polygons
  sb11_l1.output('SB.11', 'SB.11 : Overlap with COMP. : 0.22µm')
  sb11_l1.forget
  comp_sab.forget

  # Rule SB.12: Overlap with Poly2 outside ESD_MK is 0.22µm.
  logger.info('Executing rule SB.12')
  sb12_l1 = sab_out_otp.outside(esd_mk).overlap(poly_sab, 0.22.um, euclidian).polygons
  sb12_l1.output('SB.12', 'SB.12 : Overlap with Poly2 outside ESD_MK : 0.22µm')
  sb12_l1.forget
  poly_sab.forget

  # Rule SB.13: Min. area (um2) is 2µm².
  logger.info('Executing rule SB.13')
  sb13_l1 = sab_out_otp.with_area(nil, 2.um)
  sb13_l1.output('SB.13', 'SB.13 : Min. area (um2) : 2µm²')
  sb13_l1.forget

  # Rule SB.14a: Space from unsalicided Nplus Poly2 to unsalicided Pplus Poly2.
  ## (Unsalicided Nplus Poly2 must not fall within a square of 0.56um x 0.56um
  ## at unsalicided Pplus Poly2 corners). is 0.56µm
  logger.info('Executing rule SB.14a')
  sb14a_butted_sab_poly = sab_poly.and(pplus).edges.inside(sab_poly.and(nplus).edges)
  sb14a_l1 = sab_poly.and(nplus).separation(sab_poly.and(pplus), 0.56.um,
                                            square).polygons(0.001.um).not_interacting(sb14a_butted_sab_poly)
  sb14a_l1.output('SB.14a', "SB.14a : Space from unsalicided Nplus Poly2 to unsalicided Pplus Poly2.
                    (Unsalicided Nplus Poly2 must not fall within a square of 0.56um x 0.56um
                    at unsalicided Pplus Poly2 corners). : 0.56µm")
  sb14a_l1.forget
  sb14a_butted_sab_poly.forget

  # Rule SB.14b: Space from unsalicided Nplus Poly2 to P-channel gate.
  ## (Unsalicided Nplus Poly2 must not fall within a square of 0.56um x 0.56um
  ## at P-channel gate corners). is 0.56µm
  logger.info('Executing rule SB.14b')
  sb14b_l1 = sab_poly.and(nplus).separation(pgate, 0.56.um, square)
  sb14b_l1.output('SB.14b', "SB.14b : Space from unsalicided Nplus Poly2 to P-channel gate.
                    (Unsalicided Nplus Poly2 must not fall within a square of 0.56um x 0.56um
                    at P-channel gate corners). : 0.56µm")
  sb14b_l1.forget

  # Rule SB.15a: Space from unsalicided Poly2 to unrelated Nplus/Pplus. is 0.18µm
  logger.info('Executing rule SB.15a')
  sb15a_np = nplus.or(pplus).not_overlapping(sab_poly)
  sb15a_l1 = sab_poly.separation(sb15a_np, 0.18.um, euclidian)
  sb15a_l1.output('SB.15a', 'SB.15a : Space from unsalicided Poly2 to unrelated Nplus/Pplus. : 0.18µm')
  sb15a_l1.forget
  sb15a_np.forget
  sab_poly.forget

  # Rule SB.15b: Space from unsalicided Poly2 to unrelated Nplus/Pplus along Poly2 line is 0.32 um
  logger.info('Executing rule SB.15b')
  sb15b_np = nplus.or(pplus).interacting(poly2.interacting(sab_out_otp))
  sb15b_poly = poly2.overlapping(sb15b_np).and(sab_out_otp)
  sb15b_l1 = sb15b_poly.separation(sb15b_np, 0.32.um, euclidian)
  sb15b_l1.output('SB.15b', 'SB.15b : Space from unsalicided Poly2 to unrelated Nplus/Pplus. : 0.32µm')
  sb15b_l1.forget
  sb15b_np.forget
  sb15b_poly.forget

  # Rule SB.16: SAB layer cannot exist on 3.3V and 5V/6V CMOS transistors'
  ## Poly and COMP area of the core circuit (Excluding the transistors used for ESD purpose).
  ## It can only exist on CMOS transistors marked by LVS_IO, OTP_MK, ESD_MK layers.
  logger.info('Executing rule SB.16')
  sb16_exclude = sab_out_otp.outside(lvs_io.or(esd_mk))
  sb16_l1 = sb16_exclude.interacting(tgate)
  sb16_l1.output('SB.16', "SB.16 : SAB layer cannot exist on 3.3V and 5V/6V CMOS transistors'
                    Poly and COMP area of the core circuit (Excluding the transistors used for ESD purpose).
                    It can only exist on CMOS transistors marked by LVS_IO, OTP_MK, ESD_MK layers.")
  sb16_l1.forget
  sb16_exclude.forget
  sab_out_otp.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if BEOL
  #================================================
  #----------------------via1----------------------
  #================================================

  # Rule V1.1: Min/max Via1 size . is 0.26µm
  logger.info('Executing rule V1.1')
  v11_l1 = via1.edges.without_length(0.26.um)
  v11_l1.output('V1.1', 'V1.1 : Min/max Via1 size . : 0.26µm')
  v11_l1.forget

  # Rule V1.2a: min. via1 spacing is 0.26µm
  logger.info('Executing rule V1.2a')
  v12a_l1 = via1.space(0.26.um, euclidian)
  v12a_l1.output('V1.2a', 'V1.2a : min. via1 spacing : 0.26µm')
  v12a_l1.forget

  # Rule V1.2b: Via1 Space in 4x4 or larger via1 array is 0.36µm
  logger.info('Executing rule V1.2b')
  via1_egde_length = 0.26 * 3 + 3 * 0.36
  poss_4_4_via1 = via1.sized(0.2, 'square_limit').merged.sized(-0.2, 'square_limit')
  via1_4x4_all = poss_4_4_via1.with_bbox_min(via1_egde_length..nil).interacting(via1, 16..nil)
  via1_4x4_loc_exc = via1_4x4_all.width(via1_egde_length,
                                        projection_limits(via1_egde_length..1000 * via1_egde_length)).polygons
  via1_4x4_loc = via1_4x4_all.not_interacting(via1_4x4_loc_exc)
  selected_via1 = via1.interacting(via1_4x4_loc)
  via1b_l1 = selected_via1.space(0.36.um, euclidian)
  via1b_l1.output('V1.2b', 'V1.2b : Via1 Space in 4x4 or larger via1 array : 0.36µm')
  via1b_l1.forget
  poss_4_4_via1.forget
  via1_4x4_all.forget
  via1_4x4_loc_exc.forget
  via1_4x4_loc.forget
  selected_via1.forget

  # Rule V1.3a: metal1 overlap of via1.
  logger.info('Executing rule V1.3a')
  v13a_l1 = via1.not(metal1)
  v13a_l1.output('V1.3a', 'V1.3a : metal1 overlap of via1 >= 0.0')
  v13a_l1.forget

  # Rule V1.3b is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V1.3c: metal1 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V1.3c')
  v1p3c_cond = metal1.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v1p3c_eol_allowed = metal1.edges.with_length(nil, 0.34.um)
  v1p3c_cond_edge1 = v1p3c_cond.first_edges
  v1p3c_cond_edge2 = v1p3c_cond.second_edges
  v1p3c_eol = v1p3c_eol_allowed.interacting(v1p3c_cond_edge1).interacting(v1p3c_cond_edge2)
                               .not(v1p3c_cond_edge1).not(v1p3c_cond_edge2)
  v1p3c_l1 = via1.edges.enclosed(v1p3c_eol, 0.06.um, projection)
  v1p3c_l1.output('V1.3c', 'V1.3c : metal1 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v1p3c_l1.forget
  v1p3c_cond.forget
  v1p3c_eol.forget
  v1p3c_cond_edge1.forget
  v1p3c_cond_edge2.forget

  # Rule V1.3d: If metal1 overlap via1 by < 0.04um on one side, adjacent metal1 edges overlap. : 0.06µm
  logger.info('Executing rule V1.3d')
  via1_3d_cond_edges = via1.edges.not_outside(via1.enclosed(metal1, 0.04.um, projection).edges)
  via1_3d_check_corner = via1_3d_cond_edges.extended_in(0.002.um)
  via1_3d_check = via1.edges.interacting(via1_3d_check_corner).not(via1_3d_cond_edges)
  via1_cond_corner = via1_3d_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via1_3d_l1 = via1_3d_check.enclosed(metal1.edges, 0.06.um, projection).polygons
  via1_3d_l2 = via1.interacting(via1_cond_corner)
  via1_3d_l = via1_3d_l1.or(via1_3d_l2)
  via1_3d_l.output('V1.3d',
                   'V1.3d : If metal1 overlap via1 by < 0.04um on one side, adjacent metal1 edges overlap. : 0.06µm')
  via1_3d_l.forget
  via1_3d_l2.forget
  via1_3d_l1.forget
  via1_3d_cond_edges.forget
  via1_3d_check_corner.forget
  via1_cond_corner.forget
  via1_3d_check.forget

  # Rule V1.3e is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V1.4a: metal2 overlap of via1.
  logger.info('Executing rule V1.4a')
  via1_4a_l1 = via1.enclosed(metal2, 0.01.um, euclidian).polygons(0.001.um)
  via1_4a_l2 = via1.not(metal2)
  via1_4a_l = via1_4a_l1.or(via1_4a_l2)
  via1_4a_l.output('V1.4a', 'V1.4a : metal2 overlap of via1 >= 0.01 um')
  via1_4a_l1.forget
  via1_4a_l2.forget
  via1_4a_l.forget

  # Rule V1.4b: metal2 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V1.4b')
  v1p4b_cond = metal2.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v1p4b_eol_allowed = metal2.edges.with_length(nil, 0.34.um)
  v1p4b_eol = v1p4b_eol_allowed.interacting(v1p4b_cond.first_edges).interacting(v1p4b_cond.second_edges)
                               .not(v1p4b_cond.first_edges).not(v1p4b_cond.second_edges)
  v1p4b_l1 = via1.edges.enclosed(v1p4b_eol, 0.06.um, projection)
  v1p4b_l1.output('V1.4b', 'V1.4p : metal2 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v1p4b_l1.forget
  v1p4b_cond.forget
  v1p4b_eol.forget
  v1p4b_eol_allowed.forget

  # Rule V1.4c: If metal2 overlap via1 by < 0.04um on one side, adjacent metal2 edges overlap. : 0.06µm
  logger.info('Executing rule V1.4c')
  via1_4c_cond_edges = via1.edges.not_outside(via1.enclosed(metal2, 0.04.um, projection).edges)
  via1_4c_check_corner = via1_4c_cond_edges.extended_in(0.002.um)
  via1_4c_check = via1.edges.interacting(via1_4c_check_corner).not(via1_4c_cond_edges)
  via1_4c_cond_corner = via1_4c_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via1_4c_l1 = via1_4c_check.enclosed(metal2.edges, 0.06.um, projection).polygons
  via1_4c_l2 = via1.interacting(via1_4c_cond_corner)
  via1_4c_l = via1_4c_l1.or(via1_4c_l2)
  via1_4c_l.output('V1.4c',
                   'V1.4c : If metal2 overlap via1 by < 0.04um on one side, adjacent metal2 edges overlap. : 0.06µm')
  via1_4c_l.forget
  via1_4c_l2.forget
  via1_4c_l1.forget
  via1_4c_cond_edges.forget
  via1_4c_check_corner.forget
  via1_4c_cond_corner.forget
  via1_4c_check.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #---------------------POLY2----------------------
  #================================================

  logger.info('Starting POLY2 derivations')

  poly2_lv = poly2.not_interacting(v5_xtor).not_interacting(dualgate)
  poly2_mv = poly2.overlapping(dualgate)
  poly_pl_lv = poly2_lv.not(otp_mk).not(ymtp_mk).not(mvsd).not(mvpsd)
  poly_pl_mv = poly2_mv.not(otp_mk).not(ymtp_mk).not(mvsd).not(mvpsd)

  # Rule PL.1_LV: Interconnect Width (outside PLFUSE) is 0.18µm.
  logger.info('Executing rule PL.1_LV')
  pl1_l1 = poly2_lv.outside(plfuse).not(ymtp_mk).width(0.18.um, euclidian)
  pl1_l1.output('PL.1_LV', 'PL.1_LV : Interconnect Width (outside PLFUSE). : 0.18µm')
  pl1_l1.forget

  # Rule PL.1_MV: Interconnect Width (outside PLFUSE) is 0.2µm.
  logger.info('Executing rule PL.1_MV')
  pl1_l1 = poly2_mv.outside(plfuse).not(ymtp_mk).width(0.2.um, euclidian)
  pl1_l1.output('PL.1_MV', 'PL.1_MV : Interconnect Width (outside PLFUSE). : 0.2µm')
  pl1_l1.forget

  # Rule PL.1a_LV: Interconnect Width (inside PLFUSE) is 0.18µm.
  logger.info('Executing rule PL.1a_LV')
  pl1a_l1 = poly2_lv.inside(plfuse).width(0.18.um, euclidian)
  pl1a_l1.output('PL.1a_LV', 'PL.1a_LV : Interconnect Width (inside PLFUSE). : 0.18µm')
  pl1a_l1.forget

  # Rule PL.1a_MV: Interconnect Width (inside PLFUSE) is 0.18µm.
  logger.info('Executing rule PL.1a_MV')
  pl1a_l1 = poly2_mv.inside(plfuse).width(0.18.um, euclidian)
  pl1a_l1.output('PL.1a_MV', 'PL.1a_MV : Interconnect Width (inside PLFUSE). : 0.18µm')
  pl1a_l1.forget
  poly2_mv.forget

  # Rule PL.2_LV: Gate Width (Channel Length) is 0.28µm.
  logger.info('Executing rule PL.2_LV')
  pl2_l1 = tgate.interacting(poly2_lv).not(otp_mk).not(ymtp_mk)
  pl2_l = pl2_l1.edges.inside_part(comp).width(0.28.um, euclidian)
  pl2_l.output('PL.2_LV', 'PL.2_LV : Gate Width (Channel Length). : 0.28µm')
  pl2_l.forget
  pl2_l1.forget
  poly2_lv.forget

  # Rule PL.2_MV: Gate Width (Channel Length).
  logger.info('Executing rule PL.2_MV')
  pl_2_MV_n = ngate_5V.edges.inside_part(comp).width(0.6.um, euclidian).polygons
  pl_2_MV_p = pgate_5V.edges.inside_part(comp).width(0.5.um, euclidian).polygons
  pl_2_6v_n = ngate_6V.edges.inside_part(comp).width(0.7.um, euclidian).polygons
  pl_2_6v_p = pgate_6V.edges.inside_part(comp).width(0.55.um, euclidian).polygons
  pl2_l1 = pl_2_MV_n.or(pl_2_MV_p).or(pl_2_6v_n.or(pl_2_6v_p))
  pl2_l1.output('PL.2_MV', 'PL.2_MV : Gate Width (Channel Length).')
  pl2_l1.forget
  pl_2_MV_n.forget
  pl_2_MV_p.forget
  pl_2_6v_n.forget
  pl_2_6v_p.forget

  # Rule PL.3a: Space on COMP/Field is 0.24µm.
  logger.info('Executing rule PL.3a')
  pl3a_l1 = tgate.or(poly2.not(comp)).not(otp_mk).space(0.24.um, euclidian)
  pl3a_l1.output('PL.3a', 'PL.3a : Space on COMP/Field: 0.24µm')
  pl3a_l1.forget

  # Rule PL.3b_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_08.html

  # Rule PL.3b_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_08.html

  # Rule PL.4_LV: Extension beyond COMP to form Poly2 end cap. is 0.22µm
  logger.info('Executing rule PL.4_LV')
  comp_pl = comp.not(otp_mk).not(ymtp_mk).not(mvsd).not(mvpsd)
  pl4_l1 = comp_pl.enclosed(poly_pl_lv, 0.22.um, euclidian)
  pl4_l1.output('PL.4_LV', 'PL.4_LV : Extension beyond COMP to form Poly2 end cap. : 0.22µm')
  pl4_l1.forget

  # Rule PL.4_MV: Extension beyond COMP to form Poly2 end cap. is 0.22µm
  logger.info('Executing rule PL.4_MV')
  pl4_l1 = comp_pl.enclosed(poly_pl_mv, 0.22.um, euclidian)
  pl4_l1.output('PL.4_MV', 'PL.4_MV : Extension beyond COMP to form Poly2 end cap. : 0.22µm')
  pl4_l1.forget

  # Rule PL.5a_LV: Space from field Poly2 to unrelated COMP Spacer from field Poly2 to Guard-ring. is 0.1µm
  logger.info('Executing rule PL.5a_LV')
  pl5a_l1 = poly_pl_lv.separation(comp_pl, 0.1.um, euclidian)
  pl5a_l1.output('PL.5a_LV',
                 'PL.5a_LV : Space from field Poly2 to unrelated COMP Spacer from field Poly2 to Guard-ring. : 0.1µm')
  pl5a_l1.forget

  # Rule PL.5a_MV: Space from field Poly2 to unrelated COMP Spacer from field Poly2 to Guard-ring. is 0.3µm
  logger.info('Executing rule PL.5a_MV')
  pl5a_l1 = poly_pl_mv.outside(sramcore).separation(comp_pl, 0.3.um, euclidian)
  pl5a_l1.output('PL.5a_MV',
                 'PL.5a_MV : Space from field Poly2 to unrelated COMP Spacer from field Poly2 to Guard-ring. : 0.3µm')
  pl5a_l1.forget

  # Rule PL.5b_LV: Space from field Poly2 to related COMP. is 0.1µm
  logger.info('Executing rule PL.5b_LV')
  pl5b_l1 = poly_pl_lv.separation(comp_pl, 0.1.um, euclidian)
  pl5b_l1.output('PL.5b_LV', 'PL.5b_LV : Space from field Poly2 to related COMP. : 0.1µm')
  pl5b_l1.forget

  # Rule PL.5b_MV: Space from field Poly2 to related COMP. is 0.3µm
  logger.info('Executing rule PL.5b_MV')
  pl5b_l1 = poly_pl_mv.outside(sramcore).separation(comp_pl, 0.3.um, euclidian)
  pl5b_l1.output('PL.5b_MV', 'PL.5b_MV : Space from field Poly2 to related COMP. : 0.3µm')
  pl5b_l1.forget
  poly_pl_lv.forget
  poly_pl_mv.forget
  comp_pl.forget

  # Rule PL.6: 90 degree bends on the COMP are not allowed.
  logger.info('Executing rule PL.6')
  pl6_l1 = poly2.corners(90.0).sized(0.1).or(poly2.corners(-90.0).sized(0.1)).not(ymtp_mk).inside(comp.not(ymtp_mk))
  pl6_l1.output('PL.6', 'PL.6 : 90 degree bends on the COMP are not allowed.')
  pl6_l1.forget

  # Rule PL.7_LV: 45 degree bent gate width is 0.3µm
  logger.info('Executing rule PL.7_LV')
  nom_e1 = nom_gate.edges.inside_part(comp).with_angle(25, 65)
  nom_e2 = nom_gate.edges.inside_part(comp).with_angle(-65, -25)
  pl7_edges_nom = nom_e1.or(nom_e2)
  pl7_l1 = pl7_edges_nom.width(0.3.um, euclidian)
  pl7_l1.output('PL.7_LV', 'PL.7_LV : 45 degree bent gate width : 0.3µm')
  pl7_l1.forget
  nom_e1.forget
  nom_e2.forget
  pl7_edges_nom.forget

  # Rule PL.7_MV: 45 degree bent gate width is 0.7µm.
  logger.info('Executing rule PL.7_MV')
  thick_e1 = thick_gate.edges.inside_part(comp).with_angle(25, 65)
  thick_e2 = thick_gate.edges.inside_part(comp).with_angle(-65, -25)
  pl7_edges_thick = thick_e1.or(thick_e2)
  pl7_l2 = pl7_edges_thick.width(0.7.um, euclidian)
  pl7_l2.output('PL.7_MV', 'PL.7_MV : 45 degree bent gate width: 0.7µm')
  pl7_l2.forget
  thick_e1.forget
  thick_e2.forget
  pl7_edges_thick.forget

  # Rule PL.9: Poly2 inter connect connecting 3.3V and 5V areas (area inside and outside Dualgate)
  ## are not allowed. They shall be done though metal lines only.
  logger.info('Executing rule PL.9')
  pl9_l1 = poly2.interacting(poly2.not(v5_xtor).not(dualgate)).interacting(poly2.and(dualgate))
  pl9_l1.output('PL.9',
                'PL.9 : Poly2 inter connect connecting 3.3V and 5V areas (area inside and outside Dualgate)
                 are not allowed. They shall be done though metal lines only.')
  pl9_l1.forget

  # Rule PL.10 is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_08.html

  # Rule PL.11: V5_Xtor must enclose 5V device.
  logger.info('Executing rule PL.11')
  pl11_l1 = v5_xtor.not_interacting(dualgate.or(otp_mk))
  pl11_l1.output('PL.11', 'PL.11 : V5_Xtor must enclose 5V device.')
  pl11_l1.forget

  # Rule PL.12_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_08.html

  # Rule PL.12: V5_Xtor enclose 5V Comp.
  logger.info('Executing rule PL.12')
  pl12_l1 = comp.interacting(v5_xtor).not(v5_xtor)
  pl12_l1.output('PL.12', 'PL.12 : V5_Xtor enclose 5V Comp.')
  pl12_l1.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

# Metalstack
if BEOL && (METAL_LEVEL == '3LM' || METAL_LEVEL == '4LM' || METAL_LEVEL == '5LM' || METAL_LEVEL == '6LM')
  #================================================
  #----------------------via2----------------------
  #================================================

  # Rule V2.1: Min/max Via1 size . is 0.26µm
  logger.info('Executing rule V2.1')
  v21_l1 = via2.edges.without_length(0.26.um)
  v21_l1.output('V2.1', 'V2.1 : Min/max Via1 size . : 0.26µm')
  v21_l1.forget

  # Rule V2.2a: min. via2 spacing is 0.26µm
  logger.info('Executing rule V2.2a')
  v22a_l1 = via2.space(0.26.um, euclidian)
  v22a_l1.output('V2.2a', 'V2.2a : min. via2 spacing : 0.26µm')
  v22a_l1.forget

  # Rule V2.2b: Via2 Space in 4x4 or larger via2 array is 0.36µm
  logger.info('Executing rule V2.2b')
  via2_egde_length = 0.26 * 3 + 3 * 0.36
  poss_4_4_via2 = via2.sized(0.2, 'square_limit').merged.sized(-0.2, 'square_limit')
  via2_4x4_all = poss_4_4_via2.with_bbox_min(via2_egde_length..nil).interacting(via2, 16..nil)
  via2_4x4_loc_exc = via2_4x4_all.width(via2_egde_length,
                                        projection_limits(via2_egde_length..1000 * via2_egde_length)).polygons
  via2_4x4_loc = via2_4x4_all.not_interacting(via2_4x4_loc_exc)
  selected_via2 = via2.interacting(via2_4x4_loc)
  via2b_l1 = selected_via2.space(0.36.um, euclidian)
  via2b_l1.output('V2.2b', 'V2.2b : via2 Space in 4x4 or larger via2 array : 0.36µm')
  via2b_l1.forget
  poss_4_4_via2.forget
  via2_4x4_all.forget
  via2_4x4_loc_exc.forget
  via2_4x4_loc.forget
  selected_via2.forget

  # Rule V2.3a is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V2.3b: metal2 overlap of via2.
  logger.info('Executing rule V2.3b')
  v23b_l1 = via2.not(metal2)
  v23b_l2 = via2.enclosed(metal2, 0.01.um, euclidian).polygons(0.001.um)
  v23b_l = v23b_l1.or(v23b_l2)
  v23b_l.output('V2.3b', 'V2.3b : metal2 overlap of via2 >= 0.01')
  v23b_l1.forget
  v23b_l2.forget
  v23b_l.forget

  # Rule V2.3c: metal2 (< 0.34um) end-of-line overlap.(Applies to all < 0.34µm wide Metal lines,
  ##  excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V2.3c')
  v2p3c_cond = metal2.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v2p3c_eol_allowed = metal2.edges.with_length(nil, 0.34.um)
  v2p3c_cond_edge1 = v2p3c_cond.first_edges
  v2p3c_cond_edge2 = v2p3c_cond.second_edges
  v2p3c_eol = v2p3c_eol_allowed.interacting(v2p3c_cond_edge1).interacting(v2p3c_cond_edge2)
                               .not(v2p3c_cond_edge1).not(v2p3c_cond_edge2)
  v2p3c_l1 = via2.edges.enclosed(v2p3c_eol, 0.06.um, projection)
  v2p3c_l1.output('V2.3c', 'V2.3c : metal2 (< 0.34um) end-of-line overlap.(Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v2p3c_l1.forget
  v2p3c_cond.forget
  v2p3c_eol.forget
  v2p3c_eol_allowed.forget
  v2p3c_cond_edge1.forget
  v2p3c_cond_edge2.forget

  # Rule V2.3d: If metal2 overlap via2 by < 0.04um on one side, adjacent metal2 edges overlap. : 0.06µm
  logger.info('Executing rule V2.3d')
  via2_3d_cond_edges = via2.edges.not_outside(via2.enclosed(metal2, 0.04.um, projection).edges)
  via2_3d_check_corner = via2_3d_cond_edges.extended_in(0.002.um)
  via2_3d_check = via2.edges.interacting(via2_3d_check_corner).not(via2_3d_cond_edges)
  via2_cond_corner = via2_3d_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via2_3d_l1 = via2_3d_check.enclosed(metal2.edges, 0.06.um, projection).polygons
  via2_3d_l2 = via2.interacting(via2_cond_corner)
  via2_3d_l = via2_3d_l1.or(via2_3d_l2)
  via2_3d_l.output('V2.3d',
                   'V2.3d : If metal2 overlap via2 by < 0.04um on one side, adjacent metal2 edges overlap. : 0.06µm')
  via2_3d_l.forget
  via2_3d_l2.forget
  via2_3d_l1.forget
  via2_3d_cond_edges.forget
  via2_3d_check_corner.forget
  via2_cond_corner.forget
  via2_3d_check.forget

  # Rule V2.3e is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V2.4a: metal3 overlap of via2.
  logger.info('Executing rule V2.4a')
  via2_4a_l1 = via2.enclosed(metal3, 0.01.um, euclidian).polygons(0.001.um)
  via2_4a_l2 = via2.not(metal3)
  via2_4a_l = via2_4a_l1.or(via2_4a_l2)
  via2_4a_l.output('V2.4a', 'V2.4a : metal3 overlap of via2 >= 0.01 um')
  via2_4a_l1.forget
  via2_4a_l2.forget
  via2_4a_l.forget

  # Rule V2.4b: metal3 (< 0.34um) end-of-line overlap. is 0.06µm
  logger.info('Executing rule V2.4b')
  v2p4b_cond = metal3.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v2p4b_eol_allowed = metal3.edges.with_length(nil, 0.34.um)
  v2p4b_eol = v2p4b_eol_allowed.interacting(v2p4b_cond.first_edges).interacting(v2p4b_cond.second_edges)
                               .not(v2p4b_cond.first_edges).not(v2p4b_cond.second_edges)
  v2p4b_l1 = via2.edges.enclosed(v2p4b_eol, 0.06.um, projection)
  v2p4b_l1.output('V2.4b', 'V2.4p : metal3 (< 0.34um) end-of-line overlap. : 0.06µm')
  v2p4b_l1.forget
  v2p4b_cond.forget
  v2p4b_eol.forget
  v2p4b_eol_allowed.forget

  # Rule V2.4c: If metal3 overlap via2 by < 0.04um on one side, adjacent metal3 edges overlap. : 0.06µm
  logger.info('Executing rule V2.4c')
  via2_4c_cond_edges = via2.edges.not_outside(via2.enclosed(metal3, 0.04.um, projection).edges)
  via2_4c_check_corner = via2_4c_cond_edges.extended_in(0.002.um)
  via2_4c_check = via2.edges.interacting(via2_4c_check_corner).not(via2_4c_cond_edges)
  via2_4c_cond_corner = via2_4c_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via2_4c_l1 = via2_4c_check.enclosed(metal3.edges, 0.06.um, projection).polygons
  via2_4c_l2 = via2.interacting(via2_4c_cond_corner)
  via2_4c_l = via2_4c_l1.or(via2_4c_l2)
  via2_4c_l.output('V2.4c',
                   'V2.4c : If metal3 overlap via2 by < 0.04um on one side, adjacent metal3 edges overlap. : 0.06µm')
  via2_4c_l.forget
  via2_4c_l2.forget
  via2_4c_l1.forget
  via2_4c_cond_edges.forget
  via2_4c_check_corner.forget
  via2_4c_cond_corner.forget
  via2_4c_check.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if BEOL
  #================================================
  #---------------------METAL1---------------------
  #================================================

  # Rule M1.1: min. metal1 width is 0.23µm
  logger.info('Executing rule M1.1')
  m11_l1 = metal1.not(sramcore).width(0.23.um, euclidian)
  m11_l1.output('M1.1', 'M1.1 : min. metal1 width : 0.23µm')
  m11_l1.forget

  # Rule M1.2a: min. metal1 spacing is 0.23µm
  logger.info('Executing rule M1.2a')
  m12a_l1 = metal1.space(0.23.um, euclidian)
  m12a_l1.output('M1.2a', 'M1.2a : min. metal1 spacing : 0.23µm')
  m12a_l1.forget

  # Rule M1.2b: Space to wide Metal1 (length & width > 10um) is 0.3µm
  logger.info('Executing rule M1.2b')
  wide_m1 = metal1.not_interacting(metal1.edges.with_length(nil, 10.um))
  m12b_l1 = metal1.separation(wide_m1, 0.3.um, euclidian)
  m12b_l1.output('M1.2b', 'M1.2b : Space to wide Metal1 (length & width > 10um) : 0.3µm')
  m12b_l1.forget
  wide_m1.forget

  # Rule M1.3: Minimum Metal1 area is 0.1444µm²
  logger.info('Executing rule M1.3')
  m13_l1 = metal1.with_area(nil, 0.1444.um)
  m13_l1.output('M1.3', 'M1.3 : Minimum Metal1 area : 0.1444µm²')
  m13_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #----------------------ESD-----------------------
  #================================================

  logger.info('Starting ESD derivations')

  esd_edges = esd.edges
  tgate_edges = tgate.edges

  # Rule ESD.1: Minimum width of an ESD implant area. is 0.6µm
  logger.info('Executing rule ESD.1')
  esd1_l1 = esd.width(0.6.um, euclidian)
  esd1_l1.output('ESD.1', 'ESD.1 : Minimum width of an ESD implant area. : 0.6µm')
  esd1_l1.forget

  # Rule ESD.2: Minimum space between two ESD implant areas.
  ## (Merge if the space is less than 0.6um). is 0.6µm
  logger.info('Executing rule ESD.2')
  esd2_l1 = esd.space(0.6.um, euclidian)
  esd2_l1.output('ESD.2', 'ESD.2 : Minimum space between two ESD implant areas.
                 (Merge if the space is less than 0.6um). : 0.6µm')
  esd2_l1.forget

  # Rule ESD.3a: Minimum space to NCOMP. is 0.6µm
  logger.info('Executing rule ESD.3a')
  esd3a_l1 = esd.separation(ncomp, 0.6.um, euclidian)
  esd3a_l1.output('ESD.3a', 'ESD.3a : Minimum space to NCOMP. : 0.6µm')
  esd3a_l1.forget

  # Rule ESD.3b: Min/max space to a butted PCOMP.
  logger.info('Executing rule ESD.3b')
  esd3b_l1 = esd.not_outside(pcomp)
  esd3b_l1.output('ESD.3b', 'ESD.3b : Min/max space to a butted PCOMP.')
  esd3b_l1.forget

  # Rule ESD.4a: Extension beyond NCOMP. is 0.24µm
  logger.info('Executing rule ESD.4a')
  esd4a_l1 = ncomp.edges.enclosed(esd_edges.not_interacting(pcomp), 0.24.um, euclidian)
  esd4a_l1.output('ESD.4a', 'ESD.4a : Extension beyond NCOMP. : 0.24µm')
  esd4a_l1.forget

  # Rule ESD.4b: Minimum overlap of an ESD implant edge to a COMP. is 0.45µm
  logger.info('Executing rule ESD.4b')
  esd4b_l1 = esd.overlap(comp, 0.45.um, euclidian)
  esd4b_l1.output('ESD.4b', 'ESD.4b : Minimum overlap of an ESD implant edge to a COMP. : 0.45µm')
  esd4b_l1.forget

  # Rule ESD.5a: Minimum ESD area (um2). is 0.49µm²
  logger.info('Executing rule ESD.5a')
  esd5a_l1 = esd.with_area(nil, 0.49.um)
  esd5a_l1.output('ESD.5a', 'ESD.5a : Minimum ESD area (um2). : 0.49µm²')
  esd5a_l1.forget

  # Rule ESD.5b: Minimum field area enclosed by ESD implant (um2). is 0.49µm²
  logger.info('Executing rule ESD.5b')
  esd5b_l1 = esd.holes.with_area(nil, 0.49.um)
  esd5b_l1.output('ESD.5b', 'ESD.5b : Minimum field area enclosed by ESD implant (um2). : 0.49µm²')
  esd5b_l1.forget

  # Rule ESD.6: Extension perpendicular to Poly2 gate. is 0.45µm
  logger.info('Executing rule ESD.6')
  esd6_l1 = esd_edges.enclosing(poly2.edges.interacting(tgate_edges), 0.45.um, projection)
  esd6_l1.output('ESD.6', 'ESD.6 : Extension perpendicular to Poly2 gate. : 0.45µm')
  esd6_l1.forget
  esd_edges.forget

  # Rule ESD.7: No ESD implant inside PCOMP.
  logger.info('Executing rule ESD.7')
  esd7_l1 = esd.not_outside(pcomp)
  esd7_l1.output('ESD.7', 'ESD.7 : No ESD implant inside PCOMP.')
  esd7_l1.forget

  # Rule ESD.8: Minimum space to Nplus/Pplus. is 0.3µm
  logger.info('Executing rule ESD.8')
  esd8_l1 = esd.separation(nplus.or(pplus), 0.3.um).polygons
  esd8_l1.output('ESD.8', 'ESD.8 : Minimum space to Nplus/Pplus. : 0.3µm')
  esd8_l1.forget

  # Rule ESD.pl: Minimum gate length of 5V/6V gate NMOS. is 0.8µm
  logger.info('Executing rule ESD.pl')
  esdpl_l1 = poly2.overlapping(dualgate).interacting(esd).edges.and(tgate_edges)
  esdpl_l  = esdpl_l1.width(0.8.um, euclidian)
  esdpl_l.output('ESD.pl', 'ESD.pl : Minimum gate length of 5V/6V gate NMOS. : 0.8µm')
  esdpl_l1.forget
  esdpl_l1.forget
  tgate_edges.forget

  # Rule ESD.9: ESD implant layer must be overlapped by Dualgate layer
  ## (as ESD implant option is only for 5V/6V devices).
  logger.info('Executing rule ESD.9')
  esd9_l1 = esd.not_overlapping(dualgate)
  esd9_l1.output('ESD.9', 'ESD.9 : ESD implant layer must be overlapped by Dualgate layer
                  (as ESD implant option is only for 5V/6V devices).')
  esd9_l1.forget

  # Rule ESD.10: LVS_IO shall be drawn covering I/O MOS active area by minimum overlap.
  logger.info('Executing rule ESD.10')
  esd10_l1 = comp.and(esd).not_outside(lvs_io).not(lvs_io)
  esd10_l1.output('ESD.10', 'ESD.10 : LVS_IO shall be drawn covering I/O MOS active area by minimum overlap.')
  esd10_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if BEOL && (METAL_LEVEL == '3LM' || METAL_LEVEL == '4LM' || METAL_LEVEL == '5LM' || METAL_LEVEL == '6LM')
  #================================================
  #---------------------METAL2---------------------
  #================================================

  # Rule M2.1: min. metal2 width is 0.28µm
  logger.info('Executing rule M2.1')
  m21_l1 = metal2.width(0.28.um, euclidian)
  m21_l1.output('M2.1', 'M2.1 : min. metal2 width : 0.28µm')
  m21_l1.forget

  # Rule M2.2a: min. metal2 spacing is 0.28µm
  logger.info('Executing rule M2.2a')
  m22a_l1 = metal2.space(0.28.um, euclidian)
  m22a_l1.output('M2.2a', 'M2.2a : min. metal2 spacing : 0.28µm')
  m22a_l1.forget

  # Rule M2.2b: Space to wide Metal2 (length & width > 10um) is 0.3µm
  logger.info('Executing rule M2.2b')
  wide_m2 = metal2.not_interacting(metal2.edges.with_length(nil, 10.um))
  m22b_l1 = metal2.separation(wide_m2, 0.3.um, euclidian)
  m22b_l1.output('M2.2b', 'M2.2b : Space to wide Metal2 (length & width > 10um) : 0.3µm')
  m22b_l1.forget
  wide_m2.forget

  # Rule M2.3: Minimum metal2 area is 0.1444µm²
  logger.info('Executing rule M2.3')
  m23_l1 = metal2.with_area(nil, 0.1444.um)
  m23_l1.output('M2.3', 'M2.3 : Minimum metal2 area : 0.1444µm²')
  m23_l1.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #---------------------NWELL----------------------
  #================================================

  logger.info('Starting NWELL derivations')

  nw_lv = nwell.not_interacting(v5_xtor).not_interacting(dualgate)
  nw_mv = nwell.overlapping(dualgate)

  # Rule NW.1a_LV: Min. Nwell Width (This is only for litho purpose on the generated area) is 0.86µm.
  logger.info('Executing rule NW.1a_LV')
  nw1a_l1 = nw_lv.width(0.86.um, euclidian)
  nw1a_l1.output('NW.1a_LV',
                 'NW.1a_LV : Min. Nwell Width (This is only for litho purpose on the generated area): 0.86µm')
  nw1a_l1.forget

  # Rule NW.1a_MV: Min. Nwell Width (This is only for litho purpose on the generated area) is 0.86µm.
  logger.info('Executing rule NW.1a_MV')
  nw1a_l1 = nw_mv.width(0.86.um, euclidian)
  nw1a_l1.output('NW.1a_MV',
                 'NW.1a_MV : Min. Nwell Width (This is only for litho purpose on the generated area): 0.86µm')
  nw1a_l1.forget

  # Rule NW.1b_LV: Min. Nwell Width as a resistor (Outside DNWELL only) is 2µm.
  logger.info('Executing rule NW.1b_LV')
  nw_res_mk = res_mk.interacting(nwell).not_inside(nwell)
  nw_1b_lv = nw_lv.outside(dnwell).and(nw_res_mk)
  nw1b_l1  = nw_1b_lv.width(2.um, euclidian)
  nw1b_l1.output('NW.1b_LV', 'NW.1b_LV : Min. Nwell Width as a resistor (Outside DNWELL only): 2µm')
  nw1b_l1.forget
  nw_1b_lv.forget

  # Rule NW.1b_MV: Min. Nwell Width as a resistor (Outside DNWELL only) is 2µm.
  logger.info('Executing rule NW.1b_MV')
  nw_1b_mv = nw_mv.outside(dnwell).and(nw_res_mk)
  nw1b_l1  = nw_1b_mv.width(2.um, euclidian)
  nw1b_l1.output('NW.1b_MV', 'NW.1b_MV : Min. Nwell Width as a resistor (Outside DNWELL only): 2µm')
  nw1b_l1.forget
  nw_1b_mv.forget

  if CONNECTIVITY_RULES
    logger.info('CONNECTIVITY_RULES section')

    connected_nwell_3p3v, unconnected_nwell_3p3v = conn_space(nwell, 0.6, 1.4, euclidian)
    connected_nwell_5p0v, unconnected_nwell_5p0v = conn_space(nwell, 0.74, 1.7, euclidian)

    # Rule NW.2a_LV: Min. Nwell Space (Outside DNWELL) [Equi-potential],
    ## Merge if the space is less than is 0.6µm.
    logger.info('Executing rule NW.2a_LV')
    nw2a_l1 = connected_nwell_3p3v.not_inside(ymtp_mk).not_interacting(v5_xtor).not_interacting(dualgate)
    nw2a_l1.output('NW.2a_LV',
                   'NW.2a_LV : Min. Nwell Space (Outside DNWELL) [Equi-potential],
                    Merge if the space is less than. : 0.6µm')
    nw2a_l1.forget

    # Rule NW.2a_MV: Min. Nwell Space (Outside DNWELL) [Equi-potential],
    ## Merge if the space is less than is 0.74µm.
    logger.info('Executing rule NW.2a_MV')
    nw2a_l1 = connected_nwell_5p0v.not_inside(ymtp_mk).overlapping(dualgate)
    nw2a_l1.output('NW.2a_MV',
                   'NW.2a_MV : Min. Nwell Space (Outside DNWELL) [Equi-potential],
                    Merge if the space is less than. : 0.74µm')
    nw2a_l1.forget

    # Rule NW.2b_LV: Min. Nwell Space (Outside DNWELL) [Different potential] is 1.4µm.
    logger.info('Executing rule NW.2b_LV')
    nw2b_l1 = unconnected_nwell_3p3v.not_interacting(v5_xtor).not_interacting(dualgate)
    nw2b_l1.output('NW.2b_LV', 'NW.2b_LV : Min. Nwell Space (Outside DNWELL) [Different potential]: 1.4µm.')
    nw2b_l1.forget

    # Rule NW.2b_MV: Min. Nwell Space (Outside DNWELL) [Different potential] is 1.7µm.
    logger.info('Executing rule NW.2b_MV')
    nw2b_l1 = unconnected_nwell_5p0v.overlapping(dualgate)

  else
    logger.info('CONNECTIVITY_RULES disabled section')

    # Rule NW.2b_LV: Min. Nwell Space (Outside DNWELL) [Different potential] is 1.4µm.
    logger.info('Executing rule NW.2b_LV')
    nw2b_l1 = nw_lv.isolated(1.4.um, euclidian)
    nw2b_l1.output('NW.2b_LV', 'NW.2b_LV : Min. Nwell Space (Outside DNWELL) [Different potential]: 1.4µm')
    nw2b_l1.forget

    # Rule NW.2b_MV: Min. Nwell Space (Outside DNWELL) [Different potential] is 1.7µm.
    logger.info('Executing rule NW.2b_MV')
    nw2b_l1 = nw_mv.isolated(1.7.um, euclidian)

  end
  nw2b_l1.output('NW.2b_MV', 'NW.2b_MV : Min. Nwell Space (Outside DNWELL) [Different potential]: 1.7µm')
  nw2b_l1.forget # CONNECTIVITY_RULES

  # Rule NW.3: Min. Nwell to DNWELL space is 3.1µm.
  logger.info('Executing rule NW.3')
  nw3_l1 = nwell.separation(dnwell, 3.1.um, euclidian)
  nw3_l1.output('NW.3', 'NW.3 : Min. Nwell to DNWELL space: 3.1µm')
  nw3_l1.forget

  # Rule NW.4: Min. Nwell to LVPWELL space is 0um.
  logger.info('Executing rule NW.4')
  nw4_l1 = nwell.and(lvpwell)
  nw4_l1.output('NW.4', 'NW.4 : Min. Nwell to LVPWELL space: 0um')
  nw4_l1.forget

  # Rule NW.5_LV: Min. DNWELL enclose Nwell is 0.5µm.
  logger.info('Executing rule NW.5_LV')
  nw5_l1 = nw_lv.enclosed(dnwell, 0.5.um, euclidian).polygons(0.001.um)
  nw5_l2 = nw_lv.not_outside(dnwell).not(dnwell)
  nw5_l  = nw5_l1.join(nw5_l2)
  nw5_l.output('NW.5_LV', 'NW.5_LV : Min. DNWELL enclose Nwell: 0.5µm')
  nw5_l1.forget
  nw5_l2.forget
  nw5_l.forget
  nw_lv.forget

  # Rule NW.5_MV: Min. DNWELL enclose Nwell is 0.5µm.
  logger.info('Executing rule NW.5_MV')
  nw5_l1 = nw_mv.enclosed(dnwell, 0.5.um, euclidian).polygons(0.001.um)
  nw5_l2 = nwell.not_outside(dnwell).not(dnwell)
  nw5_l  = nw5_l1.join(nw5_l2)
  nw5_l.output('NW.5_MV', 'NW.5_MV : Min. DNWELL enclose Nwell: 0.5µm')
  nw5_l1.forget
  nw5_l2.forget
  nw5_l.forget
  nw_mv.forget

  # Rule NW.6: Nwell resistors can only exist outside DNWELL.
  logger.info('Executing rule NW.6')
  nw6_l1 = nwell.inside(res_mk).and(dnwell)
  nw6_l1.output('NW.6', 'NW.6 : Nwell resistors can only exist outside DNWELL.')
  nw6_l1.forget

  # Rule NW.6_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_05.html

  # Rule NW.7_LV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_05.html

  # Rule NW.7_MV is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_05.html
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #---------------------DNWELL---------------------
  #================================================

  # Rule DN.1: Min. DNWELL Width is 1.7µm
  logger.info('Executing rule DN.1')
  dn1_l1 = dnwell.width(1.7.um, euclidian)
  dn1_l1.output('DN.1', 'DN.1 : Min. DNWELL Width : 1.7µm')
  dn1_l1.forget

  if CONNECTIVITY_RULES
    logger.info('CONNECTIVITY_RULES section')

    connected_dnwell, unconnected_dnwell = conn_space(dnwell, 2.5, 5.42, euclidian)
    # Rule DN.2a: Min. DNWELL Space (Equi-potential), Merge if the space is less than is 2.5µm
    logger.info('Executing rule DN.2a')
    dn2a_l1 = connected_dnwell
    dn2a_l1.output('DN.2a', 'DN.2a : Min. DNWELL Space (Equi-potential), Merge if the space is less than : 2.5µm')
    dn2a_l1.forget

    # Rule DN.2b: Min. DNWELL Space (Different potential) is 5.42µm
    logger.info('Executing rule DN.2b')
    dn2b_l1 = unconnected_dnwell

  else
    logger.info('CONNECTIVITY_RULES disabled section')

    # Rule DN.2b_: Min. DNWELL Space (Different potential) is 5.42µm
    logger.info('Executing rule DN.2b')
    dn2b_l1 = dnwell.isolated(5.42.um, euclidian)

  end
  dn2b_l1.output('DN.2b', 'DN.2b : Min. DNWELL Space (Different potential) : 5.42µm')
  dn2b_l1.forget # CONNECTIVITY_RULES

  # Rule DN.3: Each DNWELL shall be directly surrounded by PCOMP guard ring
  ## tied to the P-substrate potential.
  logger.info('Executing rule DN.3')
  dn3_l1 = dnwell.not_inside(pcomp.holes.not(pcomp).interacting(dnwell, 1..1).extents)
  dn3_l2 = dnwell.inside(pcomp.holes.not(pcomp).covering(nat.or(ncomp).or(nwell).not_interacting(dnwell)))
  dn3_l = dn3_l1.or(dn3_l2)
  dn3_l.output('DN.3',
               'DN.3 : Each DNWELL shall be directly surrounded by PCOMP guard ring
                tied to the P-substrate potential.')
  dn3_l.forget
  dn3_l1.forget
  dn3_l2.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

if FEOL
  #================================================
  #--------------------5V SRAM---------------------
  #================================================

  logger.info('Starting 5V SRAM derivations')

  sram_mv = sramcore.overlapping(v5_xtor)
  nw_n_dn_sram = nwell_n_dn.and(sram_mv)
  poly_sram = poly2.and(sram_mv)
  comp_sram = comp.and(sram_mv)
  contact_sram = contact.and(sram_mv)
  lvpwell_dn_sram = lvpwell_dn.and(sram_mv)
  ncomp_dn_sram = ncomp.inside(dnwell).and(sramcore)

  # Rule S.DF.4c_MV: Min. (Nwell overlap of PCOMP) outside DNWELL. is 0.45µm
  logger.info('Executing rule S.DF.4c_MV')
  pcomp_out_dn_sram = pcomp.outside(dnwell).and(sram_mv)
  sdf4c_l1 = pcomp_out_dn_sram.enclosed(nw_n_dn_sram, 0.45.um, euclidian).polygons(0.001.um)
  sdf4c_l2 = pcomp_out_dn_sram.not_outside(nw_n_dn_sram).not(nw_n_dn_sram)
  sdf4c_l  = sdf4c_l1.or(sdf4c_l2)
  sdf4c_l.output('S.DF.4c_MV', 'S.DF.4c_MV : Min. (Nwell overlap of PCOMP) outside DNWELL. : 0.45µm')
  sdf4c_l1.forget
  sdf4c_l2.forget
  sdf4c_l.forget
  pcomp_out_dn_sram.forget

  # Rule S.DF.6_MV: Min. COMP extend beyond gate (it also means source/drain overhang). is 0.32µm
  logger.info('Executing rule S.DF.6_MV')
  sdf6_l1 = poly_sram.enclosed(comp_sram, 0.32.um, euclidian)
  sdf6_l1.output('S.DF.6_MV',
                 'S.DF.6_MV : Min. COMP extend beyond gate (it also means source/drain overhang). : 0.32µm')
  sdf6_l1.forget

  # Rule S.DF.7_MV: Min. (LVPWELL Spacer to PCOMP) inside DNWELL. is 0.45µm
  logger.info('Executing rule S.DF.7_MV')
  sdf7_l1 = pcomp.inside(dnwell).and(sram_mv).separation(lvpwell_dn_sram, 0.45.um, euclidian)
  sdf7_l1.output('S.DF.7_MV', 'S.DF.7_MV : Min. (LVPWELL Spacer to PCOMP) inside DNWELL. : 0.45µm')
  sdf7_l1.forget

  # Rule S.DF.8_MV: Min. (LVPWELL overlap of NCOMP) Inside DNWELL. is 0.45µm
  logger.info('Executing rule S.DF.8_MV')
  sdf8_l1 = ncomp_dn_sram.enclosed(lvpwell_dn_sram, 0.45.um, euclidian).polygons(0.001.um)
  sdf8_l2 = ncomp_dn_sram.not_outside(lvpwell_dn_sram).not(lvpwell_dn_sram)
  sdf8_l  = sdf8_l1.or(sdf8_l2)
  sdf8_l.output('S.DF.8_MV', 'S.DF.8_MV : Min. (LVPWELL overlap of NCOMP) Inside DNWELL. : 0.45µm')
  sdf8_l1.forget
  sdf8_l2.forget
  sdf8_l.forget
  lvpwell_dn_sram.forget
  ncomp_dn_sram.forget

  # Rule S.DF.16_MV: Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). is 0.45µm
  logger.info('Executing rule S.DF.16_MV')
  sdf16_l1 = ncomp.outside(nwell).outside(dnwell).and(sram_mv).separation(nw_n_dn_sram, 0.45.um, euclidian)
  sdf16_l1.output('S.DF.16_MV',
                  'S.DF.16_MV : Min. space from (Nwell outside DNWELL) to (NCOMP outside Nwell and DNWELL). : 0.45µm')
  sdf16_l1.forget
  sram_mv.forget
  nw_n_dn_sram.forget

  # Rule S.PL.5a_MV: Space from field Poly2 to unrelated
  ## COMP/Spacer from field Poly2 to Guard-ring. is 0.12µm
  logger.info('Executing rule S.PL.5a_MV')
  spl5a_l1 = poly_sram.not_overlapping(comp_sram).separation(comp_sram, 0.12.um, euclidian)
  spl5a_l1.output('S.PL.5a_MV', 'S.PL.5a_MV : Space from field Poly2 to unrelated
                   COMP/Spacer from field Poly2 to Guard-ring. : 0.12µm')
  spl5a_l1.forget

  # Rule S.PL.5b_MV: Space from field Poly2 to related COMP. is 0.12µm
  logger.info('Executing rule S.PL.5b_MV')
  spl5b_l1 = poly_sram.overlapping(comp_sram).separation(comp_sram, 0.12.um, euclidian)
  spl5b_l1.output('S.PL.5b_MV', 'S.PL.5b_MV : Space from field Poly2 to related COMP. : 0.12µm')
  spl5b_l1.forget
  poly_sram.forget

  # Rule S.CO.4_MV: COMP overlap of contact. is 0.04µm
  logger.info('Executing rule S.CO.4_MV')
  sco4_l1 = contact_sram.enclosed(comp_sram, 0.04.um, euclidian).polygons(0.001.um)
  sco4_l2 = contact_sram.not_outside(comp_sram).not(comp_sram)
  sco4_l  = sco4_l1.or(sco4_l2)
  sco4_l.output('S.CO.4_MV', 'S.CO.4_MV : COMP overlap of contact. : 0.04µm')
  sco4_l1.forget
  sco4_l2.forget
  sco4_l.forget
  comp_sram.forget
  contact_sram.forget

end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

#================================================
#---------------------EFUSE----------------------
#================================================

logger.info('Starting EFUSE derivations')

efuse_mk_pplus = efuse_mk.and(pplus)
plfuse_efuse = plfuse.and(efuse_mk)
poly_efuse = poly2.and(efuse_mk)
cathode = poly_efuse.not(lvs_source.join(plfuse))
anode = poly_efuse.and(lvs_source)
cathode_edges = cathode.edges
anode_edges = anode.edges
plfuse_edges = plfuse.edges

# Rule EF.01: Min. (Poly2 butt PLFUSE) within EFUSE_MK and Pplus is 0um.
logger.info('Executing rule EF.01')
ef01_l1 = poly2.join(plfuse).interacting(efuse_mk).not_inside(efuse_mk_pplus)
ef01_l1.output('EF.01', 'EF.01 : Min. (Poly2 butt PLFUSE) within EFUSE_MK and Pplus: 0um')
ef01_l1.forget

# Rule EF.02: Min./Max. PLFUSE width. is 0.18µm
logger.info('Executing rule EF.02')
ef02_l1 = plfuse.drc(width != 0.18.um)
ef02_l1.output('EF.02', 'EF.02 : Min./Max. PLFUSE width: 0.18µm')
ef02_l1.forget

# Rule EF.03: Min. Max. PLFUSE length. is 1.26µm
logger.info('Executing rule EF.03')
ef03_l1 = poly2.edges.and(plfuse_edges).centers(0, 0.95)
ef03_l = plfuse_edges.interacting(ef03_l1).without_length(1.26.um)
ef03_l.output('EF.03', 'EF.03 : Min. Max. PLFUSE length: 1.26µm')
ef03_l.forget
ef03_l1.forget

# Rule EF.04a: Min. Max. PLFUSE overlap Poly2
## (coinciding permitted) and touch cathode and anode.
logger.info('Executing rule EF.04a')
ef04a_exclude = plfuse.interacting(poly2.not(plfuse), 2, 2)
ef04a_l1 = plfuse.not_in(ef04a_exclude).inside(efuse_mk)
ef04a_l2 = plfuse.not(poly2).inside(efuse_mk)
ef04a_l = ef04a_l1.join(ef04a_l2)
ef04a_l.output('EF.04a', 'EF.04a : Min. Max. PLFUSE overlap Poly2
                (coinciding permitted) and touch cathode and anode.')
ef04a_l1.forget
ef04a_l.forget
ef04a_l1.forget
ef04a_l2.forget

# Rule EF.04b: PLFUSE must be rectangular.
logger.info('Executing rule EF.04b')
ef04b_l1 = plfuse.non_rectangles
ef04b_l1.output('EF.04b', 'EF.04b : PLFUSE must be rectangular.')
ef04b_l1.forget

# Rule EF.04c: Cathode Poly2 must be rectangular.
logger.info('Executing rule EF.04c')
ef04c_l1 = cathode.non_rectangles
ef04c_l1.output('EF.04c', 'EF.04c : Cathode Poly2 must be rectangular.')
ef04c_l1.forget

# Rule EF.04d: Anode Poly2 must be rectangular.
logger.info('Executing rule EF.04d')
ef04d_l1 = anode.non_rectangles
ef04d_l1.output('EF.04d', 'EF.04d : Anode Poly2 must be rectangular.')
ef04d_l1.forget

# Rule EF.05: Min./Max. LVS_Source overlap Poly2 (at Anode) is 0um.
logger.info('Executing rule EF.05')
ef05_l1 = poly_efuse.not(plfuse).interacting(lvs_source).not(lvs_source)
ef05_l2 = lvs_source.not(poly2).and(efuse_mk)
ef05_l = ef05_l1.join(ef05_l2)
ef05_l.output('EF.05', 'EF.05 : Min./Max. LVS_Source overlap Poly2 (at Anode): 0um')
ef05_l.forget
ef05_l1.forget
ef05_l2.forget
poly_efuse.forget

# Rule EF.06: Min./Max. Cathode Poly2 width. is 2.26µm
logger.info('Executing rule EF.06')
cathode_width = cathode_edges.not_interacting(cathode_edges.interacting(plfuse)).join(cathode_edges.interacting(plfuse))
ef06_l1 = cathode_width.without_length(2.26.um)
ef06_l1.output('EF.06', 'EF.06 : Min./Max. Cathode Poly2 width: 2.26µm')
ef06_l1.forget

# Rule EF.07: Min./Max. Cathode Poly2 length is 1.84µm.
logger.info('Executing rule EF.07')
ef07_l1 = cathode_edges.not(cathode_width).without_length(1.84.um)
ef07_l1.output('EF.07', 'EF.07 : Min./Max. Cathode Poly2 length: 1.84µm')
ef07_l1.forget

# Rule EF.08: Min./Max. Anode Poly2 width is 1.06µm.
logger.info('Executing rule EF.08')
anode_width = anode_edges.not_interacting(anode_edges.interacting(plfuse)).join(anode_edges.interacting(plfuse))
ef08_l1 = anode_width.without_length(1.06.um)
ef08_l1.output('EF.08', 'EF.08 : Min./Max. Anode Poly2 width: 1.06µm')
ef08_l1.forget

# Rule EF.09: Min./Max. Anode Poly2 length is 2.43µm.
logger.info('Executing rule EF.09')
ef09_l1 = anode_edges.not(anode_width).without_length(2.43.um)
ef09_l1.output('EF.09', 'EF.09 : Min./Max. Anode Poly2 length: 2.43µm')
ef09_l1.forget
anode_width.forget

# Rule EF.10: Min. Cathode Poly2 to Poly2 space. is 0.26µm
logger.info('Executing rule EF.10')
ef10_l1 = cathode.space(0.26.um, euclidian)
ef10_l1.output('EF.10', 'EF.10 : Min. Cathode Poly2 to Poly2 space: 0.26µm')
ef10_l1.forget

# Rule EF.11: Min. Anode Poly2 to Poly2 space. is 0.26µm
logger.info('Executing rule EF.11')
ef11_l1 = anode.space(0.26.um, euclidian)
ef11_l1.output('EF.11', 'EF.11 : Min. Anode Poly2 to Poly2 space: 0.26µm')
ef11_l1.forget

# Rule EF.12: Min. Space of Cathode Contact to PLFUSE end.
logger.info('Executing rule EF.12')
cont_ef = contact.and(plfuse_efuse)
ef12_l1 = plfuse_efuse.separation(contact.and(cathode), 0.155.um).polygons(0.001.um).join(cont_ef)
ef12_l1.output('EF.12', 'EF.12 : Min. Space of Cathode Contact to PLFUSE end.')
ef12_l1.forget

# Rule EF.13: Min. Space of Anode Contact to PLFUSE end.
logger.info('Executing rule EF.13')
ef13_l1 = plfuse_efuse.separation(contact.and(anode), 0.14.um).polygons(0.001.um).join(cont_ef)
ef13_l1.output('EF.13', 'EF.13 : Min. Space of Anode Contact to PLFUSE end.')
ef13_l1.forget
cont_ef.forget

# Rule EF.14: Min. EFUSE_MK enclose LVS_Source.
logger.info('Executing rule EF.14')
ef14_l1 = lvs_source.not_outside(efuse_mk).not(efuse_mk)
ef14_l1.output('EF.14', 'EF.14 : Min. EFUSE_MK enclose LVS_Source.')
ef14_l1.forget

# Rule EF.15: NO Contact is allowed to touch PLFUSE.
logger.info('Executing rule EF.15')
ef15_l1 = plfuse.interacting(contact)
ef15_l1.output('EF.15', 'EF.15 : NO Contact is allowed to touch PLFUSE.')
ef15_l1.forget

# Rule EF.16a: Cathode must contain exact number of Contacts at each ends. is 4µm
logger.info('Executing rule EF.16a')
ef16a_l1 = cathode.not_covering(contact, 4, 4)
ef16a_l1.output('EF.16a', 'EF.16a : Cathode must contain exact number of Contacts at each ends: 4µm')
ef16a_l1.forget

# Rule EF.16b: Anode must contain exact number of Contacts at each ends. is 4µm
logger.info('Executing rule EF.16b')
ef16b_l1 = anode.not_covering(contact, 4, 4)
ef16b_l1.output('EF.16b', 'EF.16b : Anode must contain exact number of Contacts at each ends: 4µm')
ef16b_l1.forget

# Rule EF.17: Min. Space of EFUSE_MK to EFUSE_MK. is 0.26µm
logger.info('Executing rule EF.17')
ef17_l1 = efuse_mk.space(0.26.um, euclidian)
ef17_l1.output('EF.17', 'EF.17 : Min. Space of EFUSE_MK to EFUSE_MK: 0.26µm')
ef17_l1.forget

# Rule EF.18: PLFUSE must sit on field oxide (NOT COMP), no cross with any
## COMP, Nplus, Pplus, ESD, SAB, Resistor, Metal1, Metal2.
logger.info('Executing rule EF.18')
ef18_exclude = comp.join(nplus).join(esd).join(sab).join(resistor).join(metal1).join(metal2)
ef18_l1 = plfuse.not(plfuse.outside(ef18_exclude))
ef18_l1.output('EF.18', 'EF.18 : PLFUSE must sit on field oxide (NOT COMP), no cross with any
                COMP, Nplus, Pplus, ESD, SAB, Resistor, Metal1, Metal2.')
ef18_l1.forget

# Rule EF.19: Min. PLFUSE space to Metal1, Metal2.
logger.info('Executing rule EF.19')
ef19_l1 = plfuse.not(plfuse.outside(metal1).outside(metal2))
ef19_l1.output('EF.19', 'EF.19 : Min. PLFUSE space to Metal1, Metal2.')
ef19_l1.forget

# Rule EF.20: Min. PLFUSE space to COMP, Nplus, Pplus, Resistor, ESD, SAB. is 2.73µm
logger.info('Executing rule EF.20')
ef20_l1 = plfuse.separation(comp + nplus + esd + sab + resistor, 2.73.um, euclidian)
ef20_l1.output('EF.20', 'EF.20 : Min. PLFUSE space to COMP, Nplus, Pplus, Resistor, ESD, SAB: 2.73µm')
ef20_l1.forget

# Rule EF.21: Min./Max. eFUSE Poly2 length. is 5.53µm
logger.info('Executing rule EF.21')
ef_21_fuse    = poly2.interacting(plfuse).inside(efuse_mk_pplus).extents.edges
ef_21_anode   = anode_edges.not_interacting(anode_edges.interacting(plfuse))
ef_21_cathode = cathode_edges.not_interacting(cathode_edges.interacting(plfuse))
ef21_l1 = ef_21_fuse.not_interacting(ef_21_anode.join(ef_21_cathode).centers(0, 0.95)).without_length(5.53.um)
ef21_l1.output('EF.21', 'EF.21 : Min./Max. eFUSE Poly2 length: 5.53µm')
ef21_l1.forget
ef_21_fuse.forget
ef_21_anode.forget
ef_21_cathode.forget
efuse_mk_pplus.forget

# Rule EF.22a: Min./Max. Cathode Poly2 overlap with PLFUSE in width direction. is 1.04µm
logger.info('Executing rule EF.22a')
ef22a_l1 = cathode_edges.interacting(plfuse).not(plfuse_edges).without_length(1.04.um)
ef22a_l1.output('EF.22a', 'EF.22a : Min./Max. Cathode Poly2 overlap with PLFUSE in width direction: 1.04µm')
ef22a_l1.forget
cathode_edges.forget

# Rule EF.22b: Min./Max. Anode Poly2 overlap with PLFUSE in width direction. is 0.44µm
logger.info('Executing rule EF.22b')
ef22b_l1 = anode_edges.interacting(plfuse).not(plfuse_edges).without_length(0.44.um)
ef22b_l1.output('EF.22b', 'EF.22b : Min./Max. Anode Poly2 overlap with PLFUSE in width direction: 0.44µm')
ef22b_l1.forget
plfuse_efuse.forget
plfuse_edges.forget
anode_edges.forget
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

# metal stack
if BEOL && (METAL_LEVEL == '5LM' || METAL_LEVEL == '6LM')
  #================================================
  #----------------------via4----------------------
  #================================================

  # Rule V4.1: Min/max Via1 size . is 0.26µm
  logger.info('Executing rule V4.1')
  v41_l1 = via4.edges.without_length(0.26.um)
  v41_l1.output('V4.1', 'V4.1 : Min/max Via1 size . : 0.26µm')
  v41_l1.forget

  # Rule V4.2a: min. via4 spacing is 0.26µm
  logger.info('Executing rule V4.2a')
  v42a_l1 = via4.space(0.26.um, euclidian)
  v42a_l1.output('V4.2a', 'V4.2a : min. via4 spacing : 0.26µm')
  v42a_l1.forget

  # Rule V4.2b: via4 Space in 4x4 or larger via4 array is 0.36µm
  logger.info('Executing rule V4.2b')
  via4_egde_length = 0.26 * 3 + 3 * 0.36
  poss_4_4_via4 = via4.sized(0.2, 'square_limit').merged.sized(-0.2, 'square_limit')
  via4_4x4_all = poss_4_4_via4.with_bbox_min(via4_egde_length..nil).interacting(via4, 16..nil)
  via4_4x4_loc_exc = via4_4x4_all.width(via4_egde_length,
                                        projection_limits(via4_egde_length..1000 * via4_egde_length)).polygons
  via4_4x4_loc = via4_4x4_all.not_interacting(via4_4x4_loc_exc)
  selected_via4 = via4.interacting(via4_4x4_loc)
  via4b_l1 = selected_via4.space(0.36.um, euclidian)
  via4b_l1.output('V4.2b', 'V4.2b : via4 Space in 4x4 or larger via4 array : 0.36µm')
  via4b_l1.forget
  poss_4_4_via4.forget
  via4_4x4_all.forget
  via4_4x4_loc_exc.forget
  via4_4x4_loc.forget
  selected_via4.forget

  # Rule V4.3a is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V4.3b: metal4  overlap of via4.
  logger.info('Executing rule V4.3b')
  v43b_l1 = via4.not(metal4)
  v43b_l2 = via4.enclosed(metal4, 0.01.um, euclidian).polygons(0.001.um)
  v43b_l = v43b_l1.or(v43b_l2)
  v43b_l.output('V4.3b', 'V4.3b : metal4 overlap of via4 >= 0.01')
  v43b_l1.forget
  v43b_l2.forget
  v43b_l.forget

  # Rule V4.3c: metal4 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V4.3c')
  v4p3c_cond = metal4.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v4p3c_eol_allowed = metal4.edges.with_length(nil, 0.34.um)
  v4p3c_cond_edge1 = v4p3c_cond.first_edges
  v4p3c_cond_edge2 = v4p3c_cond.second_edges
  v4p3c_eol = v4p3c_eol_allowed.interacting(v4p3c_cond_edge1).interacting(v4p3c_cond_edge2)
                               .not(v4p3c_cond_edge1).not(v4p3c_cond_edge2)
  v4p3c_l1 = via4.edges.enclosed(v4p3c_eol, 0.06.um, projection)
  v4p3c_l1.output('V4.3c', 'V4.3c : metal4 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v4p3c_l1.forget
  v4p3c_cond.forget
  v4p3c_eol.forget
  v4p3c_eol_allowed.forget
  v4p3c_cond_edge1.forget
  v4p3c_cond_edge2.forget

  # Rule V4.3d: If metal4 overlap via4 by < 0.04um on one side, adjacent metal4 edges overlap. : 0.06µm
  logger.info('Executing rule V4.3d')
  via4_3d_cond_edges = via4.edges.not_outside(via4.enclosed(metal4, 0.04.um, projection).edges)
  via4_3d_check_corner = via4_3d_cond_edges.extended_in(0.002.um)
  via4_3d_check = via4.edges.interacting(via4_3d_check_corner).not(via4_3d_cond_edges)
  via4_cond_corner = via4_3d_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via4_3d_l1 = via4_3d_check.enclosed(metal4.edges, 0.06.um, projection).polygons
  via4_3d_l2 = via4.interacting(via4_cond_corner)
  via4_3d_l = via4_3d_l1.or(via4_3d_l2)
  via4_3d_l.output('V4.3d',
                   'V4.3d : If metal4 overlap via4 by < 0.04um on one side, adjacent metal4 edges overlap. : 0.06µm')
  via4_3d_l.forget
  via4_3d_l2.forget
  via4_3d_l1.forget
  via4_3d_cond_edges.forget
  via4_3d_check_corner.forget
  via4_cond_corner.forget
  via4_3d_check.forget

  # Rule V4.3e is not a DRC check
  ## Please refer to https://gf180mcu-pdk.readthedocs.io/en/latest/physical_verification/design_manual/drm_07_15.html

  # Rule V4.4a: metal5 overlap of via4.
  logger.info('Executing rule V4.4a')
  via4_4a_l1 = via4.enclosed(metal5, 0.01.um, euclidian).polygons(0.001.um)
  via4_4a_l2 = via4.not(metal5)
  via4_4a_l = via4_4a_l1.or(via4_4a_l2)
  via4_4a_l.output('V4.4a', 'V4.4a : metal5 overlap of via4 >= 0.01 um')
  via4_4a_l1.forget
  via4_4a_l2.forget
  via4_4a_l.forget

  # Rule V4.4b: metal5 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
  ## excluding Metal branches shorter than 0.28µm.) is 0.06µm
  logger.info('Executing rule V4.4b')
  v4p4b_cond = metal5.width(0.34.um + 1.dbu).with_length(0.28.um, nil, both)
  v4p4b_eol_allowed = metal5.edges.with_length(nil, 0.34.um)
  v4p4b_eol = v4p4b_eol_allowed.interacting(v4p4b_cond.first_edges).interacting(v4p4b_cond.second_edges)
                               .not(v4p4b_cond.first_edges).not(v4p4b_cond.second_edges)
  v4p4b_l1 = via4.edges.enclosed(v4p4b_eol, 0.06.um, projection)
  v4p4b_l1.output('V4.4b', 'V4.4p : metal5 (< 0.34um) end-of-line overlap. (Applies to all < 0.34µm wide Metal lines,
                   excluding Metal branches shorter than 0.28µm.) : 0.06µm')
  v4p4b_l1.forget
  v4p4b_cond.forget
  v4p4b_eol.forget
  v4p4b_eol_allowed.forget

  # Rule V4.4c: If metal5 overlap via4 by < 0.04um on one side, adjacent metal5 edges overlap. : 0.06µm
  logger.info('Executing rule V4.4c')
  via4_4c_cond_edges = via4.edges.not_outside(via4.enclosed(metal5, 0.04.um, projection).edges)
  via4_4c_check_corner = via4_4c_cond_edges.extended_in(0.002.um)
  via4_4c_check = via4.edges.interacting(via4_4c_check_corner).not(via4_4c_cond_edges)
  via4_4c_cond_corner = via4_4c_cond_edges.width(0.002.um, angle_limit(135)).polygons
  via4_4c_l1 = via4_4c_check.enclosed(metal5.edges, 0.06.um, projection).polygons
  via4_4c_l2 = via4.interacting(via4_4c_cond_corner)
  via4_4c_l = via4_4c_l1.or(via4_4c_l2)
  via4_4c_l.output('V4.4c',
                   'V4.4c : If metal5 overlap via4 by < 0.04um on one side, adjacent metal5 edges overlap. : 0.06µm')
  via4_4c_l.forget
  via4_4c_l2.forget
  via4_4c_l1.forget
  via4_4c_cond_edges.forget
  via4_4c_check_corner.forget
  via4_4c_cond_corner.forget
  via4_4c_check.forget
end
################################################################################################
# Copyright 2022 GlobalFoundries PDK Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
################################################################################################

exec_end_time = Time.now
run_time = exec_end_time - exec_start_time
logger.info("#{$table_name} DRC Total Run time #{run_time} seconds")
